/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
(function (global, factory) {
  "use strict";

  if (( false ? 0 : _typeof(module)) === "object" && _typeof(module.exports) === "object") {
    // For CommonJS and CommonJS-like environments where a proper `window`
    // is present, execute the factory and get jQuery.
    // For environments that do not have a `window` with a `document`
    // (such as Node.js), expose a factory as module.exports.
    // This accentuates the need for the creation of a real `window`.
    // e.g. var jQuery = require("jquery")(window);
    // See ticket #14549 for more info.
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }

      return factory(w);
    };
  } else {
    factory(global);
  } // Pass this if window is not defined yet

})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
  // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
  // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
  // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
  // enough that all such attempts are guarded in a try block.
  "use strict";

  var arr = [];
  var getProto = Object.getPrototypeOf;
  var _slice = arr.slice;
  var flat = arr.flat ? function (array) {
    return arr.flat.call(array);
  } : function (array) {
    return arr.concat.apply([], array);
  };
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var fnToString = hasOwn.toString;
  var ObjectFunctionString = fnToString.call(Object);
  var support = {};

  var isFunction = function isFunction(obj) {
    // Support: Chrome <=57, Firefox <=52
    // In some browsers, typeof returns "function" for HTML <object> elements
    // (i.e., `typeof document.createElement( "object" ) === "function"`).
    // We don't want to classify *any* DOM node as a function.
    // Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
    // Plus for old WebKit, typeof returns "function" for HTML collections
    // (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
    return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
  };

  var isWindow = function isWindow(obj) {
    return obj != null && obj === obj.window;
  };

  var document = window.document;
  var preservedScriptAttributes = {
    type: true,
    src: true,
    nonce: true,
    noModule: true
  };

  function DOMEval(code, node, doc) {
    doc = doc || document;
    var i,
        val,
        script = doc.createElement("script");
    script.text = code;

    if (node) {
      for (i in preservedScriptAttributes) {
        // Support: Firefox 64+, Edge 18+
        // Some browsers don't support the "nonce" property on scripts.
        // On the other hand, just using `getAttribute` is not enough as
        // the `nonce` attribute is reset to an empty string whenever it
        // becomes browsing-context connected.
        // See https://github.com/whatwg/html/issues/2369
        // See https://html.spec.whatwg.org/#nonce-attributes
        // The `node.getAttribute` check was added for the sake of
        // `jQuery.globalEval` so that it can fake a nonce-containing node
        // via an object.
        val = node[i] || node.getAttribute && node.getAttribute(i);

        if (val) {
          script.setAttribute(i, val);
        }
      }
    }

    doc.head.appendChild(script).parentNode.removeChild(script);
  }

  function toType(obj) {
    if (obj == null) {
      return obj + "";
    } // Support: Android <=2.3 only (functionish RegExp)


    return _typeof(obj) === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : _typeof(obj);
  }
  /* global Symbol */
  // Defining this global in .eslintrc.json would create a danger of using the global
  // unguarded in another place, it seems safer to define global only for this module


  var version = "3.6.0",
      // Define a local copy of jQuery
  jQuery = function jQuery(selector, context) {
    // The jQuery object is actually just the init constructor 'enhanced'
    // Need init if jQuery is called (just allow error to be thrown if not included)
    return new jQuery.fn.init(selector, context);
  };

  jQuery.fn = jQuery.prototype = {
    // The current version of jQuery being used
    jquery: version,
    constructor: jQuery,
    // The default length of a jQuery object is 0
    length: 0,
    toArray: function toArray() {
      return _slice.call(this);
    },
    // Get the Nth element in the matched element set OR
    // Get the whole matched element set as a clean array
    get: function get(num) {
      // Return all the elements in a clean array
      if (num == null) {
        return _slice.call(this);
      } // Return just the one element from the set


      return num < 0 ? this[num + this.length] : this[num];
    },
    // Take an array of elements and push it onto the stack
    // (returning the new matched element set)
    pushStack: function pushStack(elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems); // Add the old object onto the stack (as a reference)

      ret.prevObject = this; // Return the newly-formed element set

      return ret;
    },
    // Execute a callback for every element in the matched set.
    each: function each(callback) {
      return jQuery.each(this, callback);
    },
    map: function map(callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function slice() {
      return this.pushStack(_slice.apply(this, arguments));
    },
    first: function first() {
      return this.eq(0);
    },
    last: function last() {
      return this.eq(-1);
    },
    even: function even() {
      return this.pushStack(jQuery.grep(this, function (_elem, i) {
        return (i + 1) % 2;
      }));
    },
    odd: function odd() {
      return this.pushStack(jQuery.grep(this, function (_elem, i) {
        return i % 2;
      }));
    },
    eq: function eq(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function end() {
      return this.prevObject || this.constructor();
    },
    // For internal use only.
    // Behaves like an Array's method, not like a jQuery method.
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };

  jQuery.extend = jQuery.fn.extend = function () {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false; // Handle a deep copy situation

    if (typeof target === "boolean") {
      deep = target; // Skip the boolean and the target

      target = arguments[i] || {};
      i++;
    } // Handle case when target is a string or something (possible in deep copy)


    if (_typeof(target) !== "object" && !isFunction(target)) {
      target = {};
    } // Extend jQuery itself if only one argument is passed


    if (i === length) {
      target = this;
      i--;
    }

    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          copy = options[name]; // Prevent Object.prototype pollution
          // Prevent never-ending loop

          if (name === "__proto__" || target === copy) {
            continue;
          } // Recurse if we're merging plain objects or arrays


          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
            src = target[name]; // Ensure proper type for the source value

            if (copyIsArray && !Array.isArray(src)) {
              clone = [];
            } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
              clone = {};
            } else {
              clone = src;
            }

            copyIsArray = false; // Never move original objects, clone them

            target[name] = jQuery.extend(deep, clone, copy); // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    } // Return the modified object


    return target;
  };

  jQuery.extend({
    // Unique for each copy of jQuery on the page
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    // Assume jQuery is ready without the ready module
    isReady: true,
    error: function error(msg) {
      throw new Error(msg);
    },
    noop: function noop() {},
    isPlainObject: function isPlainObject(obj) {
      var proto, Ctor; // Detect obvious negatives
      // Use toString instead of jQuery.type to catch host objects

      if (!obj || toString.call(obj) !== "[object Object]") {
        return false;
      }

      proto = getProto(obj); // Objects with no prototype (e.g., `Object.create( null )`) are plain

      if (!proto) {
        return true;
      } // Objects with prototype are plain iff they were constructed by a global Object function


      Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
      return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
    },
    isEmptyObject: function isEmptyObject(obj) {
      var name;

      for (name in obj) {
        return false;
      }

      return true;
    },
    // Evaluates a script in a provided context; falls back to the global one
    // if not specified.
    globalEval: function globalEval(code, options, doc) {
      DOMEval(code, {
        nonce: options && options.nonce
      }, doc);
    },
    each: function each(obj, callback) {
      var length,
          i = 0;

      if (isArrayLike(obj)) {
        length = obj.length;

        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }

      return obj;
    },
    // results is for internal usage only
    makeArray: function makeArray(arr, results) {
      var ret = results || [];

      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }

      return ret;
    },
    inArray: function inArray(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    // Support: Android <=4.0 only, PhantomJS 1 only
    // push.apply(_, arraylike) throws on ancient WebKit
    merge: function merge(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;

      for (; j < len; j++) {
        first[i++] = second[j];
      }

      first.length = i;
      return first;
    },
    grep: function grep(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert; // Go through the array, only saving the items
      // that pass the validator function

      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);

        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }

      return matches;
    },
    // arg is for internal usage only
    map: function map(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = []; // Go through the array, translating each of the items to their new values

      if (isArrayLike(elems)) {
        length = elems.length;

        for (; i < length; i++) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        } // Go through every key on the object,

      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);

          if (value != null) {
            ret.push(value);
          }
        }
      } // Flatten any nested arrays


      return flat(ret);
    },
    // A global GUID counter for objects
    guid: 1,
    // jQuery.support is not used in Core but other projects attach their
    // properties to it so it needs to exist.
    support: support
  });

  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  } // Populate the class2type map


  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (_i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });

  function isArrayLike(obj) {
    // Support: real iOS 8.2 only (not reproducible in simulator)
    // `in` check used to prevent JIT error (gh-2145)
    // hasOwn isn't used here due to false negatives
    // regarding Nodelist length in IE
    var length = !!obj && "length" in obj && obj.length,
        type = toType(obj);

    if (isFunction(obj) || isWindow(obj)) {
      return false;
    }

    return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
  }

  var Sizzle =
  /*!
   * Sizzle CSS Selector Engine v2.3.6
   * https://sizzlejs.com/
   *
   * Copyright JS Foundation and other contributors
   * Released under the MIT license
   * https://js.foundation/
   *
   * Date: 2021-02-16
   */
  function (window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        // Local document vars
    setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        // Instance-specific data
    expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        nonnativeSelectorCache = createCache(),
        sortOrder = function sortOrder(a, b) {
      if (a === b) {
        hasDuplicate = true;
      }

      return 0;
    },
        // Instance methods
    hasOwn = {}.hasOwnProperty,
        arr = [],
        pop = arr.pop,
        pushNative = arr.push,
        push = arr.push,
        slice = arr.slice,
        // Use a stripped-down indexOf as it's faster than native
    // https://jsperf.com/thor-indexof-vs-for/5
    indexOf = function indexOf(list, elem) {
      var i = 0,
          len = list.length;

      for (; i < len; i++) {
        if (list[i] === elem) {
          return i;
        }
      }

      return -1;
    },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" + "ismap|loop|multiple|open|readonly|required|scoped",
        // Regular expressions
    // http://www.w3.org/TR/css3-selectors/#whitespace
    whitespace = "[\\x20\\t\\r\\n\\f]",
        // https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
    identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
    attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
    "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5]
    // or strings [capture 3 or capture 4]"
    "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
    // 1. quoted (capture 3; capture 4 or capture 5)
    "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
    "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
    ".*" + ")\\)|)",
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
    rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rdescend = new RegExp(whitespace + "|>"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
      "ID": new RegExp("^#(" + identifier + ")"),
      "CLASS": new RegExp("^\\.(" + identifier + ")"),
      "TAG": new RegExp("^(" + identifier + "|[*])"),
      "ATTR": new RegExp("^" + attributes),
      "PSEUDO": new RegExp("^" + pseudos),
      "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
      "bool": new RegExp("^(?:" + booleans + ")$", "i"),
      // For use in libraries implementing .is()
      // We use this for POS matching in `select`
      "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
    },
        rhtml = /HTML$/i,
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
    rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        // CSS escapes
    // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
    runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g"),
        funescape = function funescape(escape, nonHex) {
      var high = "0x" + escape.slice(1) - 0x10000;
      return nonHex ? // Strip the backslash prefix from a non-hex escape sequence
      nonHex : // Replace a hexadecimal escape sequence with the encoded Unicode code point
      // Support: IE <=11+
      // For values outside the Basic Multilingual Plane (BMP), manually construct a
      // surrogate pair
      high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
    },
        // CSS string/identifier serialization
    // https://drafts.csswg.org/cssom/#common-serializing-idioms
    rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
        fcssescape = function fcssescape(ch, asCodePoint) {
      if (asCodePoint) {
        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
        if (ch === "\0") {
          return "\uFFFD";
        } // Control characters and (dependent upon position) numbers get escaped as code points


        return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
      } // Other potentially-special ASCII characters get backslash-escaped


      return "\\" + ch;
    },
        // Used for iframes
    // See setDocument()
    // Removing the function wrapper causes a "Permission Denied"
    // error in IE
    unloadHandler = function unloadHandler() {
      setDocument();
    },
        inDisabledFieldset = addCombinator(function (elem) {
      return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
    }, {
      dir: "parentNode",
      next: "legend"
    }); // Optimize for push.apply( _, NodeList )


    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0
      // Detect silently failing push.apply
      // eslint-disable-next-line no-unused-expressions

      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? // Leverage slice if possible
        function (target, els) {
          pushNative.apply(target, slice.call(els));
        } : // Support: IE<9
        // Otherwise append directly
        function (target, els) {
          var j = target.length,
              i = 0; // Can't trust NodeList.length

          while (target[j++] = els[i++]) {}

          target.length = j - 1;
        }
      };
    }

    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          // nodeType defaults to 9, since context defaults to document
      nodeType = context ? context.nodeType : 9;
      results = results || []; // Return early from calls with invalid selector or context

      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      } // Try to shortcut find operations (as opposed to filters) in HTML documents


      if (!seed) {
        setDocument(context);
        context = context || document;

        if (documentIsHTML) {
          // If the selector is sufficiently simple, try using a "get*By*" DOM method
          // (excepting DocumentFragment context, where the methods don't exist)
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            // ID selector
            if (m = match[1]) {
              // Document context
              if (nodeType === 9) {
                if (elem = context.getElementById(m)) {
                  // Support: IE, Opera, Webkit
                  // TODO: identify versions
                  // getElementById can match elements by name instead of ID
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                } // Element context

              } else {
                // Support: IE, Opera, Webkit
                // TODO: identify versions
                // getElementById can match elements by name instead of ID
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } // Type selector

            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results; // Class selector
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          } // Take advantage of querySelectorAll


          if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && ( // Support: IE 8 only
          // Exclude object elements
          nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
            newSelector = selector;
            newContext = context; // qSA considers elements outside a scoping root when evaluating child or
            // descendant combinators, which is not what we want.
            // In such cases, we work around the behavior by prefixing every selector in the
            // list with an ID selector referencing the scope context.
            // The technique has to be used as well when a leading combinator is used
            // as such selectors are not recognized by querySelectorAll.
            // Thanks to Andrew Dupont for this technique.

            if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
              // Expand context for sibling selectors
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context; // We can use :scope instead of the ID hack if the browser
              // supports it & if we're not changing the context.

              if (newContext !== context || !support.scope) {
                // Capture the context ID, setting it first if necessary
                if (nid = context.getAttribute("id")) {
                  nid = nid.replace(rcssescape, fcssescape);
                } else {
                  context.setAttribute("id", nid = expando);
                }
              } // Prefix every selector in the list


              groups = tokenize(selector);
              i = groups.length;

              while (i--) {
                groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
              }

              newSelector = groups.join(",");
            }

            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
              nonnativeSelectorCache(selector, true);
            } finally {
              if (nid === expando) {
                context.removeAttribute("id");
              }
            }
          }
        }
      } // All others


      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    /**
     * Create key-value caches of limited size
     * @returns {function(string, object)} Returns the Object data after storing it on itself with
     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
     *	deleting the oldest entry
     */


    function createCache() {
      var keys = [];

      function cache(key, value) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key + " ") > Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }

        return cache[key + " "] = value;
      }

      return cache;
    }
    /**
     * Mark a function for special use by Sizzle
     * @param {Function} fn The function to mark
     */


    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    /**
     * Support testing using an element
     * @param {Function} fn Passed the created element and returns a boolean result
     */


    function assert(fn) {
      var el = document.createElement("fieldset");

      try {
        return !!fn(el);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        } // release memory in IE


        el = null;
      }
    }
    /**
     * Adds the same handler for all of the specified attrs
     * @param {String} attrs Pipe-separated list of attributes
     * @param {Function} handler The method that will be applied
     */


    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;

      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    /**
     * Checks document order of two siblings
     * @param {Element} a
     * @param {Element} b
     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
     */


    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex; // Use IE sourceIndex if available on both nodes

      if (diff) {
        return diff;
      } // Check if b follows a


      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }

      return a ? 1 : -1;
    }
    /**
     * Returns a function to use in pseudos for input types
     * @param {String} type
     */


    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for buttons
     * @param {String} type
     */


    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    /**
     * Returns a function to use in pseudos for :enabled/:disabled
     * @param {Boolean} disabled true for :disabled; false for :enabled
     */


    function createDisabledPseudo(disabled) {
      // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
      return function (elem) {
        // Only certain elements can match :enabled or :disabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
        if ("form" in elem) {
          // Check for inherited disabledness on relevant non-disabled elements:
          // * listed form-associated elements in a disabled fieldset
          //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
          // * option elements in a disabled optgroup
          //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
          // All such elements have a "form" property.
          if (elem.parentNode && elem.disabled === false) {
            // Option elements defer to a parent optgroup if present
            if ("label" in elem) {
              if ("label" in elem.parentNode) {
                return elem.parentNode.disabled === disabled;
              } else {
                return elem.disabled === disabled;
              }
            } // Support: IE 6 - 11
            // Use the isDisabled shortcut property to check for disabled fieldset ancestors


            return elem.isDisabled === disabled || // Where there is no isDisabled, check manually

            /* jshint -W018 */
            elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
          }

          return elem.disabled === disabled; // Try to winnow out elements that can't be disabled before trusting the disabled property.
          // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
          // even exist on them, let alone have a boolean value.
        } else if ("label" in elem) {
          return elem.disabled === disabled;
        } // Remaining elements are neither :enabled nor :disabled


        return false;
      };
    }
    /**
     * Returns a function to use in pseudos for positionals
     * @param {Function} fn
     */


    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length; // Match elements found at the specified indexes

          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    /**
     * Checks a node for validity as a Sizzle context
     * @param {Element|Object=} context
     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
     */


    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    } // Expose support vars for convenience


    support = Sizzle.support = {};
    /**
     * Detects XML nodes
     * @param {Element|Object} elem An element or a document
     * @returns {Boolean} True iff elem is a non-HTML XML node
     */

    isXML = Sizzle.isXML = function (elem) {
      var namespace = elem && elem.namespaceURI,
          docElem = elem && (elem.ownerDocument || elem).documentElement; // Support: IE <=8
      // Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
      // https://bugs.jquery.com/ticket/4833

      return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML");
    };
    /**
     * Sets document-related variables once based on the current document
     * @param {Element|Object} [doc] An element or document object to use to set the document
     * @returns {Object} Returns the current document
     */


    setDocument = Sizzle.setDocument = function (node) {
      var hasCompare,
          subWindow,
          doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq

      if (doc == document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      } // Update global variables


      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document); // Support: IE 9 - 11+, Edge 12 - 18+
      // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq

      if (preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow) {
        // Support: IE 11, Edge
        if (subWindow.addEventListener) {
          subWindow.addEventListener("unload", unloadHandler, false); // Support: IE 9 - 10 only
        } else if (subWindow.attachEvent) {
          subWindow.attachEvent("onunload", unloadHandler);
        }
      } // Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
      // Safari 4 - 5 only, Opera <=11.6 - 12.x only
      // IE/Edge & older browsers don't support the :scope pseudo-class.
      // Support: Safari 6.0 only
      // Safari 6.0 supports :scope but it's an alias of :root there.


      support.scope = assert(function (el) {
        docElem.appendChild(el).appendChild(document.createElement("div"));
        return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
      });
      /* Attributes
      ---------------------------------------------------------------------- */
      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties
      // (excepting IE8 booleans)

      support.attributes = assert(function (el) {
        el.className = "i";
        return !el.getAttribute("className");
      });
      /* getElement(s)By*
      ---------------------------------------------------------------------- */
      // Check if getElementsByTagName("*") returns only elements

      support.getElementsByTagName = assert(function (el) {
        el.appendChild(document.createComment(""));
        return !el.getElementsByTagName("*").length;
      }); // Support: IE<9

      support.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programmatically-set names,
      // so use a roundabout getElementsByName test

      support.getById = assert(function (el) {
        docElem.appendChild(el).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      }); // ID filter and find

      if (support.getById) {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute("id") === attrId;
          };
        };

        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var elem = context.getElementById(id);
            return elem ? [elem] : [];
          }
        };
      } else {
        Expr.filter["ID"] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        }; // Support: IE 6 - 7 only
        // getElementById is not reliable as a find shortcut


        Expr.find["ID"] = function (id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var node,
                i,
                elems,
                elem = context.getElementById(id);

            if (elem) {
              // Verify the id attribute
              node = elem.getAttributeNode("id");

              if (node && node.value === id) {
                return [elem];
              } // Fall back on getElementsByName


              elems = context.getElementsByName(id);
              i = 0;

              while (elem = elems[i++]) {
                node = elem.getAttributeNode("id");

                if (node && node.value === id) {
                  return [elem];
                }
              }
            }

            return [];
          }
        };
      } // Tag


      Expr.find["TAG"] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function (tag, context) {
        var elem,
            tmp = [],
            i = 0,
            // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
        results = context.getElementsByTagName(tag); // Filter out possible comments

        if (tag === "*") {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }

          return tmp;
        }

        return results;
      }; // Class

      Expr.find["CLASS"] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      /* QSA/matchesSelector
      ---------------------------------------------------------------------- */
      // QSA and matchesSelector support
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)


      rbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See https://bugs.jquery.com/ticket/13378

      rbuggyQSA = [];

      if (support.qsa = rnative.test(document.querySelectorAll)) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (el) {
          var input; // Select is set to empty string on purpose
          // This is to test IE's treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // https://bugs.jquery.com/ticket/12359

          docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>"; // Support: IE8, Opera 11-12.16
          // Nothing should be selected when empty strings follow ^= or $= or *=
          // The test attribute must be unknown in Opera but "safe" for WinRT
          // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section

          if (el.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          } // Support: IE8
          // Boolean attributes and "value" are not treated correctly


          if (!el.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          } // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+


          if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          } // Support: IE 11+, Edge 15 - 18+
          // IE 11/Edge don't find elements on a `[name='']` query in some cases.
          // Adding a temporary attribute to the document before the selection works
          // around the issue.
          // Interestingly, IE 10 & older don't seem to have the issue.


          input = document.createElement("input");
          input.setAttribute("name", "");
          el.appendChild(input);

          if (!el.querySelectorAll("[name='']").length) {
            rbuggyQSA.push("\\[" + whitespace + "*name" + whitespace + "*=" + whitespace + "*(?:''|\"\")");
          } // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests


          if (!el.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          } // Support: Safari 8+, iOS 8+
          // https://bugs.webkit.org/show_bug.cgi?id=136851
          // In-page `selector#id sibling-combinator selector` fails


          if (!el.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          } // Support: Firefox <=3.6 - 5 only
          // Old Firefox doesn't throw on a badly-escaped identifier.


          el.querySelectorAll("\\\f");
          rbuggyQSA.push("[\\r\\n\\f]");
        });
        assert(function (el) {
          el.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>"; // Support: Windows 8 Native Apps
          // The type and name attributes are restricted during .innerHTML assignment

          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          el.appendChild(input).setAttribute("name", "D"); // Support: IE8
          // Enforce case-sensitivity of name attribute

          if (el.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          } // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests


          if (el.querySelectorAll(":enabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: IE9-11+
          // IE's :disabled selector does not pick up the children of disabled fieldsets


          docElem.appendChild(el).disabled = true;

          if (el.querySelectorAll(":disabled").length !== 2) {
            rbuggyQSA.push(":enabled", ":disabled");
          } // Support: Opera 10 - 11 only
          // Opera 10-11 does not throw on post-comma invalid pseudos


          el.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }

      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (el) {
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(el, "*"); // This should fail with an exception
          // Gecko does not error, returns false instead

          matches.call(el, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }

      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      /* Contains
      ---------------------------------------------------------------------- */

      hasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another
      // Purposefully self-exclusive
      // As in, an element does not contain itself

      contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }

        return false;
      };
      /* Sorting
      ---------------------------------------------------------------------- */
      // Document order sorting

      sortOrder = hasCompare ? function (a, b) {
        // Flag for duplicate removal
        if (a === b) {
          hasDuplicate = true;
          return 0;
        } // Sort on method existence if only one input has compareDocumentPosition


        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;

        if (compare) {
          return compare;
        } // Calculate position if both inputs belong to the same document
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.
        // eslint-disable-next-line eqeqeq


        compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected
        1; // Disconnected nodes

        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          // Choose the first element that is related to our preferred document
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          if (a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
            return -1;
          } // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq


          if (b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
            return 1;
          } // Maintain original order


          return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
        }

        return compare & 4 ? -1 : 1;
      } : function (a, b) {
        // Exit early if the nodes are identical
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }

        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b]; // Parentless nodes are either documents or disconnected

        if (!aup || !bup) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.

          /* eslint-disable eqeqeq */
          return a == document ? -1 : b == document ? 1 :
          /* eslint-enable eqeqeq */
          aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check
        } else if (aup === bup) {
          return siblingCheck(a, b);
        } // Otherwise we need full lists of their ancestors for comparison


        cur = a;

        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }

        cur = b;

        while (cur = cur.parentNode) {
          bp.unshift(cur);
        } // Walk down the tree looking for a discrepancy


        while (ap[i] === bp[i]) {
          i++;
        }

        return i ? // Do a sibling check if the nodes have a common ancestor
        siblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first
        // Support: IE 11+, Edge 17 - 18+
        // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
        // two documents; shallow comparisons work.

        /* eslint-disable eqeqeq */
        ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 :
        /* eslint-enable eqeqeq */
        0;
      };
      return document;
    };

    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };

    Sizzle.matchesSelector = function (elem, expr) {
      setDocument(elem);

      if (support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes

          if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
          // fragment in IE 9
          elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
          nonnativeSelectorCache(expr, true);
        }
      }

      return Sizzle(expr, document, null, [elem]).length > 0;
    };

    Sizzle.contains = function (context, elem) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((context.ownerDocument || context) != document) {
        setDocument(context);
      }

      return contains(context, elem);
    };

    Sizzle.attr = function (elem, name) {
      // Set document vars if needed
      // Support: IE 11+, Edge 17 - 18+
      // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
      // two documents; shallow comparisons work.
      // eslint-disable-next-line eqeqeq
      if ((elem.ownerDocument || elem) != document) {
        setDocument(elem);
      }

      var fn = Expr.attrHandle[name.toLowerCase()],
          // Don't get fooled by Object.prototype properties (jQuery #13807)
      val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };

    Sizzle.escape = function (sel) {
      return (sel + "").replace(rcssescape, fcssescape);
    };

    Sizzle.error = function (msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    /**
     * Document sorting and removing duplicates
     * @param {ArrayLike} results
     */


    Sizzle.uniqueSort = function (results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0; // Unless we *know* we can detect duplicates, assume their presence

      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);

      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }

        while (j--) {
          results.splice(duplicates[j], 1);
        }
      } // Clear input after sorting to release objects
      // See https://github.com/jquery/sizzle/pull/225


      sortInput = null;
      return results;
    };
    /**
     * Utility function for retrieving the text value of an array of DOM nodes
     * @param {Array|Element} elem
     */


    getText = Sizzle.getText = function (elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;

      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        while (node = elem[i++]) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (jQuery #11153)
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      } // Do not include comment or processing instruction nodes


      return ret;
    };

    Expr = Sizzle.selectors = {
      // Can be adjusted by the user
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {
          dir: "parentNode"
        },
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {
          dir: "previousSibling"
        }
      },
      preFilter: {
        "ATTR": function ATTR(match) {
          match[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted

          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }

          return match.slice(0, 4);
        },
        "CHILD": function CHILD(match) {
          /* matches from matchExpr["CHILD"]
          	1 type (only|nth|...)
          	2 what (child|of-type)
          	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
          	4 xn-component of xn+y argument ([+-]?\d*n|)
          	5 sign of xn-component
          	6 x of xn-component
          	7 sign of y-component
          	8 y of y-component
          */
          match[1] = match[1].toLowerCase();

          if (match[1].slice(0, 3) === "nth") {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            } // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1


            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +(match[7] + match[8] || match[3] === "odd"); // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }

          return match;
        },
        "PSEUDO": function PSEUDO(match) {
          var excess,
              unquoted = !match[6] && match[2];

          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          } // Accept quoted arguments as-is


          if (match[3]) {
            match[2] = match[4] || match[5] || ""; // Strip excess characters from unquoted arguments
          } else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)
          excess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis
          excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          } // Return only captures needed by the pseudo filter method (type and argument)


          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function TAG(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function CLASS(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function ATTR(name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);

            if (result == null) {
              return operator === "!=";
            }

            if (!operator) {
              return true;
            }

            result += "";
            /* eslint-disable max-len */

            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
            /* eslint-enable max-len */
          };
        },
        "CHILD": function CHILD(type, what, _argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? // Shortcut for :nth-*(n)
          function (elem) {
            return !!elem.parentNode;
          } : function (elem, _context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;

            if (parent) {
              // :(first|last|only)-(child|of-type)
              if (simple) {
                while (dir) {
                  node = elem;

                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  } // Reverse direction for :only-* (if we haven't yet done so)


                  start = dir = type === "only" && !start && "nextSibling";
                }

                return true;
              }

              start = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`

              if (forward && useCache) {
                // Seek `elem` from a previously-cached index
                // ...in a gzip-friendly way
                node = parent;
                outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                // Defend against cloned attroperties (jQuery gh-1709)

                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];

                while (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start
                diff = nodeIndex = 0) || start.pop()) {
                  // When found, cache indexes on `parent` and break
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                // Use previously-cached element index if available
                if (useCache) {
                  // ...in a gzip-friendly way
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                  // Defend against cloned attroperties (jQuery gh-1709)

                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                } // xml :nth-child(...)
                // or :nth-last-child(...) or :nth(-last)?-of-type(...)


                if (diff === false) {
                  // Use the same loop as above to seek `elem` from the start
                  while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      // Cache the index of each encountered element
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {}); // Support: IE <9 only
                        // Defend against cloned attroperties (jQuery gh-1709)

                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }

                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              } // Incorporate the offset, then check against cycle size


              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        "PSEUDO": function PSEUDO(pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo); // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does

          if (fn[expando]) {
            return fn(argument);
          } // But maintain support for old signatures


          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;

              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }

          return fn;
        }
      },
      pseudos: {
        // Potentially complex pseudos
        "not": markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function (seed, matches, _context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length; // Match elements unmatched by `matcher`

            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, _context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results); // Don't keep the element (issue #299)

            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function (text) {
          text = text.replace(runescape, funescape);
          return function (elem) {
            return (elem.textContent || getText(elem)).indexOf(text) > -1;
          };
        }),
        // "Whether an element is represented by a :lang() selector
        // is based solely on the element's language value
        // being equal to the identifier C,
        // or beginning with the identifier C immediately followed by "-".
        // The matching of C against the element's language value is performed case-insensitively.
        // The identifier C does not have to be a valid language name."
        // http://www.w3.org/TR/selectors/#lang-pseudo
        "lang": markFunction(function (lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }

          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;

            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);

            return false;
          };
        }),
        // Miscellaneous
        "target": function target(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function root(elem) {
          return elem === docElem;
        },
        "focus": function focus(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        // Boolean properties
        "enabled": createDisabledPseudo(false),
        "disabled": createDisabledPseudo(true),
        "checked": function checked(elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === "input" && !!elem.checked || nodeName === "option" && !!elem.selected;
        },
        "selected": function selected(elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            // eslint-disable-next-line no-unused-expressions
            elem.parentNode.selectedIndex;
          }

          return elem.selected === true;
        },
        // Contents
        "empty": function empty(elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
          //   but not by others (comment: 8; processing instruction: 7; etc.)
          // nodeType < 6 works because attributes (2) do not appear as children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }

          return true;
        },
        "parent": function parent(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        // Element/input types
        "header": function header(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function input(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function button(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function text(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ( // Support: IE<8
          // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
          (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        // Position-in-collection
        "first": createPositionalPseudo(function () {
          return [0];
        }),
        "last": createPositionalPseudo(function (_matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function (_matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;

          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument > length ? length : argument;

          for (; --i >= 0;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;

          for (; ++i < length;) {
            matchIndexes.push(i);
          }

          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"]; // Add button/input type pseudos

    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }

    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    } // Easy API for creating new setFilters


    function setFilters() {}

    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();

    tokenize = Sizzle.tokenize = function (selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];

      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }

      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;

      while (soFar) {
        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }

          groups.push(tokens = []);
        }

        matched = false; // Combinators

        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            // Cast descendant combinators to space
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        } // Filters


        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }

        if (!matched) {
          break;
        }
      } // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens


      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
      tokenCache(selector, groups).slice(0);
    };

    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";

      for (; i < len; i++) {
        selector += tokens[i].value;
      }

      return selector;
    }

    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          skip = combinator.next,
          key = skip || dir,
          checkNonElements = base && key === "parentNode",
          doneName = done++;
      return combinator.first ? // Check against closest ancestor/preceding element
      function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }

        return false;
      } : // Check against all ancestor/preceding elements
      function (elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching

        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only
              // Defend against cloned attroperties (jQuery gh-1709)

              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

              if (skip && skip === elem.nodeName.toLowerCase()) {
                elem = elem[dir] || elem;
              } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                // Assign to newCache so results back-propagate to previous elements
                return newCache[2] = oldCache[2];
              } else {
                // Reuse newcache so results back-propagate to previous elements
                uniqueCache[key] = newCache; // A match means we're done; a fail means we have to keep checking

                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }

        return false;
      };
    }

    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;

        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }

        return true;
      } : matchers[0];
    }

    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;

      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }

      return results;
    }

    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;

      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);

            if (mapped) {
              map.push(i);
            }
          }
        }
      }

      return newUnmatched;
    }

    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }

      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }

      return markFunction(function (seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            // Get initial elements from seed or context
        elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            // Prefilter to get matcher input, preserving a map for seed-results synchronization
        matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
        postFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary
        [] : // ...otherwise use results directly
        results : matcherIn; // Find primary matches

        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        } // Apply postFilter


        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn

          i = temp.length;

          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }

        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;

              while (i--) {
                if (elem = matcherOut[i]) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push(matcherIn[i] = elem);
                }
              }

              postFinder(null, matcherOut = [], temp, xml);
            } // Move matched elements from seed to results to keep them synchronized


            i = matcherOut.length;

            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          } // Add elements to results, through postFinder if defined

        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);

          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }

    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          // The foundational matcher ensures that elements are reachable from top-level context(s)
      matchContext = addCombinator(function (elem) {
        return elem === checkContext;
      }, implicitRelative, true),
          matchAnyContext = addCombinator(function (elem) {
        return indexOf(checkContext, elem) > -1;
      }, implicitRelative, true),
          matchers = [function (elem, context, xml) {
        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)

        checkContext = null;
        return ret;
      }];

      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher

          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;

            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }

            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`
            tokens.slice(0, i - 1).concat({
              value: tokens[i - 2].type === " " ? "*" : ""
            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }

          matchers.push(matcher);
        }
      }

      return elementMatcher(matchers);
    }

    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function superMatcher(seed, context, xml, results, outermost) {
        var elem,
            j,
            matcher,
            matchedCount = 0,
            i = "0",
            unmatched = seed && [],
            setMatched = [],
            contextBackup = outermostContext,
            // We must always have either seed elements or outermost context
        elems = seed || byElement && Expr.find["TAG"]("*", outermost),
            // Use integer dirruns iff this is the outermost matcher
        dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,
            len = elems.length;

        if (outermost) {
          // Support: IE 11+, Edge 17 - 18+
          // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
          // two documents; shallow comparisons work.
          // eslint-disable-next-line eqeqeq
          outermostContext = context == document || context || outermost;
        } // Add elements passing elementMatchers directly to results
        // Support: IE<9, Safari
        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id


        for (; i !== len && (elem = elems[i]) != null; i++) {
          if (byElement && elem) {
            j = 0; // Support: IE 11+, Edge 17 - 18+
            // IE/Edge sometimes throw a "Permission denied" error when strict-comparing
            // two documents; shallow comparisons work.
            // eslint-disable-next-line eqeqeq

            if (!context && elem.ownerDocument != document) {
              setDocument(elem);
              xml = !documentIsHTML;
            }

            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context || document, xml)) {
                results.push(elem);
                break;
              }
            }

            if (outermost) {
              dirruns = dirrunsUnique;
            }
          } // Track unmatched elements for set filters


          if (bySet) {
            // They will have gone through all possible matchers
            if (elem = !matcher && elem) {
              matchedCount--;
            } // Lengthen the array for every element, matched or not


            if (seed) {
              unmatched.push(elem);
            }
          }
        } // `i` is now the count of elements visited above, and adding it to `matchedCount`
        // makes the latter nonnegative.


        matchedCount += i; // Apply set filters to unmatched elements
        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
        // no element matchers and no seed.
        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
        // numerically zero.

        if (bySet && i !== matchedCount) {
          j = 0;

          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context, xml);
          }

          if (seed) {
            // Reintegrate element matches to eliminate the need for sorting
            if (matchedCount > 0) {
              while (i--) {
                if (!(unmatched[i] || setMatched[i])) {
                  setMatched[i] = pop.call(results);
                }
              }
            } // Discard index placeholder values to get only actual matches


            setMatched = condense(setMatched);
          } // Add matches to results


          push.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting

          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle.uniqueSort(results);
          }
        } // Override manipulation of globals by nested matchers


        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }

        return unmatched;
      };

      return bySet ? markFunction(superMatcher) : superMatcher;
    }

    compile = Sizzle.compile = function (selector, match
    /* Internal Use Only */
    ) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];

      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!match) {
          match = tokenize(selector);
        }

        i = match.length;

        while (i--) {
          cached = matcherFromTokens(match[i]);

          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        } // Cache the compiled function


        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization

        cached.selector = selector;
      }

      return cached;
    };
    /**
     * A low-level selection function that works with Sizzle's compiled
     *  selector functions
     * @param {String|Function} selector A selector or a pre-compiled
     *  selector function built with Sizzle.compile
     * @param {Element} context
     * @param {Array} [results]
     * @param {Array} [seed] A set of elements to match against
     */


    select = Sizzle.select = function (selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || []; // Try to minimize operations if there is only one selector in the list and no seed
      // (the latter of which guarantees us context)

      if (match.length === 1) {
        // Reduce context if the leading compound selector is an ID
        tokens = match[0] = match[0].slice(0);

        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];

          if (!context) {
            return results; // Precompiled matchers will still verify ancestry, so step up a level
          } else if (compiled) {
            context = context.parentNode;
          }

          selector = selector.slice(tokens.shift().value.length);
        } // Fetch a seed set for right-to-left matching


        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;

        while (i--) {
          token = tokens[i]; // Abort if we hit a combinator

          if (Expr.relative[type = token.type]) {
            break;
          }

          if (find = Expr.find[type]) {
            // Search, expanding context for leading sibling combinators
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              // If seed is empty or no tokens remain, we can return early
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);

              if (!selector) {
                push.apply(results, seed);
                return results;
              }

              break;
            }
          }
        }
      } // Compile and execute a filtering function if one is not provided
      // Provide `match` to avoid retokenization if we modified the selector above


      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    }; // One-time assignments
    // Sort stability


    support.sortStable = expando.split("").sort(sortOrder).join("") === expando; // Support: Chrome 14-35+
    // Always assume duplicates if they aren't passed to the comparison function

    support.detectDuplicates = !!hasDuplicate; // Initialize against the default document

    setDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*

    support.sortDetached = assert(function (el) {
      // Should return 1, but returns 4 (following)
      return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
    }); // Support: IE<8
    // Prevent attribute/property "interpolation"
    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx

    if (!assert(function (el) {
      el.innerHTML = "<a href='#'></a>";
      return el.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    } // Support: IE<9
    // Use defaultValue in place of getAttribute("value")


    if (!support.attributes || !assert(function (el) {
      el.innerHTML = "<input/>";
      el.firstChild.setAttribute("value", "");
      return el.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function (elem, _name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    } // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies


    if (!assert(function (el) {
      return el.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;

        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }

    return Sizzle;
  }(window);

  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors; // Deprecated

  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  jQuery.escapeSelector = Sizzle.escape;

  var dir = function dir(elem, _dir, until) {
    var matched = [],
        truncate = until !== undefined;

    while ((elem = elem[_dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }

        matched.push(elem);
      }
    }

    return matched;
  };

  var _siblings = function siblings(n, elem) {
    var matched = [];

    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }

    return matched;
  };

  var rneedsContext = jQuery.expr.match.needsContext;

  function nodeName(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }

  var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i; // Implement the identical functionality for filter and not

  function winnow(elements, qualifier, not) {
    if (isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    } // Single element


    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    } // Arraylike of elements (jQuery, arguments, Array)


    if (typeof qualifier !== "string") {
      return jQuery.grep(elements, function (elem) {
        return indexOf.call(qualifier, elem) > -1 !== not;
      });
    } // Filtered directly for both simple and complex selectors


    return jQuery.filter(qualifier, elements, not);
  }

  jQuery.filter = function (expr, elems, not) {
    var elem = elems[0];

    if (not) {
      expr = ":not(" + expr + ")";
    }

    if (elems.length === 1 && elem.nodeType === 1) {
      return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
    }

    return jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
      return elem.nodeType === 1;
    }));
  };

  jQuery.fn.extend({
    find: function find(selector) {
      var i,
          ret,
          len = this.length,
          self = this;

      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }

      ret = this.pushStack([]);

      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }

      return len > 1 ? jQuery.uniqueSort(ret) : ret;
    },
    filter: function filter(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function not(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function is(selector) {
      return !!winnow(this, // If this is a positional/relative selector, check membership in the returned set
      // so $("p:first").is("p:last") won't return true for a doc with two "p".
      typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  }); // Initialize a jQuery object
  // A central reference to the root jQuery(document)

  var rootjQuery,
      // A simple way to check for HTML strings
  // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
  // Strict HTML recognition (#11290: must start with <)
  // Shortcut simple #id case for speed
  rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,
      init = jQuery.fn.init = function (selector, context, root) {
    var match, elem; // HANDLE: $(""), $(null), $(undefined), $(false)

    if (!selector) {
      return this;
    } // Method init() accepts an alternate rootjQuery
    // so migrate can support jQuery.sub (gh-2101)


    root = root || rootjQuery; // Handle HTML strings

    if (typeof selector === "string") {
      if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
        // Assume that strings that start and end with <> are HTML and skip the regex check
        match = [null, selector, null];
      } else {
        match = rquickExpr.exec(selector);
      } // Match html or make sure no context is specified for #id


      if (match && (match[1] || !context)) {
        // HANDLE: $(html) -> $(array)
        if (match[1]) {
          context = context instanceof jQuery ? context[0] : context; // Option to run scripts is true for back-compat
          // Intentionally let the error be thrown if parseHTML is not present

          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true)); // HANDLE: $(html, props)

          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
            for (match in context) {
              // Properties of context are called as methods if possible
              if (isFunction(this[match])) {
                this[match](context[match]); // ...and otherwise set as attributes
              } else {
                this.attr(match, context[match]);
              }
            }
          }

          return this; // HANDLE: $(#id)
        } else {
          elem = document.getElementById(match[2]);

          if (elem) {
            // Inject the element directly into the jQuery object
            this[0] = elem;
            this.length = 1;
          }

          return this;
        } // HANDLE: $(expr, $(...))

      } else if (!context || context.jquery) {
        return (context || root).find(selector); // HANDLE: $(expr, context)
        // (which is just equivalent to: $(context).find(expr)
      } else {
        return this.constructor(context).find(selector);
      } // HANDLE: $(DOMElement)

    } else if (selector.nodeType) {
      this[0] = selector;
      this.length = 1;
      return this; // HANDLE: $(function)
      // Shortcut for document ready
    } else if (isFunction(selector)) {
      return root.ready !== undefined ? root.ready(selector) : // Execute immediately if ready is not present
      selector(jQuery);
    }

    return jQuery.makeArray(selector, this);
  }; // Give the init function the jQuery prototype for later instantiation


  init.prototype = jQuery.fn; // Initialize central reference

  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      // Methods guaranteed to produce a unique set when starting from a unique set
  guaranteedUnique = {
    children: true,
    contents: true,
    next: true,
    prev: true
  };
  jQuery.fn.extend({
    has: function has(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function () {
        var i = 0;

        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function closest(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          targets = typeof selectors !== "string" && jQuery(selectors); // Positional selectors never match, since there's no _selection_ context

      if (!rneedsContext.test(selectors)) {
        for (; i < l; i++) {
          for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
            // Always skip document fragments
            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : // Don't pass non-elements to Sizzle
            cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
              matched.push(cur);
              break;
            }
          }
        }
      }

      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    // Determine the position of an element within the set
    index: function index(elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      } // Index in selector


      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      } // Locate the position of the desired element


      return indexOf.call(this, // If it receives a jQuery object, the first element is used
      elem.jquery ? elem[0] : elem);
    },
    add: function add(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function addBack(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });

  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}

    return cur;
  }

  jQuery.each({
    parent: function parent(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function parents(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function parentsUntil(elem, _i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function next(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function prev(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function nextAll(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function prevAll(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function nextUntil(elem, _i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function prevUntil(elem, _i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function siblings(elem) {
      return _siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function children(elem) {
      return _siblings(elem.firstChild);
    },
    contents: function contents(elem) {
      if (elem.contentDocument != null && // Support: IE 11+
      // <object> elements with no `data` attribute has an object
      // `contentDocument` with a `null` prototype.
      getProto(elem.contentDocument)) {
        return elem.contentDocument;
      } // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
      // Treat the template element as a regular one in browsers that
      // don't support it.


      if (nodeName(elem, "template")) {
        elem = elem.content || elem;
      }

      return jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var matched = jQuery.map(this, fn, until);

      if (name.slice(-5) !== "Until") {
        selector = until;
      }

      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }

      if (this.length > 1) {
        // Remove duplicates
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        } // Reverse order for parents* and prev-derivatives


        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }

      return this.pushStack(matched);
    };
  });
  var rnothtmlwhite = /[^\x20\t\r\n\f]+/g; // Convert String-formatted options into Object-formatted ones

  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  /*
   * Create a callback list using the following parameters:
   *
   *	options: an optional list of space-separated options that will change how
   *			the callback list behaves or a more traditional option object
   *
   * By default a callback list will act like an event callback list and can be
   * "fired" multiple times.
   *
   * Possible options:
   *
   *	once:			will ensure the callback list can only be fired once (like a Deferred)
   *
   *	memory:			will keep track of previous values and will call any callback added
   *					after the list has been fired right away with the latest "memorized"
   *					values (like a Deferred)
   *
   *	unique:			will ensure a callback can only be added once (no duplicate in the list)
   *
   *	stopOnFalse:	interrupt callings when a callback returns false
   *
   */


  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

    var // Flag to know if list is currently firing
    firing,
        // Last fire value for non-forgettable lists
    memory,
        // Flag to know if list was already fired
    _fired,
        // Flag to prevent firing
    _locked,
        // Actual callback list
    list = [],
        // Queue of execution data for repeatable lists
    queue = [],
        // Index of currently firing callback (modified by add/remove as needed)
    firingIndex = -1,
        // Fire callbacks
    fire = function fire() {
      // Enforce single-firing
      _locked = _locked || options.once; // Execute callbacks for all pending executions,
      // respecting firingIndex overrides and runtime changes

      _fired = firing = true;

      for (; queue.length; firingIndex = -1) {
        memory = queue.shift();

        while (++firingIndex < list.length) {
          // Run callback and check for early termination
          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
            // Jump to end and forget the data so .add doesn't re-fire
            firingIndex = list.length;
            memory = false;
          }
        }
      } // Forget the data if we're done with it


      if (!options.memory) {
        memory = false;
      }

      firing = false; // Clean up if we're done firing for good

      if (_locked) {
        // Keep an empty list if we have data for future add calls
        if (memory) {
          list = []; // Otherwise, this object is spent
        } else {
          list = "";
        }
      }
    },
        // Actual Callbacks object
    self = {
      // Add a callback or a collection of callbacks to the list
      add: function add() {
        if (list) {
          // If we have memory from a past run, we should fire after adding
          if (memory && !firing) {
            firingIndex = list.length - 1;
            queue.push(memory);
          }

          (function add(args) {
            jQuery.each(args, function (_, arg) {
              if (isFunction(arg)) {
                if (!options.unique || !self.has(arg)) {
                  list.push(arg);
                }
              } else if (arg && arg.length && toType(arg) !== "string") {
                // Inspect recursively
                add(arg);
              }
            });
          })(arguments);

          if (memory && !firing) {
            fire();
          }
        }

        return this;
      },
      // Remove a callback from the list
      remove: function remove() {
        jQuery.each(arguments, function (_, arg) {
          var index;

          while ((index = jQuery.inArray(arg, list, index)) > -1) {
            list.splice(index, 1); // Handle firing indexes

            if (index <= firingIndex) {
              firingIndex--;
            }
          }
        });
        return this;
      },
      // Check if a given callback is in the list.
      // If no argument is given, return whether or not list has callbacks attached.
      has: function has(fn) {
        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
      },
      // Remove all callbacks from the list
      empty: function empty() {
        if (list) {
          list = [];
        }

        return this;
      },
      // Disable .fire and .add
      // Abort any current/pending executions
      // Clear all callbacks and values
      disable: function disable() {
        _locked = queue = [];
        list = memory = "";
        return this;
      },
      disabled: function disabled() {
        return !list;
      },
      // Disable .fire
      // Also disable .add unless we have memory (since it would have no effect)
      // Abort any pending executions
      lock: function lock() {
        _locked = queue = [];

        if (!memory && !firing) {
          list = memory = "";
        }

        return this;
      },
      locked: function locked() {
        return !!_locked;
      },
      // Call all callbacks with the given context and arguments
      fireWith: function fireWith(context, args) {
        if (!_locked) {
          args = args || [];
          args = [context, args.slice ? args.slice() : args];
          queue.push(args);

          if (!firing) {
            fire();
          }
        }

        return this;
      },
      // Call all the callbacks with the given arguments
      fire: function fire() {
        self.fireWith(this, arguments);
        return this;
      },
      // To know if the callbacks have already been called at least once
      fired: function fired() {
        return !!_fired;
      }
    };

    return self;
  };

  function Identity(v) {
    return v;
  }

  function Thrower(ex) {
    throw ex;
  }

  function adoptValue(value, resolve, reject, noValue) {
    var method;

    try {
      // Check for promise aspect first to privilege synchronous behavior
      if (value && isFunction(method = value.promise)) {
        method.call(value).done(resolve).fail(reject); // Other thenables
      } else if (value && isFunction(method = value.then)) {
        method.call(value, resolve, reject); // Other non-thenables
      } else {
        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
        // * false: [ value ].slice( 0 ) => resolve( value )
        // * true: [ value ].slice( 1 ) => resolve()
        resolve.apply(undefined, [value].slice(noValue));
      } // For Promises/A+, convert exceptions into rejections
      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
      // Deferred#then to conditionally suppress rejection.

    } catch (value) {
      // Support: Android 4.0 only
      // Strict mode functions invoked without .call/.apply get global-object context
      reject.apply(undefined, [value]);
    }
  }

  jQuery.extend({
    Deferred: function Deferred(func) {
      var tuples = [// action, add listener, callbacks,
      // ... .then handlers, argument index, [final state]
      ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]],
          _state = "pending",
          _promise = {
        state: function state() {
          return _state;
        },
        always: function always() {
          deferred.done(arguments).fail(arguments);
          return this;
        },
        "catch": function _catch(fn) {
          return _promise.then(null, fn);
        },
        // Keep pipe for back-compat
        pipe: function pipe()
        /* fnDone, fnFail, fnProgress */
        {
          var fns = arguments;
          return jQuery.Deferred(function (newDefer) {
            jQuery.each(tuples, function (_i, tuple) {
              // Map tuples (progress, done, fail) to arguments (done, fail, progress)
              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })
              // deferred.done(function() { bind to newDefer or newDefer.resolve })
              // deferred.fail(function() { bind to newDefer or newDefer.reject })

              deferred[tuple[1]](function () {
                var returned = fn && fn.apply(this, arguments);

                if (returned && isFunction(returned.promise)) {
                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                } else {
                  newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                }
              });
            });
            fns = null;
          }).promise();
        },
        then: function then(onFulfilled, onRejected, onProgress) {
          var maxDepth = 0;

          function resolve(depth, deferred, handler, special) {
            return function () {
              var that = this,
                  args = arguments,
                  mightThrow = function mightThrow() {
                var returned, then; // Support: Promises/A+ section 2.3.3.3.3
                // https://promisesaplus.com/#point-59
                // Ignore double-resolution attempts

                if (depth < maxDepth) {
                  return;
                }

                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1
                // https://promisesaplus.com/#point-48

                if (returned === deferred.promise()) {
                  throw new TypeError("Thenable self-resolution");
                } // Support: Promises/A+ sections 2.3.3.1, 3.5
                // https://promisesaplus.com/#point-54
                // https://promisesaplus.com/#point-75
                // Retrieve `then` only once


                then = returned && ( // Support: Promises/A+ section 2.3.4
                // https://promisesaplus.com/#point-64
                // Only check objects and functions for thenability
                _typeof(returned) === "object" || typeof returned === "function") && returned.then; // Handle a returned thenable

                if (isFunction(then)) {
                  // Special processors (notify) just wait for resolution
                  if (special) {
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress
                  } else {
                    // ...and disregard older resolution values
                    maxDepth++;
                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));
                  } // Handle all other returned values

                } else {
                  // Only substitute handlers pass on context
                  // and multiple values (non-spec behavior)
                  if (handler !== Identity) {
                    that = undefined;
                    args = [returned];
                  } // Process the value(s)
                  // Default process is resolve


                  (special || deferred.resolveWith)(that, args);
                }
              },
                  // Only normal processors (resolve) catch and reject exceptions
              process = special ? mightThrow : function () {
                try {
                  mightThrow();
                } catch (e) {
                  if (jQuery.Deferred.exceptionHook) {
                    jQuery.Deferred.exceptionHook(e, process.stackTrace);
                  } // Support: Promises/A+ section 2.3.3.3.4.1
                  // https://promisesaplus.com/#point-61
                  // Ignore post-resolution exceptions


                  if (depth + 1 >= maxDepth) {
                    // Only substitute handlers pass on context
                    // and multiple values (non-spec behavior)
                    if (handler !== Thrower) {
                      that = undefined;
                      args = [e];
                    }

                    deferred.rejectWith(that, args);
                  }
                }
              }; // Support: Promises/A+ section 2.3.3.3.1
              // https://promisesaplus.com/#point-57
              // Re-resolve promises immediately to dodge false rejection from
              // subsequent errors


              if (depth) {
                process();
              } else {
                // Call an optional hook to record the stack, in case of exception
                // since it's otherwise lost when execution goes async
                if (jQuery.Deferred.getStackHook) {
                  process.stackTrace = jQuery.Deferred.getStackHook();
                }

                window.setTimeout(process);
              }
            };
          }

          return jQuery.Deferred(function (newDefer) {
            // progress_handlers.add( ... )
            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )

            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )

            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
          }).promise();
        },
        // Get a promise for this deferred
        // If obj is provided, the promise aspect is added to the object
        promise: function promise(obj) {
          return obj != null ? jQuery.extend(obj, _promise) : _promise;
        }
      },
          deferred = {}; // Add list-specific methods

      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2],
            stateString = tuple[5]; // promise.progress = list.add
        // promise.done = list.add
        // promise.fail = list.add

        _promise[tuple[1]] = list.add; // Handle state

        if (stateString) {
          list.add(function () {
            // state = "resolved" (i.e., fulfilled)
            // state = "rejected"
            _state = stateString;
          }, // rejected_callbacks.disable
          // fulfilled_callbacks.disable
          tuples[3 - i][2].disable, // rejected_handlers.disable
          // fulfilled_handlers.disable
          tuples[3 - i][3].disable, // progress_callbacks.lock
          tuples[0][2].lock, // progress_handlers.lock
          tuples[0][3].lock);
        } // progress_handlers.fire
        // fulfilled_handlers.fire
        // rejected_handlers.fire


        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }
        // deferred.resolve = function() { deferred.resolveWith(...) }
        // deferred.reject = function() { deferred.rejectWith(...) }

        deferred[tuple[0]] = function () {
          deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
          return this;
        }; // deferred.notifyWith = list.fireWith
        // deferred.resolveWith = list.fireWith
        // deferred.rejectWith = list.fireWith


        deferred[tuple[0] + "With"] = list.fireWith;
      }); // Make the deferred a promise

      _promise.promise(deferred); // Call given func if any


      if (func) {
        func.call(deferred, deferred);
      } // All done!


      return deferred;
    },
    // Deferred helper
    when: function when(singleValue) {
      var // count of uncompleted subordinates
      remaining = arguments.length,
          // count of unprocessed arguments
      i = remaining,
          // subordinate fulfillment data
      resolveContexts = Array(i),
          resolveValues = _slice.call(arguments),
          // the primary Deferred
      primary = jQuery.Deferred(),
          // subordinate callback factory
      updateFunc = function updateFunc(i) {
        return function (value) {
          resolveContexts[i] = this;
          resolveValues[i] = arguments.length > 1 ? _slice.call(arguments) : value;

          if (! --remaining) {
            primary.resolveWith(resolveContexts, resolveValues);
          }
        };
      }; // Single- and empty arguments are adopted like Promise.resolve


      if (remaining <= 1) {
        adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)

        if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
          return primary.then();
        }
      } // Multiple arguments are aggregated like Promise.all array elements


      while (i--) {
        adoptValue(resolveValues[i], updateFunc(i), primary.reject);
      }

      return primary.promise();
    }
  }); // These usually indicate a programmer mistake during development,
  // warn about them ASAP rather than swallowing them by default.

  var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

  jQuery.Deferred.exceptionHook = function (error, stack) {
    // Support: IE 8 - 9 only
    // Console exists when dev tools are open, which can happen at any time
    if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
      window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
    }
  };

  jQuery.readyException = function (error) {
    window.setTimeout(function () {
      throw error;
    });
  }; // The deferred used on DOM ready


  var readyList = jQuery.Deferred();

  jQuery.fn.ready = function (fn) {
    readyList.then(fn) // Wrap jQuery.readyException in a function so that the lookup
    // happens at the time of error handling instead of callback
    // registration.
    .catch(function (error) {
      jQuery.readyException(error);
    });
    return this;
  };

  jQuery.extend({
    // Is the DOM ready to be used? Set to true once it occurs.
    isReady: false,
    // A counter to track how many items to wait for before
    // the ready event fires. See #6781
    readyWait: 1,
    // Handle when the DOM is ready
    ready: function ready(wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      } // Remember that the DOM is ready


      jQuery.isReady = true; // If a normal DOM Ready event fired, decrement, and wait if need be

      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      } // If there are functions bound, to execute


      readyList.resolveWith(document, [jQuery]);
    }
  });
  jQuery.ready.then = readyList.then; // The ready event handler and self cleanup method

  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  } // Catch cases where $(document).ready() is called
  // after the browser event has already occurred.
  // Support: IE <=9 - 10 only
  // Older IE sometimes signals "interactive" too soon


  if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) {
    // Handle it asynchronously to allow scripts the opportunity to delay ready
    window.setTimeout(jQuery.ready);
  } else {
    // Use the handy event callback
    document.addEventListener("DOMContentLoaded", completed); // A fallback to window.onload, that will always work

    window.addEventListener("load", completed);
  } // Multifunctional method to get and set values of a collection
  // The value/s can optionally be executed if it's a function


  var access = function access(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null; // Sets many values

    if (toType(key) === "object") {
      chainable = true;

      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      } // Sets one value

    } else if (value !== undefined) {
      chainable = true;

      if (!isFunction(value)) {
        raw = true;
      }

      if (bulk) {
        // Bulk operations run against the entire set
        if (raw) {
          fn.call(elems, value);
          fn = null; // ...except when executing function values
        } else {
          bulk = fn;

          fn = function fn(elem, _key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }

      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }

    if (chainable) {
      return elems;
    } // Gets


    if (bulk) {
      return fn.call(elems);
    }

    return len ? fn(elems[0], key) : emptyGet;
  }; // Matches dashed string for camelizing


  var rmsPrefix = /^-ms-/,
      rdashAlpha = /-([a-z])/g; // Used by camelCase as callback to replace()

  function fcamelCase(_all, letter) {
    return letter.toUpperCase();
  } // Convert dashed to camelCase; used by the css and data modules
  // Support: IE <=9 - 11, Edge 12 - 15
  // Microsoft forgot to hump their vendor prefix (#9572)


  function camelCase(string) {
    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
  }

  var acceptData = function acceptData(owner) {
    // Accepts only:
    //  - Node
    //    - Node.ELEMENT_NODE
    //    - Node.DOCUMENT_NODE
    //  - Object
    //    - Any
    return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
  };

  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }

  Data.uid = 1;
  Data.prototype = {
    cache: function cache(owner) {
      // Check if the owner object already has a cache
      var value = owner[this.expando]; // If not, create one

      if (!value) {
        value = {}; // We can accept data for non-element nodes in modern browsers,
        // but we should not, see #8335.
        // Always return an empty object.

        if (acceptData(owner)) {
          // If it is a node unlikely to be stringify-ed or looped over
          // use plain assignment
          if (owner.nodeType) {
            owner[this.expando] = value; // Otherwise secure it in a non-enumerable property
            // configurable must be true to allow the property to be
            // deleted when data is removed
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }

      return value;
    },
    set: function set(owner, data, value) {
      var prop,
          cache = this.cache(owner); // Handle: [ owner, key, value ] args
      // Always use camelCase key (gh-2257)

      if (typeof data === "string") {
        cache[camelCase(data)] = value; // Handle: [ owner, { properties } ] args
      } else {
        // Copy the properties one-by-one to the cache object
        for (prop in data) {
          cache[camelCase(prop)] = data[prop];
        }
      }

      return cache;
    },
    get: function get(owner, key) {
      return key === undefined ? this.cache(owner) : // Always use camelCase key (gh-2257)
      owner[this.expando] && owner[this.expando][camelCase(key)];
    },
    access: function access(owner, key, value) {
      // In cases where either:
      //
      //   1. No key was specified
      //   2. A string key was specified, but no value provided
      //
      // Take the "read" path and allow the get method to determine
      // which value to return, respectively either:
      //
      //   1. The entire cache object
      //   2. The data stored at the key
      //
      if (key === undefined || key && typeof key === "string" && value === undefined) {
        return this.get(owner, key);
      } // When the key is not a string, or both a key and value
      // are specified, set or extend (existing objects) with either:
      //
      //   1. An object of properties
      //   2. A key and value
      //


      this.set(owner, key, value); // Since the "set" path can have two possible entry points
      // return the expected data based on which path was taken[*]

      return value !== undefined ? value : key;
    },
    remove: function remove(owner, key) {
      var i,
          cache = owner[this.expando];

      if (cache === undefined) {
        return;
      }

      if (key !== undefined) {
        // Support array or space separated string of keys
        if (Array.isArray(key)) {
          // If key is an array of keys...
          // We always set camelCase keys, so remove that.
          key = key.map(camelCase);
        } else {
          key = camelCase(key); // If a key with the spaces exists, use it.
          // Otherwise, create an array by matching non-whitespace

          key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
        }

        i = key.length;

        while (i--) {
          delete cache[key[i]];
        }
      } // Remove the expando if there's no more data


      if (key === undefined || jQuery.isEmptyObject(cache)) {
        // Support: Chrome <=35 - 45
        // Webkit & Blink performance suffers when deleting properties
        // from DOM nodes, so set to undefined instead
        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function hasData(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data(); //	Implementation Summary
  //
  //	1. Enforce API surface and semantic compatibility with 1.9.x branch
  //	2. Improve the module's maintainability by reducing the storage
  //		paths to a single mechanism.
  //	3. Use the same single mechanism to support "private" and "user" data.
  //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
  //	5. Avoid exposing implementation details on user objects (eg. expando properties)
  //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;

  function getData(data) {
    if (data === "true") {
      return true;
    }

    if (data === "false") {
      return false;
    }

    if (data === "null") {
      return null;
    } // Only convert to a number if it doesn't change the string


    if (data === +data + "") {
      return +data;
    }

    if (rbrace.test(data)) {
      return JSON.parse(data);
    }

    return data;
  }

  function dataAttr(elem, key, data) {
    var name; // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute

    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);

      if (typeof data === "string") {
        try {
          data = getData(data);
        } catch (e) {} // Make sure we set the data so it isn't changed later


        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }

    return data;
  }

  jQuery.extend({
    hasData: function hasData(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function data(elem, name, _data) {
      return dataUser.access(elem, name, _data);
    },
    removeData: function removeData(elem, name) {
      dataUser.remove(elem, name);
    },
    // TODO: Now that all calls to _data and _removeData have been replaced
    // with direct calls to dataPriv methods, these can be deprecated.
    _data: function _data(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function _removeData(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function data(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes; // Gets all values

      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);

          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;

            while (i--) {
              // Support: IE 11 only
              // The attrs elements can be null (#14894)
              if (attrs[i]) {
                name = attrs[i].name;

                if (name.indexOf("data-") === 0) {
                  name = camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }

            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }

        return data;
      } // Sets multiple values


      if (_typeof(key) === "object") {
        return this.each(function () {
          dataUser.set(this, key);
        });
      }

      return access(this, function (value) {
        var data; // The calling jQuery object (element matches) is not empty
        // (and therefore has an element appears at this[ 0 ]) and the
        // `value` parameter was not undefined. An empty jQuery object
        // will result in `undefined` for elem = this[ 0 ] which will
        // throw an exception if an attempt to read a data cache is made.

        if (elem && value === undefined) {
          // Attempt to get data from the cache
          // The key will always be camelCased in Data
          data = dataUser.get(elem, key);

          if (data !== undefined) {
            return data;
          } // Attempt to "discover" the data in
          // HTML5 custom data-* attrs


          data = dataAttr(elem, key);

          if (data !== undefined) {
            return data;
          } // We tried really hard, but the data doesn't exist.


          return;
        } // Set the data...


        this.each(function () {
          // We always store the camelCased key
          dataUser.set(this, key, value);
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function removeData(key) {
      return this.each(function () {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function queue(elem, type, data) {
      var queue;

      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup

        if (data) {
          if (!queue || Array.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }

        return queue || [];
      }
    },
    dequeue: function dequeue(elem, type) {
      type = type || "fx";

      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function next() {
        jQuery.dequeue(elem, type);
      }; // If the fx queue is dequeued, always remove the progress sentinel


      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }

      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === "fx") {
          queue.unshift("inprogress");
        } // Clear up the last queue stop function


        delete hooks.stop;
        fn.call(elem, next, hooks);
      }

      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    // Not public - generate a queueHooks object, or return the current one
    _queueHooks: function _queueHooks(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
        empty: jQuery.Callbacks("once memory").add(function () {
          dataPriv.remove(elem, [type + "queue", key]);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function queue(type, data) {
      var setter = 2;

      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }

      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }

      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue

        jQuery._queueHooks(this, type);

        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function dequeue(type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function clearQueue(type) {
      return this.queue(type || "fx", []);
    },
    // Get a promise resolved when queues of a certain type
    // are emptied (fx is the type by default)
    promise: function promise(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function resolve() {
        if (! --count) {
          defer.resolveWith(elements, [elements]);
        }
      };

      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }

      type = type || "fx";

      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");

        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }

      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var documentElement = document.documentElement;

  var isAttached = function isAttached(elem) {
    return jQuery.contains(elem.ownerDocument, elem);
  },
      composed = {
    composed: true
  }; // Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
  // Check attachment across shadow DOM boundaries when possible (gh-3504)
  // Support: iOS 10.0-10.2 only
  // Early iOS 10 versions support `attachShadow` but not `getRootNode`,
  // leading to errors. We need to check for `getRootNode`.


  if (documentElement.getRootNode) {
    isAttached = function isAttached(elem) {
      return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
    };
  }

  var isHiddenWithinTree = function isHiddenWithinTree(elem, el) {
    // isHiddenWithinTree might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem; // Inline style trumps all

    return elem.style.display === "none" || elem.style.display === "" && // Otherwise, check computed style
    // Support: Firefox <=43 - 45
    // Disconnected elements can have computed display: none, so first confirm that elem is
    // in the document.
    isAttached(elem) && jQuery.css(elem, "display") === "none";
  };

  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale,
        maxIterations = 20,
        currentValue = tween ? function () {
      return tween.cur();
    } : function () {
      return jQuery.css(elem, prop, "");
    },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        // Starting value computation is required for potential unit mismatches
    initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

    if (initialInUnit && initialInUnit[3] !== unit) {
      // Support: Firefox <=54
      // Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
      initial = initial / 2; // Trust units reported by jQuery.css

      unit = unit || initialInUnit[3]; // Iteratively approximate from a nonzero starting point

      initialInUnit = +initial || 1;

      while (maxIterations--) {
        // Evaluate and update our best guess (doubling guesses that zero out).
        // Finish if the scale equals or crosses 1 (making the old*new product non-positive).
        jQuery.style(elem, prop, initialInUnit + unit);

        if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
          maxIterations = 0;
        }

        initialInUnit = initialInUnit / scale;
      }

      initialInUnit = initialInUnit * 2;
      jQuery.style(elem, prop, initialInUnit + unit); // Make sure we update the tween properties later on

      valueParts = valueParts || [];
    }

    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0; // Apply relative offset (+=/-=) if specified

      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];

      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }

    return adjusted;
  }

  var defaultDisplayMap = {};

  function getDefaultDisplay(elem) {
    var temp,
        doc = elem.ownerDocument,
        nodeName = elem.nodeName,
        display = defaultDisplayMap[nodeName];

    if (display) {
      return display;
    }

    temp = doc.body.appendChild(doc.createElement(nodeName));
    display = jQuery.css(temp, "display");
    temp.parentNode.removeChild(temp);

    if (display === "none") {
      display = "block";
    }

    defaultDisplayMap[nodeName] = display;
    return display;
  }

  function showHide(elements, show) {
    var display,
        elem,
        values = [],
        index = 0,
        length = elements.length; // Determine new display value for elements that need to change

    for (; index < length; index++) {
      elem = elements[index];

      if (!elem.style) {
        continue;
      }

      display = elem.style.display;

      if (show) {
        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
        // check is required in this first loop unless we have a nonempty display value (either
        // inline or about-to-be-restored)
        if (display === "none") {
          values[index] = dataPriv.get(elem, "display") || null;

          if (!values[index]) {
            elem.style.display = "";
          }
        }

        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
          values[index] = getDefaultDisplay(elem);
        }
      } else {
        if (display !== "none") {
          values[index] = "none"; // Remember what we're overwriting

          dataPriv.set(elem, "display", display);
        }
      }
    } // Set the display of the elements in a second loop to avoid constant reflow


    for (index = 0; index < length; index++) {
      if (values[index] != null) {
        elements[index].style.display = values[index];
      }
    }

    return elements;
  }

  jQuery.fn.extend({
    show: function show() {
      return showHide(this, true);
    },
    hide: function hide() {
      return showHide(this);
    },
    toggle: function toggle(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }

      return this.each(function () {
        if (isHiddenWithinTree(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  var rcheckableType = /^(?:checkbox|radio)$/i;
  var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
  var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;

  (function () {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input"); // Support: Android 4.0 - 4.3 only
    // Check state lost if the name is set (#11217)
    // Support: Windows Web Apps (WWA)
    // `name` and `type` must use .setAttribute for WWA (#14901)

    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input); // Support: Android <=4.1 only
    // Older WebKit doesn't clone checked state correctly in fragments

    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked; // Support: IE <=11 only
    // Make sure textarea (and checkbox) defaultValue is properly cloned

    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue; // Support: IE <=9 only
    // IE <=9 replaces <option> tags with their contents when inserted outside of
    // the select element.

    div.innerHTML = "<option></option>";
    support.option = !!div.lastChild;
  })(); // We have to close these tags to support XHTML (#13200)


  var wrapMap = {
    // XHTML parsers do not magically insert elements in the
    // same way that tag soup parsers do. So we cannot shorten
    // this by omitting <tbody> or other required elements.
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td; // Support: IE <=9 only

  if (!support.option) {
    wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
  }

  function getAll(context, tag) {
    // Support: IE <=9 - 11 only
    // Use typeof to avoid zero-argument method invocation on host objects (#15151)
    var ret;

    if (typeof context.getElementsByTagName !== "undefined") {
      ret = context.getElementsByTagName(tag || "*");
    } else if (typeof context.querySelectorAll !== "undefined") {
      ret = context.querySelectorAll(tag || "*");
    } else {
      ret = [];
    }

    if (tag === undefined || tag && nodeName(context, tag)) {
      return jQuery.merge([context], ret);
    }

    return ret;
  } // Mark scripts as having already been evaluated


  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;

    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }

  var rhtml = /<|&#?\w+;/;

  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        attached,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;

    for (; i < l; i++) {
      elem = elems[i];

      if (elem || elem === 0) {
        // Add nodes directly
        if (toType(elem) === "object") {
          // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem); // Convert non-html into a text node
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem)); // Convert html into DOM nodes
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div")); // Deserialize a standard representation

          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2]; // Descend through wrappers to the right content

          j = wrap[0];

          while (j--) {
            tmp = tmp.lastChild;
          } // Support: Android <=4.0 only, PhantomJS 1 only
          // push.apply(_, arraylike) throws on ancient WebKit


          jQuery.merge(nodes, tmp.childNodes); // Remember the top-level container

          tmp = fragment.firstChild; // Ensure the created nodes are orphaned (#12392)

          tmp.textContent = "";
        }
      }
    } // Remove wrapper from fragment


    fragment.textContent = "";
    i = 0;

    while (elem = nodes[i++]) {
      // Skip elements already in the context collection (trac-4087)
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }

        continue;
      }

      attached = isAttached(elem); // Append to fragment

      tmp = getAll(fragment.appendChild(elem), "script"); // Preserve script evaluation history

      if (attached) {
        setGlobalEval(tmp);
      } // Capture executables


      if (scripts) {
        j = 0;

        while (elem = tmp[j++]) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }

    return fragment;
  }

  var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

  function returnTrue() {
    return true;
  }

  function returnFalse() {
    return false;
  } // Support: IE <=9 - 11+
  // focus() and blur() are asynchronous, except when they are no-op.
  // So expect focus to be synchronous when the element is already active,
  // and blur to be synchronous when the element is not already active.
  // (focus and blur are always synchronous in other supported browsers,
  // this just defines when we can count on it).


  function expectSync(elem, type) {
    return elem === safeActiveElement() === (type === "focus");
  } // Support: IE <=9 only
  // Accessing document.activeElement can throw unexpectedly
  // https://bugs.jquery.com/ticket/13393


  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }

  function _on(elem, types, selector, data, fn, one) {
    var origFn, type; // Types can be a map of types/handlers

    if (_typeof(types) === "object") {
      // ( types-Object, selector, data )
      if (typeof selector !== "string") {
        // ( types-Object, data )
        data = data || selector;
        selector = undefined;
      }

      for (type in types) {
        _on(elem, type, selector, data, types[type], one);
      }

      return elem;
    }

    if (data == null && fn == null) {
      // ( types, fn )
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        // ( types, selector, fn )
        fn = data;
        data = undefined;
      } else {
        // ( types, data, fn )
        fn = data;
        data = selector;
        selector = undefined;
      }
    }

    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }

    if (one === 1) {
      origFn = fn;

      fn = function fn(event) {
        // Can use an empty set, since event contains the info
        jQuery().off(event);
        return origFn.apply(this, arguments);
      }; // Use same guid so caller can remove using origFn


      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }

    return elem.each(function () {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  /*
   * Helper functions for managing events -- not part of the public interface.
   * Props to Dean Edwards' addEvent library for many of the ideas.
   */


  jQuery.event = {
    global: {},
    add: function add(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem); // Only attach events to objects that accept data

      if (!acceptData(elem)) {
        return;
      } // Caller can pass in an object of custom data in lieu of the handler


      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      } // Ensure that invalid selectors throw exceptions at attach time
      // Evaluate against documentElement in case elem is a non-element node (e.g., document)


      if (selector) {
        jQuery.find.matchesSelector(documentElement, selector);
      } // Make sure that the handler has a unique ID, used to find/remove it later


      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      } // Init the element's event structure and main handler, if this is the first


      if (!(events = elemData.events)) {
        events = elemData.events = Object.create(null);
      }

      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      } // Handle multiple events separated by a space


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // There *must* be a type, no attaching namespace-only handlers

        if (!type) {
          continue;
        } // If event changes its type, use the special event handlers for the changed type


        special = jQuery.event.special[type] || {}; // If selector defined, determine special event api type, otherwise given type

        type = (selector ? special.delegateType : special.bindType) || type; // Update special based on newly reset type

        special = jQuery.event.special[type] || {}; // handleObj is passed to all event handlers

        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn); // Init the event handler queue if we're the first

        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0; // Only use addEventListener if the special events handler returns false

          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }

        if (special.add) {
          special.add.call(elem, handleObj);

          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        } // Add to the element's handler list, delegates in front


        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        } // Keep track of which events have ever been used, for event optimization


        jQuery.event.global[type] = true;
      }
    },
    // Detach an event or set of events from an element
    remove: function remove(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

      if (!elemData || !(events = elemData.events)) {
        return;
      } // Once for each type.namespace in types; type may be omitted


      types = (types || "").match(rnothtmlwhite) || [""];
      t = types.length;

      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort(); // Unbind all events (on this namespace, if provided) for the element

        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }

          continue;
        }

        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"); // Remove matching events

        origCount = j = handlers.length;

        while (j--) {
          handleObj = handlers[j];

          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);

            if (handleObj.selector) {
              handlers.delegateCount--;
            }

            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        } // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)


        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }

          delete events[type];
        }
      } // Remove data and the expando if it's no longer used


      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function dispatch(nativeEvent) {
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue,
          args = new Array(arguments.length),
          // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix(nativeEvent),
          handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
          special = jQuery.event.special[event.type] || {}; // Use the fix-ed jQuery.Event rather than the (read-only) native event

      args[0] = event;

      for (i = 1; i < arguments.length; i++) {
        args[i] = arguments[i];
      }

      event.delegateTarget = this; // Call the preDispatch hook for the mapped type, and let it bail if desired

      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      } // Determine handlers


      handlerQueue = jQuery.event.handlers.call(this, event, handlers); // Run delegates first; they may want to stop propagation beneath us

      i = 0;

      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;

        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          // If the event is namespaced, then each handler is only invoked if it is
          // specially universal or its namespaces are a superset of the event's.
          if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      } // Call the postDispatch hook for the mapped type


      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }

      return event.result;
    },
    handlers: function handlers(event, _handlers) {
      var i,
          handleObj,
          sel,
          matchedHandlers,
          matchedSelectors,
          handlerQueue = [],
          delegateCount = _handlers.delegateCount,
          cur = event.target; // Find delegate handlers

      if (delegateCount && // Support: IE <=9
      // Black-hole SVG <use> instance trees (trac-13180)
      cur.nodeType && // Support: Firefox <=42
      // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
      // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
      // Support: IE 11 only
      // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
      !(event.type === "click" && event.button >= 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          // Don't check non-elements (#13208)
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
            matchedHandlers = [];
            matchedSelectors = {};

            for (i = 0; i < delegateCount; i++) {
              handleObj = _handlers[i]; // Don't conflict with Object.prototype properties (#13203)

              sel = handleObj.selector + " ";

              if (matchedSelectors[sel] === undefined) {
                matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }

              if (matchedSelectors[sel]) {
                matchedHandlers.push(handleObj);
              }
            }

            if (matchedHandlers.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matchedHandlers
              });
            }
          }
        }
      } // Add the remaining (directly-bound) handlers


      cur = this;

      if (delegateCount < _handlers.length) {
        handlerQueue.push({
          elem: cur,
          handlers: _handlers.slice(delegateCount)
        });
      }

      return handlerQueue;
    },
    addProp: function addProp(name, hook) {
      Object.defineProperty(jQuery.Event.prototype, name, {
        enumerable: true,
        configurable: true,
        get: isFunction(hook) ? function () {
          if (this.originalEvent) {
            return hook(this.originalEvent);
          }
        } : function () {
          if (this.originalEvent) {
            return this.originalEvent[name];
          }
        },
        set: function set(value) {
          Object.defineProperty(this, name, {
            enumerable: true,
            configurable: true,
            writable: true,
            value: value
          });
        }
      });
    },
    fix: function fix(originalEvent) {
      return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
    },
    special: {
      load: {
        // Prevent triggered image.load events from bubbling to window.load
        noBubble: true
      },
      click: {
        // Utilize native event to ensure correct state for checkable inputs
        setup: function setup(data) {
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data; // Claim the first handler

          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
            // dataPriv.set( el, "click", ... )
            leverageNative(el, "click", returnTrue);
          } // Return false to allow normal processing in the caller


          return false;
        },
        trigger: function trigger(data) {
          // For mutual compressibility with _default, replace `this` access with a local var.
          // `|| data` is dead code meant only to preserve the variable through minification.
          var el = this || data; // Force setup before triggering a click

          if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
            leverageNative(el, "click");
          } // Return non-false to allow normal event-path propagation


          return true;
        },
        // For cross-browser consistency, suppress native .click() on links
        // Also prevent it if we're currently inside a leveraged native-event stack
        _default: function _default(event) {
          var target = event.target;
          return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
        }
      },
      beforeunload: {
        postDispatch: function postDispatch(event) {
          // Support: Firefox 20+
          // Firefox doesn't alert if the returnValue field is not set.
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    }
  }; // Ensure the presence of an event listener that handles manually-triggered
  // synthetic events by interrupting progress until reinvoked in response to
  // *native* events that it fires directly, ensuring that state changes have
  // already occurred before other listeners are invoked.

  function leverageNative(el, type, expectSync) {
    // Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
    if (!expectSync) {
      if (dataPriv.get(el, type) === undefined) {
        jQuery.event.add(el, type, returnTrue);
      }

      return;
    } // Register the controller as a special universal handler for all event namespaces


    dataPriv.set(el, type, false);
    jQuery.event.add(el, type, {
      namespace: false,
      handler: function handler(event) {
        var notAsync,
            result,
            saved = dataPriv.get(this, type);

        if (event.isTrigger & 1 && this[type]) {
          // Interrupt processing of the outer synthetic .trigger()ed event
          // Saved data should be false in such cases, but might be a leftover capture object
          // from an async native handler (gh-4350)
          if (!saved.length) {
            // Store arguments for use when handling the inner native event
            // There will always be at least one argument (an event object), so this array
            // will not be confused with a leftover capture object.
            saved = _slice.call(arguments);
            dataPriv.set(this, type, saved); // Trigger the native event and capture its result
            // Support: IE <=9 - 11+
            // focus() and blur() are asynchronous

            notAsync = expectSync(this, type);
            this[type]();
            result = dataPriv.get(this, type);

            if (saved !== result || notAsync) {
              dataPriv.set(this, type, false);
            } else {
              result = {};
            }

            if (saved !== result) {
              // Cancel the outer synthetic event
              event.stopImmediatePropagation();
              event.preventDefault(); // Support: Chrome 86+
              // In Chrome, if an element having a focusout handler is blurred by
              // clicking outside of it, it invokes the handler synchronously. If
              // that handler calls `.remove()` on the element, the data is cleared,
              // leaving `result` undefined. We need to guard against this.

              return result && result.value;
            } // If this is an inner synthetic event for an event with a bubbling surrogate
            // (focus or blur), assume that the surrogate already propagated from triggering the
            // native event and prevent that from happening again here.
            // This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
            // bubbling surrogate propagates *after* the non-bubbling base), but that seems
            // less bad than duplication.

          } else if ((jQuery.event.special[type] || {}).delegateType) {
            event.stopPropagation();
          } // If this is a native event triggered above, everything is now in order
          // Fire an inner synthetic event with the original arguments

        } else if (saved.length) {
          // ...and capture the result
          dataPriv.set(this, type, {
            value: jQuery.event.trigger( // Support: IE <=9 - 11+
            // Extend with the prototype to reset the above stopImmediatePropagation()
            jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
          }); // Abort handling of the native event

          event.stopImmediatePropagation();
        }
      }
    });
  }

  jQuery.removeEvent = function (elem, type, handle) {
    // This "if" is needed for plain objects
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };

  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    } // Event object


    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type; // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.

      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && // Support: Android <=2.3 only
      src.returnValue === false ? returnTrue : returnFalse; // Create target properties
      // Support: Safari <=6 - 7 only
      // Target should not be a text node (#504, #13143)

      this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
      this.currentTarget = src.currentTarget;
      this.relatedTarget = src.relatedTarget; // Event type
    } else {
      this.type = src;
    } // Put explicitly provided properties onto the event object


    if (props) {
      jQuery.extend(this, props);
    } // Create a timestamp if incoming event doesn't have one


    this.timeStamp = src && src.timeStamp || Date.now(); // Mark it as fixed

    this[jQuery.expando] = true;
  }; // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html


  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    isSimulated: false,
    preventDefault: function preventDefault() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;

      if (e && !this.isSimulated) {
        e.preventDefault();
      }
    },
    stopPropagation: function stopPropagation() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function stopImmediatePropagation() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;

      if (e && !this.isSimulated) {
        e.stopImmediatePropagation();
      }

      this.stopPropagation();
    }
  }; // Includes all common event props including KeyEvent and MouseEvent specific props

  jQuery.each({
    altKey: true,
    bubbles: true,
    cancelable: true,
    changedTouches: true,
    ctrlKey: true,
    detail: true,
    eventPhase: true,
    metaKey: true,
    pageX: true,
    pageY: true,
    shiftKey: true,
    view: true,
    "char": true,
    code: true,
    charCode: true,
    key: true,
    keyCode: true,
    button: true,
    buttons: true,
    clientX: true,
    clientY: true,
    offsetX: true,
    offsetY: true,
    pointerId: true,
    pointerType: true,
    screenX: true,
    screenY: true,
    targetTouches: true,
    toElement: true,
    touches: true,
    which: true
  }, jQuery.event.addProp);
  jQuery.each({
    focus: "focusin",
    blur: "focusout"
  }, function (type, delegateType) {
    jQuery.event.special[type] = {
      // Utilize native event if possible so blur/focus sequence is correct
      setup: function setup() {
        // Claim the first handler
        // dataPriv.set( this, "focus", ... )
        // dataPriv.set( this, "blur", ... )
        leverageNative(this, type, expectSync); // Return false to allow normal processing in the caller

        return false;
      },
      trigger: function trigger() {
        // Force setup before trigger
        leverageNative(this, type); // Return non-false to allow normal event-path propagation

        return true;
      },
      // Suppress native focus or blur as it's already being fired
      // in leverageNative.
      _default: function _default() {
        return true;
      },
      delegateType: delegateType
    };
  }); // Create mouseenter/leave events using mouseover/out and event-time checks
  // so that event delegation works in jQuery.
  // Do the same for pointerenter/pointerleave and pointerover/pointerout
  //
  // Support: Safari 7 only
  // Safari sends mouseenter too often; see:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
  // for the description of the bug (it existed in older Chrome versions as well).

  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function handle(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj; // For mouseenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window

        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }

        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function on(types, selector, data, fn) {
      return _on(this, types, selector, data, fn);
    },
    one: function one(types, selector, data, fn) {
      return _on(this, types, selector, data, fn, 1);
    },
    off: function off(types, selector, fn) {
      var handleObj, type;

      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }

      if (_typeof(types) === "object") {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }

        return this;
      }

      if (selector === false || typeof selector === "function") {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }

      if (fn === false) {
        fn = returnFalse;
      }

      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var // Support: IE <=10 - 11, Edge 12 - 13 only
  // In IE/Edge using regex groups here causes severe slowdowns.
  // See https://connect.microsoft.com/IE/feedback/details/1736512/
  rnoInnerhtml = /<script|<style|<link/i,
      // checked="checked" or checked
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g; // Prefer a tbody over its parent table for containing new rows

  function manipulationTarget(elem, content) {
    if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
      return jQuery(elem).children("tbody")[0] || elem;
    }

    return elem;
  } // Replace/restore the type attribute of script elements for safe DOM manipulation


  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }

  function restoreScript(elem) {
    if ((elem.type || "").slice(0, 5) === "true/") {
      elem.type = elem.type.slice(5);
    } else {
      elem.removeAttribute("type");
    }

    return elem;
  }

  function cloneCopyEvent(src, dest) {
    var i, l, type, pdataOld, udataOld, udataCur, events;

    if (dest.nodeType !== 1) {
      return;
    } // 1. Copy private data: events, handlers, etc.


    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.get(src);
      events = pdataOld.events;

      if (events) {
        dataPriv.remove(dest, "handle events");

        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    } // 2. Copy user data


    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  } // Fix IE bugs, see support tests


  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase(); // Fails to persist the checked state of a cloned checkbox or radio button.

    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked; // Fails to return the selected option to the default selected state when cloning options
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }

  function domManip(collection, args, callback, ignored) {
    // Flatten any nested arrays
    args = flat(args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        valueIsFunction = isFunction(value); // We can't cloneNode fragments that contain checked, in WebKit

    if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
      return collection.each(function (index) {
        var self = collection.eq(index);

        if (valueIsFunction) {
          args[0] = value.call(this, index, self.html());
        }

        domManip(self, args, callback, ignored);
      });
    }

    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;

      if (fragment.childNodes.length === 1) {
        fragment = first;
      } // Require either new content or an interest in ignored elements to invoke the callback


      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length; // Use the original fragment for the last item
        // instead of the first because it can end up
        // being emptied incorrectly in certain situations (#8070).

        for (; i < l; i++) {
          node = fragment;

          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true); // Keep references to cloned scripts for later restoration

            if (hasScripts) {
              // Support: Android <=4.0 only, PhantomJS 1 only
              // push.apply(_, arraylike) throws on ancient WebKit
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }

          callback.call(collection[i], node, i);
        }

        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument; // Reenable scripts

          jQuery.map(scripts, restoreScript); // Evaluate executable scripts on first document insertion

          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];

            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src && (node.type || "").toLowerCase() !== "module") {
                // Optional AJAX dependency, but won't run scripts if not present
                if (jQuery._evalUrl && !node.noModule) {
                  jQuery._evalUrl(node.src, {
                    nonce: node.nonce || node.getAttribute("nonce")
                  }, doc);
                }
              } else {
                DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
              }
            }
          }
        }
      }
    }

    return collection;
  }

  function _remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;

    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }

      if (node.parentNode) {
        if (keepData && isAttached(node)) {
          setGlobalEval(getAll(node, "script"));
        }

        node.parentNode.removeChild(node);
      }
    }

    return elem;
  }

  jQuery.extend({
    htmlPrefilter: function htmlPrefilter(html) {
      return html;
    },
    clone: function clone(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = isAttached(elem); // Fix IE cloning issues

      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);

        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      } // Copy the events from the original to the clone


      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);

          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      } // Preserve script evaluation history


      destElements = getAll(clone, "script");

      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      } // Return the cloned set


      return clone;
    },
    cleanData: function cleanData(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;

      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if (data = elem[dataPriv.expando]) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type); // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            } // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove


            elem[dataPriv.expando] = undefined;
          }

          if (elem[dataUser.expando]) {
            // Support: Chrome <=35 - 45+
            // Assign undefined instead of using delete, see Data#remove
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    detach: function detach(selector) {
      return _remove(this, selector, true);
    },
    remove: function remove(selector) {
      return _remove(this, selector);
    },
    text: function text(value) {
      return access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function () {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function append() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function prepend() {
      return domManip(this, arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function before() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function after() {
      return domManip(this, arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function empty() {
      var elem,
          i = 0;

      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          // Prevent memory leaks
          jQuery.cleanData(getAll(elem, false)); // Remove any remaining nodes

          elem.textContent = "";
        }
      }

      return this;
    },
    clone: function clone(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function html(value) {
      return access(this, function (value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;

        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        } // See if we can take a shortcut and just use innerHTML


        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);

          try {
            for (; i < l; i++) {
              elem = this[i] || {}; // Remove element nodes and prevent memory leaks

              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }

            elem = 0; // If using innerHTML throws an exception, use the fallback method
          } catch (e) {}
        }

        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function replaceWith() {
      var ignored = []; // Make the changes, replacing each non-ignored context element with the new content

      return domManip(this, arguments, function (elem) {
        var parent = this.parentNode;

        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));

          if (parent) {
            parent.replaceChild(elem, this);
          }
        } // Force callback invocation

      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;

      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems); // Support: Android <=4.0 only, PhantomJS 1 only
        // .get() because push.apply(_, arraylike) throws on ancient WebKit

        push.apply(ret, elems.get());
      }

      return this.pushStack(ret);
    };
  });
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

  var getStyles = function getStyles(elem) {
    // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
    // IE throws on elements created in popups
    // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
    var view = elem.ownerDocument.defaultView;

    if (!view || !view.opener) {
      view = window;
    }

    return view.getComputedStyle(elem);
  };

  var swap = function swap(elem, options, callback) {
    var ret,
        name,
        old = {}; // Remember the old values, and insert the new ones

    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }

    ret = callback.call(elem); // Revert the old values

    for (name in options) {
      elem.style[name] = old[name];
    }

    return ret;
  };

  var rboxStyle = new RegExp(cssExpand.join("|"), "i");

  (function () {
    // Executing both pixelPosition & boxSizingReliable tests require only one layout
    // so they're executed at the same time to save the second computation.
    function computeStyleTests() {
      // This is a singleton, we need to execute it only once
      if (!div) {
        return;
      }

      container.style.cssText = "position:absolute;left:-11111px;width:60px;" + "margin-top:1px;padding:0;border:0";
      div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;" + "margin:auto;border:1px;padding:1px;" + "width:60%;top:1%";
      documentElement.appendChild(container).appendChild(div);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%"; // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44

      reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12; // Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
      // Some styles come back with percentage values, even though they shouldn't

      div.style.right = "60%";
      pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36; // Support: IE 9 - 11 only
      // Detect misreporting of content dimensions for box-sizing:border-box elements

      boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36; // Support: IE 9 only
      // Detect overflow:scroll screwiness (gh-3699)
      // Support: Chrome <=64
      // Don't get tricked when zoom affects offsetWidth (gh-4029)

      div.style.position = "absolute";
      scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
      documentElement.removeChild(container); // Nullify the div so it wouldn't be stored in the memory and
      // it will also be a sign that checks already performed

      div = null;
    }

    function roundPixelMeasures(measure) {
      return Math.round(parseFloat(measure));
    }

    var pixelPositionVal,
        boxSizingReliableVal,
        scrollboxSizeVal,
        pixelBoxStylesVal,
        reliableTrDimensionsVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div"); // Finish early in limited (non-browser) environments

    if (!div.style) {
      return;
    } // Support: IE <=9 - 11 only
    // Style of cloned element affects source element cloned (#8908)


    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    jQuery.extend(support, {
      boxSizingReliable: function boxSizingReliable() {
        computeStyleTests();
        return boxSizingReliableVal;
      },
      pixelBoxStyles: function pixelBoxStyles() {
        computeStyleTests();
        return pixelBoxStylesVal;
      },
      pixelPosition: function pixelPosition() {
        computeStyleTests();
        return pixelPositionVal;
      },
      reliableMarginLeft: function reliableMarginLeft() {
        computeStyleTests();
        return reliableMarginLeftVal;
      },
      scrollboxSize: function scrollboxSize() {
        computeStyleTests();
        return scrollboxSizeVal;
      },
      // Support: IE 9 - 11+, Edge 15 - 18+
      // IE/Edge misreport `getComputedStyle` of table rows with width/height
      // set in CSS while `offset*` properties report correct values.
      // Behavior in IE 9 is more subtle than in newer versions & it passes
      // some versions of this test; make sure not to make it pass there!
      //
      // Support: Firefox 70+
      // Only Firefox includes border widths
      // in computed dimensions. (gh-4529)
      reliableTrDimensions: function reliableTrDimensions() {
        var table, tr, trChild, trStyle;

        if (reliableTrDimensionsVal == null) {
          table = document.createElement("table");
          tr = document.createElement("tr");
          trChild = document.createElement("div");
          table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
          tr.style.cssText = "border:1px solid"; // Support: Chrome 86+
          // Height set through cssText does not get applied.
          // Computed height then comes back as 0.

          tr.style.height = "1px";
          trChild.style.height = "9px"; // Support: Android 8 Chrome 86+
          // In our bodyBackground.html iframe,
          // display for all div elements is set to "inline",
          // which causes a problem only in Android 8 Chrome 86.
          // Ensuring the div is display: block
          // gets around this issue.

          trChild.style.display = "block";
          documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
          trStyle = window.getComputedStyle(tr);
          reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
          documentElement.removeChild(table);
        }

        return reliableTrDimensionsVal;
      }
    });
  })();

  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        // Support: Firefox 51+
    // Retrieving style before computed somehow
    // fixes an issue with getting wrong values
    // on detached elements
    style = elem.style;
    computed = computed || getStyles(elem); // getPropertyValue is needed for:
    //   .css('filter') (IE 9 only, #12537)
    //   .css('--customProperty) (#3144)

    if (computed) {
      ret = computed.getPropertyValue(name) || computed[name];

      if (ret === "" && !isAttached(elem)) {
        ret = jQuery.style(elem, name);
      } // A tribute to the "awesome hack by Dean Edwards"
      // Android Browser returns percentage for some values,
      // but width seems to be reliably pixels.
      // This is against the CSSOM draft spec:
      // https://drafts.csswg.org/cssom/#resolved-values


      if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
        // Remember the original values
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth; // Put in the new values to get a computed value out

        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width; // Revert the changed values

        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }

    return ret !== undefined ? // Support: IE <=9 - 11 only
    // IE returns zIndex value as an integer.
    ret + "" : ret;
  }

  function addGetHookIf(conditionFn, hookFn) {
    // Define the hook, we'll check on the first run if it's really needed.
    return {
      get: function get() {
        if (conditionFn()) {
          // Hook not needed (or it's not possible to use it due
          // to missing dependency), remove it.
          delete this.get;
          return;
        } // Hook needed; redefine it so that the support test is not executed again.


        return (this.get = hookFn).apply(this, arguments);
      }
    };
  }

  var cssPrefixes = ["Webkit", "Moz", "ms"],
      emptyStyle = document.createElement("div").style,
      vendorProps = {}; // Return a vendor-prefixed property or undefined

  function vendorPropName(name) {
    // Check for vendor prefixed names
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;

    while (i--) {
      name = cssPrefixes[i] + capName;

      if (name in emptyStyle) {
        return name;
      }
    }
  } // Return a potentially-mapped jQuery.cssProps or vendor prefixed property


  function finalPropName(name) {
    var final = jQuery.cssProps[name] || vendorProps[name];

    if (final) {
      return final;
    }

    if (name in emptyStyle) {
      return name;
    }

    return vendorProps[name] = vendorPropName(name) || name;
  }

  var // Swappable if display is none or starts with table
  // except "table", "table-cell", or "table-caption"
  // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
  rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      rcustomProp = /^--/,
      cssShow = {
    position: "absolute",
    visibility: "hidden",
    display: "block"
  },
      cssNormalTransform = {
    letterSpacing: "0",
    fontWeight: "400"
  };

  function setPositiveNumber(_elem, value, subtract) {
    // Any relative (+/-) values have already been
    // normalized at this point
    var matches = rcssNum.exec(value);
    return matches ? // Guard against undefined "subtract", e.g., when used as in cssHooks
    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }

  function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
    var i = dimension === "width" ? 1 : 0,
        extra = 0,
        delta = 0; // Adjustment may not be necessary

    if (box === (isBorderBox ? "border" : "content")) {
      return 0;
    }

    for (; i < 4; i += 2) {
      // Both box models exclude margin
      if (box === "margin") {
        delta += jQuery.css(elem, box + cssExpand[i], true, styles);
      } // If we get here with a content-box, we're seeking "padding" or "border" or "margin"


      if (!isBorderBox) {
        // Add padding
        delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles); // For "border" or "margin", add border

        if (box !== "padding") {
          delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles); // But still keep track of it otherwise
        } else {
          extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        } // If we get here with a border-box (content + padding + border), we're seeking "content" or
        // "padding" or "margin"

      } else {
        // For "content", subtract padding
        if (box === "content") {
          delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        } // For "content" or "padding", subtract border


        if (box !== "margin") {
          delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    } // Account for positive content-box scroll gutter when requested by providing computedVal


    if (!isBorderBox && computedVal >= 0) {
      // offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
      // Assuming integer scroll gutter, subtract the rest and round down
      delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5 // If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
      // Use an explicit zero to avoid NaN (gh-3964)
      )) || 0;
    }

    return delta;
  }

  function getWidthOrHeight(elem, dimension, extra) {
    // Start with computed style
    var styles = getStyles(elem),
        // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
    // Fake content-box until we know it's needed to know the true value.
    boxSizingNeeded = !support.boxSizingReliable() || extra,
        isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
        valueIsBorderBox = isBorderBox,
        val = curCSS(elem, dimension, styles),
        offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1); // Support: Firefox <=54
    // Return a confounding non-pixel value or feign ignorance, as appropriate.

    if (rnumnonpx.test(val)) {
      if (!extra) {
        return val;
      }

      val = "auto";
    } // Support: IE 9 - 11 only
    // Use offsetWidth/offsetHeight for when box sizing is unreliable.
    // In those cases, the computed value can be trusted to be border-box.


    if ((!support.boxSizingReliable() && isBorderBox || // Support: IE 10 - 11+, Edge 15 - 18+
    // IE/Edge misreport `getComputedStyle` of table rows with width/height
    // set in CSS while `offset*` properties report correct values.
    // Interestingly, in some cases IE 9 doesn't suffer from this issue.
    !support.reliableTrDimensions() && nodeName(elem, "tr") || // Fall back to offsetWidth/offsetHeight when value is "auto"
    // This happens for inline elements with no explicit setting (gh-3571)
    val === "auto" || // Support: Android <=4.1 - 4.3 only
    // Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
    !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && // Make sure the element is visible & connected
    elem.getClientRects().length) {
      isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box"; // Where available, offsetWidth/offsetHeight approximate border box dimensions.
      // Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
      // retrieved value as a content box dimension.

      valueIsBorderBox = offsetProp in elem;

      if (valueIsBorderBox) {
        val = elem[offsetProp];
      }
    } // Normalize "" and auto


    val = parseFloat(val) || 0; // Adjust for the element's box model

    return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, // Provide the current computed size to request scroll gutter calculation (gh-3589)
    val) + "px";
  }

  jQuery.extend({
    // Add in style property hooks for overriding the default
    // behavior of getting and setting a style property
    cssHooks: {
      opacity: {
        get: function get(elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }
      }
    },
    // Don't automatically add "px" to these possibly-unitless properties
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "gridArea": true,
      "gridColumn": true,
      "gridColumnEnd": true,
      "gridColumnStart": true,
      "gridRow": true,
      "gridRowEnd": true,
      "gridRowStart": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    // Add in properties whose names you wish to fix before
    // setting or getting the value
    cssProps: {},
    // Get and set the style property on a DOM Node
    style: function style(elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      } // Make sure that we're working with the right name


      var ret,
          type,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name),
          style = elem.style; // Make sure that we're working with the right name. We don't
      // want to query the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Gets hook for the prefixed version, then unprefixed version


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // Check if we're setting a value

      if (value !== undefined) {
        type = _typeof(value); // Convert "+=" or "-=" to relative numbers (#7345)

        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret); // Fixes bug #9237

          type = "number";
        } // Make sure that null and NaN values aren't set (#7116)


        if (value == null || value !== value) {
          return;
        } // If a number was passed in, add the unit (except for certain CSS properties)
        // The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
        // "px" to a few hardcoded values.


        if (type === "number" && !isCustomProp) {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        } // background-* props affect original clone's values


        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        } // If a hook was provided, use that value, otherwise just set the specified value


        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          if (isCustomProp) {
            style.setProperty(name, value);
          } else {
            style[name] = value;
          }
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        } // Otherwise just get the value from the style object


        return style[name];
      }
    },
    css: function css(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = camelCase(name),
          isCustomProp = rcustomProp.test(name); // Make sure that we're working with the right name. We don't
      // want to modify the value if it is a CSS custom property
      // since they are user-defined.

      if (!isCustomProp) {
        name = finalPropName(origName);
      } // Try prefixed name followed by the unprefixed name


      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]; // If a hook was provided get the computed value from there

      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      } // Otherwise, if a way to get the computed value exists, use that


      if (val === undefined) {
        val = curCSS(elem, name, styles);
      } // Convert "normal" to computed value


      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      } // Make numeric if forced or a qualifier was provided and val looks numeric


      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }

      return val;
    }
  });
  jQuery.each(["height", "width"], function (_i, dimension) {
    jQuery.cssHooks[dimension] = {
      get: function get(elem, computed, extra) {
        if (computed) {
          // Certain elements can have dimension info if we invisibly show them
          // but it must have a current display style that would benefit
          return rdisplayswap.test(jQuery.css(elem, "display")) && ( // Support: Safari 8+
          // Table columns in Safari have non-zero offsetWidth & zero
          // getBoundingClientRect().width unless display is changed.
          // Support: IE <=11 only
          // Running getBoundingClientRect on a disconnected node
          // in IE throws an error.
          !elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, dimension, extra);
          }) : getWidthOrHeight(elem, dimension, extra);
        }
      },
      set: function set(elem, value, extra) {
        var matches,
            styles = getStyles(elem),
            // Only read styles.position if the test has a chance to fail
        // to avoid forcing a reflow.
        scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute",
            // To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
        boxSizingNeeded = scrollboxSizeBuggy || extra,
            isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box",
            subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0; // Account for unreliable border-box dimensions by comparing offset* to computed and
        // faking a content-box to get border and padding (gh-3699)

        if (isBorderBox && scrollboxSizeBuggy) {
          subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
        } // Convert to pixels if value adjustment is needed


        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[dimension] = value;
          value = jQuery.css(elem, dimension);
        }

        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
        marginLeft: 0
      }, function () {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  }); // These hooks are used by animate to expand properties

  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function expand(value) {
        var i = 0,
            expanded = {},
            // Assumes a single number if not a string
        parts = typeof value === "string" ? value.split(" ") : [value];

        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }

        return expanded;
      }
    };

    if (prefix !== "margin") {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function css(name, value) {
      return access(this, function (elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;

        if (Array.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;

          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }

          return map;
        }

        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    }
  });

  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }

  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function init(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function cur() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function run(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];

      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }

      this.now = (this.end - this.start) * eased + this.start;

      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }

      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }

      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function get(tween) {
        var result; // Use a property on the element directly when it is not a DOM element,
        // or when there is no matching style property that exists.

        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        } // Passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails.
        // Simple values such as "10px" are parsed to Float;
        // complex values such as "rotate(1rad)" are returned as-is.


        result = jQuery.css(tween.elem, tween.prop, ""); // Empty strings, null, undefined and "auto" are converted to 0.

        return !result || result === "auto" ? 0 : result;
      },
      set: function set(tween) {
        // Use step hook for back compat.
        // Use cssHook if its there.
        // Use .style if available and use plain properties where available.
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  }; // Support: IE <=9 only
  // Panic based approach to setting things on disconnected nodes

  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function set(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.easing = {
    linear: function linear(p) {
      return p;
    },
    swing: function swing(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init; // Back compat <1.8 extension point

  jQuery.fx.step = {};
  var fxNow,
      inProgress,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;

  function schedule() {
    if (inProgress) {
      if (document.hidden === false && window.requestAnimationFrame) {
        window.requestAnimationFrame(schedule);
      } else {
        window.setTimeout(schedule, jQuery.fx.interval);
      }

      jQuery.fx.tick();
    }
  } // Animations created synchronously will run synchronously


  function createFxNow() {
    window.setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = Date.now();
  } // Generate parameters to create a standard animation


  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {
      height: type
    }; // If we include width, step value is 1 to do all cssExpand values,
    // otherwise step value is 2 to skip over Left and Right

    includeWidth = includeWidth ? 1 : 0;

    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }

    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }

    return attrs;
  }

  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;

    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        // We're done with this property
        return tween;
      }
    }
  }

  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        hooks,
        oldfire,
        propTween,
        restoreDisplay,
        display,
        isBox = "width" in props || "height" in props,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHiddenWithinTree(elem),
        dataShow = dataPriv.get(elem, "fxshow"); // Queue-skipping animations hijack the fx hooks

    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");

      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;

        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }

      hooks.unqueued++;
      anim.always(function () {
        // Ensure the complete handler is called before this completes
        anim.always(function () {
          hooks.unqueued--;

          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    } // Detect show/hide animations


    for (prop in props) {
      value = props[prop];

      if (rfxtypes.test(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";

        if (value === (hidden ? "hide" : "show")) {
          // Pretend to be hidden if this is a "show" and
          // there is still data from a stopped show/hide
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true; // Ignore all other no-op show/hide data
          } else {
            continue;
          }
        }

        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    } // Bail out if this is a no-op like .hide().hide()


    propTween = !jQuery.isEmptyObject(props);

    if (!propTween && jQuery.isEmptyObject(orig)) {
      return;
    } // Restrict "overflow" and "display" styles during box animations


    if (isBox && elem.nodeType === 1) {
      // Support: IE <=9 - 11, Edge 12 - 15
      // Record all 3 overflow attributes because IE does not infer the shorthand
      // from identically-valued overflowX and overflowY and Edge just mirrors
      // the overflowX value there.
      opts.overflow = [style.overflow, style.overflowX, style.overflowY]; // Identify a display type, preferring old show/hide data over the CSS cascade

      restoreDisplay = dataShow && dataShow.display;

      if (restoreDisplay == null) {
        restoreDisplay = dataPriv.get(elem, "display");
      }

      display = jQuery.css(elem, "display");

      if (display === "none") {
        if (restoreDisplay) {
          display = restoreDisplay;
        } else {
          // Get nonempty value(s) by temporarily forcing visibility
          showHide([elem], true);
          restoreDisplay = elem.style.display || restoreDisplay;
          display = jQuery.css(elem, "display");
          showHide([elem]);
        }
      } // Animate inline elements as inline-block


      if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
        if (jQuery.css(elem, "float") === "none") {
          // Restore the original display value at the end of pure show/hide animations
          if (!propTween) {
            anim.done(function () {
              style.display = restoreDisplay;
            });

            if (restoreDisplay == null) {
              display = style.display;
              restoreDisplay = display === "none" ? "" : display;
            }
          }

          style.display = "inline-block";
        }
      }
    }

    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function () {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    } // Implement show/hide animations


    propTween = false;

    for (prop in orig) {
      // General show/hide setup for this element animation
      if (!propTween) {
        if (dataShow) {
          if ("hidden" in dataShow) {
            hidden = dataShow.hidden;
          }
        } else {
          dataShow = dataPriv.access(elem, "fxshow", {
            display: restoreDisplay
          });
        } // Store hidden/visible for toggle so `.stop().toggle()` "reverses"


        if (toggle) {
          dataShow.hidden = !hidden;
        } // Show elements before animating them


        if (hidden) {
          showHide([elem], true);
        }
        /* eslint-disable no-loop-func */


        anim.done(function () {
          /* eslint-enable no-loop-func */
          // The final step of a "hide" animation is actually hiding the element
          if (!hidden) {
            showHide([elem]);
          }

          dataPriv.remove(elem, "fxshow");

          for (prop in orig) {
            jQuery.style(elem, prop, orig[prop]);
          }
        });
      } // Per-property setup


      propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

      if (!(prop in dataShow)) {
        dataShow[prop] = propTween.start;

        if (hidden) {
          propTween.end = propTween.start;
          propTween.start = 0;
        }
      }
    }
  }

  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks; // camelCase, specialEasing and expand cssHook pass

    for (index in props) {
      name = camelCase(index);
      easing = specialEasing[name];
      value = props[index];

      if (Array.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }

      if (index !== name) {
        props[name] = value;
        delete props[index];
      }

      hooks = jQuery.cssHooks[name];

      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name]; // Not quite $.extend, this won't overwrite existing keys.
        // Reusing 'index' because we have the correct "name"

        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }

  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function () {
      // Don't match elem in the :animated selector
      delete tick.elem;
    }),
        tick = function tick() {
      if (stopped) {
        return false;
      }

      var currentTime = fxNow || createFxNow(),
          remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // Support: Android 2.3 only
      // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
      temp = remaining / animation.duration || 0,
          percent = 1 - temp,
          index = 0,
          length = animation.tweens.length;

      for (; index < length; index++) {
        animation.tweens[index].run(percent);
      }

      deferred.notifyWith(elem, [animation, percent, remaining]); // If there's more to do, yield

      if (percent < 1 && length) {
        return remaining;
      } // If this was an empty animation, synthesize a final progress notification


      if (!length) {
        deferred.notifyWith(elem, [animation, 1, 0]);
      } // Resolve the animation and report its conclusion


      deferred.resolveWith(elem, [animation]);
      return false;
    },
        animation = deferred.promise({
      elem: elem,
      props: jQuery.extend({}, properties),
      opts: jQuery.extend(true, {
        specialEasing: {},
        easing: jQuery.easing._default
      }, options),
      originalProperties: properties,
      originalOptions: options,
      startTime: fxNow || createFxNow(),
      duration: options.duration,
      tweens: [],
      createTween: function createTween(prop, end) {
        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
        animation.tweens.push(tween);
        return tween;
      },
      stop: function stop(gotoEnd) {
        var index = 0,
            // If we are going to the end, we want to run all the tweens
        // otherwise we skip this part
        length = gotoEnd ? animation.tweens.length : 0;

        if (stopped) {
          return this;
        }

        stopped = true;

        for (; index < length; index++) {
          animation.tweens[index].run(1);
        } // Resolve when we played the last frame; otherwise, reject


        if (gotoEnd) {
          deferred.notifyWith(elem, [animation, 1, 0]);
          deferred.resolveWith(elem, [animation, gotoEnd]);
        } else {
          deferred.rejectWith(elem, [animation, gotoEnd]);
        }

        return this;
      }
    }),
        props = animation.props;

    propFilter(props, animation.opts.specialEasing);

    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);

      if (result) {
        if (isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
        }

        return result;
      }
    }

    jQuery.map(props, createTween, animation);

    if (isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    } // Attach callbacks from options


    animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation;
  }

  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {
      "*": [function (prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]
    },
    tweener: function tweener(props, callback) {
      if (isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnothtmlwhite);
      }

      var prop,
          index = 0,
          length = props.length;

      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function prefilter(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });

  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && _typeof(speed) === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !isFunction(easing) && easing
    }; // Go to the end state if fx are off

    if (jQuery.fx.off) {
      opt.duration = 0;
    } else {
      if (typeof opt.duration !== "number") {
        if (opt.duration in jQuery.fx.speeds) {
          opt.duration = jQuery.fx.speeds[opt.duration];
        } else {
          opt.duration = jQuery.fx.speeds._default;
        }
      }
    } // Normalize opt.queue - true/undefined/null -> "fx"


    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    } // Queueing


    opt.old = opt.complete;

    opt.complete = function () {
      if (isFunction(opt.old)) {
        opt.old.call(this);
      }

      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };

    return opt;
  };

  jQuery.fn.extend({
    fadeTo: function fadeTo(speed, to, easing, callback) {
      // Show any hidden elements after setting opacity to 0
      return this.filter(isHiddenWithinTree).css("opacity", 0).show() // Animate to the value specified
      .end().animate({
        opacity: to
      }, speed, easing, callback);
    },
    animate: function animate(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function doAnimation() {
        // Operate on a copy of prop so per-property easing won't be lost
        var anim = Animation(this, jQuery.extend({}, prop), optall); // Empty animations, or finishing resolves immediately

        if (empty || dataPriv.get(this, "finish")) {
          anim.stop(true);
        }
      };

      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function stop(type, clearQueue, gotoEnd) {
      var stopQueue = function stopQueue(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };

      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }

      if (clearQueue) {
        this.queue(type || "fx", []);
      }

      return this.each(function () {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);

        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }

        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        } // Start the next in the queue if the last step wasn't forced.
        // Timers currently will call their complete callbacks, which
        // will dequeue but only if they were gotoEnd.


        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function finish(type) {
      if (type !== false) {
        type = type || "fx";
      }

      return this.each(function () {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0; // Enable finishing flag on private data

        data.finish = true; // Empty the queue first

        jQuery.queue(this, type, []);

        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        } // Look for any active animations, and finish them


        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        } // Look for any animations in the old queue and finish them


        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        } // Turn off finishing flag


        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function (_i, name) {
    var cssFn = jQuery.fn[name];

    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  }); // Generate shortcuts for custom animations

  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {
      opacity: "show"
    },
    fadeOut: {
      opacity: "hide"
    },
    fadeToggle: {
      opacity: "toggle"
    }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];

  jQuery.fx.tick = function () {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = Date.now();

    for (; i < timers.length; i++) {
      timer = timers[i]; // Run the timer and safely remove it when done (allowing for external removal)

      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }

    if (!timers.length) {
      jQuery.fx.stop();
    }

    fxNow = undefined;
  };

  jQuery.fx.timer = function (timer) {
    jQuery.timers.push(timer);
    jQuery.fx.start();
  };

  jQuery.fx.interval = 13;

  jQuery.fx.start = function () {
    if (inProgress) {
      return;
    }

    inProgress = true;
    schedule();
  };

  jQuery.fx.stop = function () {
    inProgress = null;
  };

  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    // Default speed
    _default: 400
  }; // Based off of the plugin by Clint Helfers, with permission.
  // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/

  jQuery.fn.delay = function (time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function (next, hooks) {
      var timeout = window.setTimeout(next, time);

      hooks.stop = function () {
        window.clearTimeout(timeout);
      };
    });
  };

  (function () {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox"; // Support: Android <=4.3 only
    // Default value for a checkbox should be "on"

    support.checkOn = input.value !== ""; // Support: IE <=11 only
    // Must access selectedIndex to make default options select

    support.optSelected = opt.selected; // Support: IE <=11 only
    // An input loses its value after becoming a radio

    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();

  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function attr(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function removeAttr(name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function attr(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set attributes on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      } // Fallback to prop when attributes are not supported


      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      } // Attribute hooks are determined by the lowercase version
      // Grab necessary hook if one is defined


      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }

      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }

        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        elem.setAttribute(name, value + "");
        return value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      ret = jQuery.find.attr(elem, name); // Non-existent attributes return null, we normalize to undefined

      return ret == null ? undefined : ret;
    },
    attrHooks: {
      type: {
        set: function set(elem, value) {
          if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);

            if (val) {
              elem.value = val;
            }

            return value;
          }
        }
      }
    },
    removeAttr: function removeAttr(elem, value) {
      var name,
          i = 0,
          // Attribute names can contain non-HTML whitespace characters
      // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
      attrNames = value && value.match(rnothtmlwhite);

      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          elem.removeAttribute(name);
        }
      }
    }
  }); // Hooks for boolean attributes

  boolHook = {
    set: function set(elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }

      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (_i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;

    attrHandle[name] = function (elem, name, isXML) {
      var ret,
          handle,
          lowercaseName = name.toLowerCase();

      if (!isXML) {
        // Avoid an infinite loop by temporarily removing this function from the getter
        handle = attrHandle[lowercaseName];
        attrHandle[lowercaseName] = ret;
        ret = getter(elem, name, isXML) != null ? lowercaseName : null;
        attrHandle[lowercaseName] = handle;
      }

      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function prop(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function removeProp(name) {
      return this.each(function () {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function prop(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType; // Don't get/set properties on text, comment and attribute nodes

      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }

      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }

      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }

        return elem[name] = value;
      }

      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }

      return elem[name];
    },
    propHooks: {
      tabIndex: {
        get: function get(elem) {
          // Support: IE <=9 - 11 only
          // elem.tabIndex doesn't always return the
          // correct value when it hasn't been explicitly set
          // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          // Use proper attribute retrieval(#12072)
          var tabindex = jQuery.find.attr(elem, "tabindex");

          if (tabindex) {
            return parseInt(tabindex, 10);
          }

          if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
            return 0;
          }

          return -1;
        }
      }
    },
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  }); // Support: IE <=11 only
  // Accessing the selectedIndex property
  // forces the browser to respect setting selected
  // on the option
  // The getter ensures a default option is selected
  // when in an optgroup
  // eslint rule "no-unused-expressions" is disabled for this code
  // since it considers such accessions noop

  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function get(elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }

        return null;
      },
      set: function set(elem) {
        /* eslint no-unused-expressions: "off" */
        var parent = elem.parentNode;

        if (parent) {
          parent.selectedIndex;

          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }

  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  }); // Strip and collapse whitespace according to HTML spec
  // https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace

  function stripAndCollapse(value) {
    var tokens = value.match(rnothtmlwhite) || [];
    return tokens.join(" ");
  }

  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }

  function classesToArray(value) {
    if (Array.isArray(value)) {
      return value;
    }

    if (typeof value === "string") {
      return value.match(rnothtmlwhite) || [];
    }

    return [];
  }

  jQuery.fn.extend({
    addClass: function addClass(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    removeClass: function removeClass(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;

      if (isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }

      if (!arguments.length) {
        return this.attr("class", "");
      }

      classes = classesToArray(value);

      if (classes.length) {
        while (elem = this[i++]) {
          curValue = getClass(elem); // This expression is here for better compressibility (see addClass)

          cur = elem.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";

          if (cur) {
            j = 0;

            while (clazz = classes[j++]) {
              // Remove *all* instances
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            } // Only assign if different to avoid unneeded rendering.


            finalValue = stripAndCollapse(cur);

            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }

      return this;
    },
    toggleClass: function toggleClass(value, stateVal) {
      var type = _typeof(value),
          isValidValue = type === "string" || Array.isArray(value);

      if (typeof stateVal === "boolean" && isValidValue) {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }

      if (isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }

      return this.each(function () {
        var className, i, self, classNames;

        if (isValidValue) {
          // Toggle individual class names
          i = 0;
          self = jQuery(this);
          classNames = classesToArray(value);

          while (className = classNames[i++]) {
            // Check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          } // Toggle whole class name

        } else if (value === undefined || type === "boolean") {
          className = getClass(this);

          if (className) {
            // Store className if set
            dataPriv.set(this, "__className__", className);
          } // If the element has a class name or if we're passed `false`,
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.


          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function hasClass(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";

      while (elem = this[i++]) {
        if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
          return true;
        }
      }

      return false;
    }
  });
  var rreturn = /\r/g;
  jQuery.fn.extend({
    val: function val(value) {
      var hooks,
          ret,
          valueIsFunction,
          elem = this[0];

      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }

          ret = elem.value; // Handle most common string cases

          if (typeof ret === "string") {
            return ret.replace(rreturn, "");
          } // Handle cases where value is null/undef or number


          return ret == null ? "" : ret;
        }

        return;
      }

      valueIsFunction = isFunction(value);
      return this.each(function (i) {
        var val;

        if (this.nodeType !== 1) {
          return;
        }

        if (valueIsFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        } // Treat null/undefined as ""; convert numbers to string


        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (Array.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? "" : value + "";
          });
        }

        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]; // If set returns undefined, fall back to normal setting

        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function get(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : // Support: IE <=10 - 11 only
          // option.text throws exceptions (#14686, #14858)
          // Strip and collapse whitespace
          // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
          stripAndCollapse(jQuery.text(elem));
        }
      },
      select: {
        get: function get(elem) {
          var value,
              option,
              i,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one",
              values = one ? null : [],
              max = one ? index + 1 : options.length;

          if (index < 0) {
            i = max;
          } else {
            i = one ? index : 0;
          } // Loop through all the selected options


          for (; i < max; i++) {
            option = options[i]; // Support: IE <=9 only
            // IE8-9 doesn't update selected after form reset (#2551)

            if ((option.selected || i === index) && // Don't return options that are disabled or in a disabled optgroup
            !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
              // Get the specific value for the option
              value = jQuery(option).val(); // We don't need an array for one selects

              if (one) {
                return value;
              } // Multi-Selects return an array


              values.push(value);
            }
          }

          return values;
        },
        set: function set(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;

          while (i--) {
            option = options[i];
            /* eslint-disable no-cond-assign */

            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
            /* eslint-enable no-cond-assign */

          } // Force browsers to behave consistently when non-matching value is set


          if (!optionSet) {
            elem.selectedIndex = -1;
          }

          return values;
        }
      }
    }
  }); // Radios and checkboxes getter/setter

  jQuery.each(["radio", "checkbox"], function () {
    jQuery.valHooks[this] = {
      set: function set(elem, value) {
        if (Array.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
        }
      }
    };

    if (!support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  }); // Return jQuery for attributes-only inclusion

  support.focusin = "onfocusin" in window;

  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
      stopPropagationCallback = function stopPropagationCallback(e) {
    e.stopPropagation();
  };

  jQuery.extend(jQuery.event, {
    trigger: function trigger(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          lastElement,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = lastElement = tmp = elem = elem || document; // Don't do events on text and comment nodes

      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      } // focus/blur morphs to focusin/out; ensure we're not firing them right now


      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }

      if (type.indexOf(".") > -1) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }

      ontype = type.indexOf(":") < 0 && "on" + type; // Caller can pass in a jQuery.Event object, Object, or just an event type string

      event = event[jQuery.expando] ? event : new jQuery.Event(type, _typeof(event) === "object" && event); // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)

      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null; // Clean up the event in case it is being reused

      event.result = undefined;

      if (!event.target) {
        event.target = elem;
      } // Clone any incoming data and prepend the event, creating the handler arg list


      data = data == null ? [event] : jQuery.makeArray(data, [event]); // Allow special events to draw outside the lines

      special = jQuery.event.special[type] || {};

      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      } // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)


      if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
        bubbleType = special.delegateType || type;

        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }

        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        } // Only add window if we got to document (e.g., not plain obj or detached DOM)


        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      } // Fire handlers on the event path


      i = 0;

      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        lastElement = cur;
        event.type = i > 1 ? bubbleType : special.bindType || type; // jQuery handler

        handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle");

        if (handle) {
          handle.apply(cur, data);
        } // Native handler


        handle = ontype && cur[ontype];

        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);

          if (event.result === false) {
            event.preventDefault();
          }
        }
      }

      event.type = type; // If nobody prevented the default action, do it now

      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          // Call a native DOM method on the target with the same name as the event.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];

            if (tmp) {
              elem[ontype] = null;
            } // Prevent re-triggering of the same event, since we already bubbled it above


            jQuery.event.triggered = type;

            if (event.isPropagationStopped()) {
              lastElement.addEventListener(type, stopPropagationCallback);
            }

            elem[type]();

            if (event.isPropagationStopped()) {
              lastElement.removeEventListener(type, stopPropagationCallback);
            }

            jQuery.event.triggered = undefined;

            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }

      return event.result;
    },
    // Piggyback on a donor event to simulate a different one
    // Used only for `focus(in | out)` events
    simulate: function simulate(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
    }
  });
  jQuery.fn.extend({
    trigger: function trigger(type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function triggerHandler(type, data) {
      var elem = this[0];

      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  }); // Support: Firefox <=44
  // Firefox doesn't have focus(in | out) events
  // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
  //
  // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
  // focus(in | out) events fire after focus & blur events,
  // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
  // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857

  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function (orig, fix) {
      // Attach a single capturing handler on the document while someone wants focusin/focusout
      var handler = function handler(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };

      jQuery.event.special[fix] = {
        setup: function setup() {
          // Handle: regular nodes (via `this.ownerDocument`), window
          // (via `this.document`) & document (via `this`).
          var doc = this.ownerDocument || this.document || this,
              attaches = dataPriv.access(doc, fix);

          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }

          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function teardown() {
          var doc = this.ownerDocument || this.document || this,
              attaches = dataPriv.access(doc, fix) - 1;

          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }

  var location = window.location;
  var nonce = {
    guid: Date.now()
  };
  var rquery = /\?/; // Cross-browser xml parsing

  jQuery.parseXML = function (data) {
    var xml, parserErrorElem;

    if (!data || typeof data !== "string") {
      return null;
    } // Support: IE 9 - 11 only
    // IE throws on parseFromString with invalid input.


    try {
      xml = new window.DOMParser().parseFromString(data, "text/xml");
    } catch (e) {}

    parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];

    if (!xml || parserErrorElem) {
      jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function (el) {
        return el.textContent;
      }).join("\n") : data));
    }

    return xml;
  };

  var rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;

  function buildParams(prefix, obj, traditional, add) {
    var name;

    if (Array.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + "[" + (_typeof(v) === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && toType(obj) === "object") {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  } // Serialize an array of form elements or a set of
  // key/values into a query string


  jQuery.param = function (a, traditional) {
    var prefix,
        s = [],
        add = function add(key, valueOrFunction) {
      // If value is a function, invoke it and use its return value
      var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
      s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
    };

    if (a == null) {
      return "";
    } // If an array was passed in, assume that it is an array of form elements.


    if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    } // Return the resulting serialization


    return s.join("&");
  };

  jQuery.fn.extend({
    serialize: function serialize() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function serializeArray() {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type; // Use .is( ":disabled" ) so that fieldset[disabled] works

        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function (_i, elem) {
        var val = jQuery(this).val();

        if (val == null) {
          return null;
        }

        if (Array.isArray(val)) {
          return jQuery.map(val, function (val) {
            return {
              name: elem.name,
              value: val.replace(rCRLF, "\r\n")
            };
          });
        }

        return {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  var r20 = /%20/g,
      rhash = /#.*$/,
      rantiCache = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      // #7653, #8125, #8152: local protocol detection
  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,

  /* Prefilters
   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
   * 2) These are called:
   *    - BEFORE asking for a transport
   *    - AFTER param serialization (s.data is a string if s.processData is true)
   * 3) key is the dataType
   * 4) the catchall symbol "*" can be used
   * 5) execution will start with transport dataType and THEN continue down to "*" if needed
   */
  prefilters = {},

  /* Transports bindings
   * 1) key is the dataType
   * 2) the catchall symbol "*" can be used
   * 3) selection will start with transport dataType and THEN go to "*" if needed
   */
  transports = {},
      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
  allTypes = "*/".concat("*"),
      // Anchor tag for parsing the document origin
  originAnchor = document.createElement("a");
  originAnchor.href = location.href; // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport

  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }

      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

      if (isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while (dataType = dataTypes[i++]) {
          // Prepend if requested
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  } // Base inspection function for prefilters and transports


  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = structure === transports;

    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);

        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }

    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  } // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887


  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};

    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }

    if (deep) {
      jQuery.extend(true, target, deep);
    }

    return target;
  }
  /* Handles responses to an ajax request:
   * - finds the right dataType (mediates between content-type and expected dataType)
   * - returns the corresponding response
   */


  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process

    while (dataTypes[0] === "*") {
      dataTypes.shift();

      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    } // Check if we're dealing with a known content-type


    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    } // Check to see if we have a response for the expected dataType


    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }

        if (!firstDataType) {
          firstDataType = type;
        }
      } // Or just use first one


      finalDataType = finalDataType || firstDataType;
    } // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response


    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }

      return responses[finalDataType];
    }
  }
  /* Chain conversions given the request and the original response
   * Also sets the responseXXX fields on the jqXHR instance
   */


  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys

    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }

    current = dataTypes.shift(); // Convert to each sequential dataType

    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      } // Apply the dataFilter if provided


      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }

      prev = current;
      current = dataTypes.shift();

      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === "*") {
          current = prev; // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== "*" && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + " " + current] || converters["* " + current]; // If none found, seek a pair

          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(" ");

              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];

                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }

                  break;
                }
              }
            }
          } // Apply converter (if not an equivalence)


          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }

    return {
      state: "success",
      data: response
    };
  }

  jQuery.extend({
    // Counter for holding the number of active queries
    active: 0,
    // Last-Modified header cache for next request
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",

      /*
      timeout: 0,
      data: null,
      dataType: null,
      username: null,
      password: null,
      cache: null,
      throws: false,
      traditional: false,
      headers: {},
      */
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      // Data converters
      // Keys separate source (or catchall "*") and destination types with a single space
      converters: {
        // Convert anything to text
        "* text": String,
        // Text to html (true = no transformation)
        "text html": true,
        // Evaluate text as a json expression
        "text json": JSON.parse,
        // Parse text as xml
        "text xml": jQuery.parseXML
      },
      // For options that shouldn't be deep extended:
      // you can add your own custom options here if
      // and when you create one that shouldn't be
      // deep extended (see ajaxExtend)
      flatOptions: {
        url: true,
        context: true
      }
    },
    // Creates a full fledged settings object into target
    // with both ajaxSettings and settings fields.
    // If target is omitted, writes into ajaxSettings.
    ajaxSetup: function ajaxSetup(target, settings) {
      return settings ? // Building a settings object
      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings
      ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    // Main method
    ajax: function ajax(url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (_typeof(url) === "object") {
        options = url;
        url = undefined;
      } // Force options to be an object


      options = options || {};

      var transport,
          // URL without anti-cache param
      cacheURL,
          // Response headers
      responseHeadersString,
          responseHeaders,
          // timeout handle
      timeoutTimer,
          // Url cleanup var
      urlAnchor,
          // Request state (becomes false upon send and true upon completion)
      completed,
          // To know if global events are to be dispatched
      fireGlobals,
          // Loop variable
      i,
          // uncached part of the url
      uncached,
          // Create the final options object
      s = jQuery.ajaxSetup({}, options),
          // Callbacks context
      callbackContext = s.context || s,
          // Context for global events is callbackContext if it is a DOM node or jQuery collection
      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          // Deferreds
      deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          // Status-dependent callbacks
      _statusCode = s.statusCode || {},
          // Headers (they are sent all at once)
      requestHeaders = {},
          requestHeadersNames = {},
          // Default abort message
      strAbort = "canceled",
          // Fake xhr
      jqXHR = {
        readyState: 0,
        // Builds headers hashtable if needed
        getResponseHeader: function getResponseHeader(key) {
          var match;

          if (completed) {
            if (!responseHeaders) {
              responseHeaders = {};

              while (match = rheaders.exec(responseHeadersString)) {
                responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
              }
            }

            match = responseHeaders[key.toLowerCase() + " "];
          }

          return match == null ? null : match.join(", ");
        },
        // Raw string
        getAllResponseHeaders: function getAllResponseHeaders() {
          return completed ? responseHeadersString : null;
        },
        // Caches the header
        setRequestHeader: function setRequestHeader(name, value) {
          if (completed == null) {
            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
            requestHeaders[name] = value;
          }

          return this;
        },
        // Overrides response content-type header
        overrideMimeType: function overrideMimeType(type) {
          if (completed == null) {
            s.mimeType = type;
          }

          return this;
        },
        // Status-dependent callbacks
        statusCode: function statusCode(map) {
          var code;

          if (map) {
            if (completed) {
              // Execute the appropriate callbacks
              jqXHR.always(map[jqXHR.status]);
            } else {
              // Lazy-add the new callbacks in a way that preserves old ones
              for (code in map) {
                _statusCode[code] = [_statusCode[code], map[code]];
              }
            }
          }

          return this;
        },
        // Cancel the request
        abort: function abort(statusText) {
          var finalText = statusText || strAbort;

          if (transport) {
            transport.abort(finalText);
          }

          done(0, finalText);
          return this;
        }
      }; // Attach deferreds


      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available

      s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"); // Alias method option to type as per ticket #12004

      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list

      s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""]; // A cross-domain request is in order when the origin doesn't match the current origin.

      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a"); // Support: IE <=8 - 11, Edge 12 - 15
        // IE throws exception on accessing the href property if url is malformed,
        // e.g. http://example.com:80x/

        try {
          urlAnchor.href = s.url; // Support: IE <=8 - 11 only
          // Anchor's host property isn't correctly set when s.url is relative

          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          // If there is an error parsing the URL, assume it is crossDomain,
          // it can be rejected by the transport if it is invalid
          s.crossDomain = true;
        }
      } // Convert data if not already a string


      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      } // Apply prefilters


      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there

      if (completed) {
        return jqXHR;
      } // We can fire global events as of now if asked to
      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)


      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests

      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      } // Uppercase the type


      s.type = s.type.toUpperCase(); // Determine if request has content

      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      // Remove hash to simplify url manipulation

      cacheURL = s.url.replace(rhash, ""); // More options handling for requests with no content

      if (!s.hasContent) {
        // Remember the hash so we can put it back
        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url

        if (s.data && (s.processData || typeof s.data === "string")) {
          cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data; // #9682: remove data so that it's not used in an eventual retry

          delete s.data;
        } // Add or update anti-cache param if needed


        if (s.cache === false) {
          cacheURL = cacheURL.replace(rantiCache, "$1");
          uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
        } // Put hash and anti-cache on the URL that will be requested (gh-1732)


        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)
      } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
        s.data = s.data.replace(r20, "+");
      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.


      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }

        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      } // Set the correct header, if data is being sent


      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      } // Set the Accepts header for the server, depending on the dataType


      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]); // Check for headers option

      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      } // Allow custom headers/mimetypes and early abort


      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {
        // Abort if not done already and return
        return jqXHR.abort();
      } // Aborting is no longer a cancellation


      strAbort = "abort"; // Install callbacks on deferreds

      completeDeferred.add(s.complete);
      jqXHR.done(s.success);
      jqXHR.fail(s.error); // Get transport

      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort

      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1; // Send global event

        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        } // If request was aborted inside ajaxSend, stop there


        if (completed) {
          return jqXHR;
        } // Timeout


        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function () {
            jqXHR.abort("timeout");
          }, s.timeout);
        }

        try {
          completed = false;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Rethrow post-completion exceptions
          if (completed) {
            throw e;
          } // Propagate others as results


          done(-1, e);
        }
      } // Callback for when everything is done


      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText; // Ignore repeat invocations

        if (completed) {
          return;
        }

        completed = true; // Clear timeout if it exists

        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        } // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)


        transport = undefined; // Cache response headers

        responseHeadersString = headers || ""; // Set readyState

        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful

        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data

        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        } // Use a noop converter for missing script but not if jsonp


        if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
          s.converters["text script"] = function () {};
        } // Convert no matter what (that way responseXXX fields are always set)


        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining

        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");

            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }

            modified = jqXHR.getResponseHeader("etag");

            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          } // if no content


          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent"; // if not modified
          } else if (status === 304) {
            statusText = "notmodified"; // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // Extract error from statusText and normalize for non-aborts
          error = statusText;

          if (status || !statusText) {
            statusText = "error";

            if (status < 0) {
              status = 0;
            }
          }
        } // Set data for the fake xhr object


        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + ""; // Success/Error

        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        } // Status-dependent callbacks


        jqXHR.statusCode(_statusCode);
        _statusCode = undefined;

        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        } // Complete


        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]); // Handle the global AJAX counter

          if (! --jQuery.active) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }

      return jqXHR;
    },
    getJSON: function getJSON(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function getScript(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function (_i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // Shift arguments if data argument was omitted
      if (isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      } // The url can be an options object (which then must have .url)


      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery.ajaxPrefilter(function (s) {
    var i;

    for (i in s.headers) {
      if (i.toLowerCase() === "content-type") {
        s.contentType = s.headers[i] || "";
      }
    }
  });

  jQuery._evalUrl = function (url, options, doc) {
    return jQuery.ajax({
      url: url,
      // Make this explicit, since user can override this through ajaxSetup (#11264)
      type: "GET",
      dataType: "script",
      cache: true,
      async: false,
      global: false,
      // Only evaluate the response if it is successful (gh-4126)
      // dataFilter is not invoked for failure responses, so using it instead
      // of the default converter is kludgy but it works.
      converters: {
        "text script": function textScript() {}
      },
      dataFilter: function dataFilter(response) {
        jQuery.globalEval(response, options, doc);
      }
    });
  };

  jQuery.fn.extend({
    wrapAll: function wrapAll(html) {
      var wrap;

      if (this[0]) {
        if (isFunction(html)) {
          html = html.call(this[0]);
        } // The elements to wrap the target around


        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }

        wrap.map(function () {
          var elem = this;

          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }

          return elem;
        }).append(this);
      }

      return this;
    },
    wrapInner: function wrapInner(html) {
      if (isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }

      return this.each(function () {
        var self = jQuery(this),
            contents = self.contents();

        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function wrap(html) {
      var htmlIsFunction = isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function unwrap(selector) {
      this.parent(selector).not("body").each(function () {
        jQuery(this).replaceWith(this.childNodes);
      });
      return this;
    }
  });

  jQuery.expr.pseudos.hidden = function (elem) {
    return !jQuery.expr.pseudos.visible(elem);
  };

  jQuery.expr.pseudos.visible = function (elem) {
    return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
  };

  jQuery.ajaxSettings.xhr = function () {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };

  var xhrSuccessStatus = {
    // File protocol always yields status code 0, assume 200
    0: 200,
    // Support: IE <=9 only
    // #1450: sometimes IE returns 1223 when it should be 204
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function (options) {
    var _callback, errorCallback; // Cross domain only allowed if supported through XMLHttpRequest


    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function send(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password); // Apply custom fields if provided

          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          } // Override mime type if needed


          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          } // X-Requested-With header
          // For cross-domain requests, seeing as conditions for a preflight are
          // akin to a jigsaw puzzle, we simply never set it to be sure.
          // (it can always be set on a per-request basis or even using ajaxSetup)
          // For same-domain requests, won't change header if already provided.


          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          } // Set headers


          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          } // Callback


          _callback = function callback(type) {
            return function () {
              if (_callback) {
                _callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;

                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  // Support: IE <=9 only
                  // On a manual native abort, IE9 throws
                  // errors on any property access that is not readyState
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete( // File: protocol always yields status 0; see #8605, #14207
                    xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, // Support: IE <=9 only
                  // IE9 has no XHR2 but throws on binary (trac-11426)
                  // For XHR2 non-text, let the caller handle it (gh-2498)
                  (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                    binary: xhr.response
                  } : {
                    text: xhr.responseText
                  }, xhr.getAllResponseHeaders());
                }
              }
            };
          }; // Listen to events


          xhr.onload = _callback();
          errorCallback = xhr.onerror = xhr.ontimeout = _callback("error"); // Support: IE 9 only
          // Use onreadystatechange to replace onabort
          // to handle uncaught aborts

          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function () {
              // Check readyState before timeout as it changes
              if (xhr.readyState === 4) {
                // Allow onerror to be called first,
                // but that will not handle a native abort
                // Also, save errorCallback to a variable
                // as xhr.onerror cannot be accessed
                window.setTimeout(function () {
                  if (_callback) {
                    errorCallback();
                  }
                });
              }
            };
          } // Create the abort callback


          _callback = _callback("abort");

          try {
            // Do send the request (this may raise an exception)
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            // #14683: Only rethrow if this hasn't been notified as an error yet
            if (_callback) {
              throw e;
            }
          }
        },
        abort: function abort() {
          if (_callback) {
            _callback();
          }
        }
      };
    }
  }); // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)

  jQuery.ajaxPrefilter(function (s) {
    if (s.crossDomain) {
      s.contents.script = false;
    }
  }); // Install script dataType

  jQuery.ajaxSetup({
    accepts: {
      script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
    },
    contents: {
      script: /\b(?:java|ecma)script\b/
    },
    converters: {
      "text script": function textScript(text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  }); // Handle cache's special case and crossDomain

  jQuery.ajaxPrefilter("script", function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }

    if (s.crossDomain) {
      s.type = "GET";
    }
  }); // Bind script tag hack transport

  jQuery.ajaxTransport("script", function (s) {
    // This transport only deals with cross domain or forced-by-attrs requests
    if (s.crossDomain || s.scriptAttrs) {
      var script, _callback2;

      return {
        send: function send(_, complete) {
          script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", _callback2 = function callback(evt) {
            script.remove();
            _callback2 = null;

            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          }); // Use native DOM manipulation to avoid our domManip AJAX trickery

          document.head.appendChild(script[0]);
        },
        abort: function abort() {
          if (_callback2) {
            _callback2();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/; // Default jsonp settings

  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function jsonpCallback() {
      var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
      this[callback] = true;
      return callback;
    }
  }); // Detect, normalize options and install callbacks for jsonp requests

  jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data"); // Handle iff the expected data type is "jsonp" or we have a parameter to set

    if (jsonProp || s.dataTypes[0] === "jsonp") {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback; // Insert callback into url or form data

      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      } // Use data converter to retrieve json after script execution


      s.converters["script json"] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }

        return responseContainer[0];
      }; // Force json dataType


      s.dataTypes[0] = "json"; // Install callback

      overwritten = window[callbackName];

      window[callbackName] = function () {
        responseContainer = arguments;
      }; // Clean-up function (fires after converters)


      jqXHR.always(function () {
        // If previous value didn't exist - remove it
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName); // Otherwise restore preexisting value
        } else {
          window[callbackName] = overwritten;
        } // Save back as free


        if (s[callbackName]) {
          // Make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback; // Save the callback name for future use

          oldCallbacks.push(callbackName);
        } // Call if it was a function and we have a response


        if (responseContainer && isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }

        responseContainer = overwritten = undefined;
      }); // Delegate to script

      return "script";
    }
  }); // Support: Safari 8 only
  // In Safari 8 documents created via document.implementation.createHTMLDocument
  // collapse sibling forms: the second one becomes a child of the first one.
  // Because of that, this security measure has to be disabled in Safari 8.
  // https://bugs.webkit.org/show_bug.cgi?id=137337

  support.createHTMLDocument = function () {
    var body = document.implementation.createHTMLDocument("").body;
    body.innerHTML = "<form></form><form></form>";
    return body.childNodes.length === 2;
  }(); // Argument "data" should be string of html
  // context (optional): If specified, the fragment will be created in this context,
  // defaults to document
  // keepScripts (optional): If true, will include scripts passed in the html string


  jQuery.parseHTML = function (data, context, keepScripts) {
    if (typeof data !== "string") {
      return [];
    }

    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }

    var base, parsed, scripts;

    if (!context) {
      // Stop scripts or inline event handlers from being executed immediately
      // by using document.implementation
      if (support.createHTMLDocument) {
        context = document.implementation.createHTMLDocument(""); // Set the base href for the created document
        // so any parsed elements with URLs
        // are based on the document's URL (gh-2965)

        base = context.createElement("base");
        base.href = document.location.href;
        context.head.appendChild(base);
      } else {
        context = document;
      }
    }

    parsed = rsingleTag.exec(data);
    scripts = !keepScripts && []; // Single tag

    if (parsed) {
      return [context.createElement(parsed[1])];
    }

    parsed = buildFragment([data], context, scripts);

    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }

    return jQuery.merge([], parsed.childNodes);
  };
  /**
   * Load a url into a page
   */


  jQuery.fn.load = function (url, params, callback) {
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");

    if (off > -1) {
      selector = stripAndCollapse(url.slice(off));
      url = url.slice(0, off);
    } // If it's a function


    if (isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined; // Otherwise, build a param string
    } else if (params && _typeof(params) === "object") {
      type = "POST";
    } // If we have elements to modify, make the request


    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        // If "type" variable is undefined, then "GET" method will be used.
        // Make value of this field explicit since
        // user can override it through ajaxSetup method
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function (responseText) {
        // Save response for use in complete callback
        response = arguments;
        self.html(selector ? // If a selector was specified, locate the right elements in a dummy div
        // Exclude scripts to avoid IE 'Permission Denied' errors
        jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : // Otherwise use the full result
        responseText); // If the request succeeds, this function gets "data", "status", "jqXHR"
        // but they are ignored because response was set above.
        // If it fails, this function gets "jqXHR", "status", "error"
      }).always(callback && function (jqXHR, status) {
        self.each(function () {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }

    return this;
  };

  jQuery.expr.pseudos.animated = function (elem) {
    return jQuery.grep(jQuery.timers, function (fn) {
      return elem === fn.elem;
    }).length;
  };

  jQuery.offset = {
    setOffset: function setOffset(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {}; // Set position first, in-case top/left are set even on static elem

      if (position === "static") {
        elem.style.position = "relative";
      }

      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1; // Need to be able to calculate position if either
      // top or left is auto and position is either absolute or fixed

      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }

      if (isFunction(options)) {
        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }

      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }

      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }

      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    // offset() relates an element's border box to the document origin
    offset: function offset(options) {
      // Preserve chaining for setter
      if (arguments.length) {
        return options === undefined ? this : this.each(function (i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }

      var rect,
          win,
          elem = this[0];

      if (!elem) {
        return;
      } // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
      // Support: IE <=11 only
      // Running getBoundingClientRect on a
      // disconnected node in IE throws an error


      if (!elem.getClientRects().length) {
        return {
          top: 0,
          left: 0
        };
      } // Get document-relative position by adding viewport scroll to viewport-relative gBCR


      rect = elem.getBoundingClientRect();
      win = elem.ownerDocument.defaultView;
      return {
        top: rect.top + win.pageYOffset,
        left: rect.left + win.pageXOffset
      };
    },
    // position() relates an element's margin box to its offset parent's padding box
    // This corresponds to the behavior of CSS absolute positioning
    position: function position() {
      if (!this[0]) {
        return;
      }

      var offsetParent,
          offset,
          doc,
          elem = this[0],
          parentOffset = {
        top: 0,
        left: 0
      }; // position:fixed elements are offset from the viewport, which itself always has zero offset

      if (jQuery.css(elem, "position") === "fixed") {
        // Assume position:fixed implies availability of getBoundingClientRect
        offset = elem.getBoundingClientRect();
      } else {
        offset = this.offset(); // Account for the *real* offset parent, which can be the document or its root element
        // when a statically positioned element is identified

        doc = elem.ownerDocument;
        offsetParent = elem.offsetParent || doc.documentElement;

        while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.parentNode;
        }

        if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
          // Incorporate borders into its offset, since they are outside its content origin
          parentOffset = jQuery(offsetParent).offset();
          parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
          parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
        }
      } // Subtract parent offsets and element margins


      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    // This method will return documentElement in the following cases:
    // 1) For the element inside the iframe without offsetParent, this method will return
    //    documentElement of the parent window
    // 2) For the hidden or detached element
    // 3) For body or html element, i.e. in case of the html node - it will return itself
    //
    // but those exceptions were never presented as a real life use-cases
    // and might be considered as more preferable results.
    //
    // This logic, however, is not guaranteed and can change at any point in the future
    offsetParent: function offsetParent() {
      return this.map(function () {
        var offsetParent = this.offsetParent;

        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || documentElement;
      });
    }
  }); // Create scrollLeft and scrollTop methods

  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function (method, prop) {
    var top = "pageYOffset" === prop;

    jQuery.fn[method] = function (val) {
      return access(this, function (elem, method, val) {
        // Coalesce documents and windows
        var win;

        if (isWindow(elem)) {
          win = elem;
        } else if (elem.nodeType === 9) {
          win = elem.defaultView;
        }

        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }

        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  }); // Support: Safari <=7 - 9.1, Chrome <=37 - 49
  // Add the top/left cssHooks using jQuery.fn.position
  // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
  // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
  // getComputedStyle returns percent when specified for top/left/bottom/right;
  // rather than make the css module depend on the offset module, just check for it here

  jQuery.each(["top", "left"], function (_i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop); // If curCSS returns percentage, fallback to offset

        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  }); // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods

  jQuery.each({
    Height: "height",
    Width: "width"
  }, function (name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function (defaultExtra, funcName) {
      // Margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function (elem, type, value) {
          var doc;

          if (isWindow(elem)) {
            // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
            return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
          } // Get document width or height


          if (elem.nodeType === 9) {
            doc = elem.documentElement; // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
            // whichever is greatest

            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }

          return value === undefined ? // Get width or height on the element, requesting but not forcing parseFloat
          jQuery.css(elem, type, extra) : // Set width or height on the element
          jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable);
      };
    });
  });
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (_i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.fn.extend({
    bind: function bind(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function unbind(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function delegate(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function undelegate(selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    },
    hover: function hover(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }
  });
  jQuery.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function (_i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  }); // Support: Android <=4.0 only
  // Make sure we trim BOM and NBSP

  var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g; // Bind a function to a context, optionally partially applying any
  // arguments.
  // jQuery.proxy is deprecated to promote standards (specifically Function#bind)
  // However, it is not slated for removal any time soon

  jQuery.proxy = function (fn, context) {
    var tmp, args, proxy;

    if (typeof context === "string") {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    } // Quick check to determine if target is callable, in the spec
    // this throws a TypeError, but we will just return undefined.


    if (!isFunction(fn)) {
      return undefined;
    } // Simulated bind


    args = _slice.call(arguments, 2);

    proxy = function proxy() {
      return fn.apply(context || this, args.concat(_slice.call(arguments)));
    }; // Set the guid of unique handler to the same of original handler, so it can be removed


    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    return proxy;
  };

  jQuery.holdReady = function (hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  };

  jQuery.isArray = Array.isArray;
  jQuery.parseJSON = JSON.parse;
  jQuery.nodeName = nodeName;
  jQuery.isFunction = isFunction;
  jQuery.isWindow = isWindow;
  jQuery.camelCase = camelCase;
  jQuery.type = toType;
  jQuery.now = Date.now;

  jQuery.isNumeric = function (obj) {
    // As of jQuery 3.0, isNumeric is limited to
    // strings and numbers (primitives or objects)
    // that can be coerced to finite numbers (gh-2662)
    var type = jQuery.type(obj);
    return (type === "number" || type === "string") && // parseFloat NaNs numeric-cast false positives ("")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    !isNaN(obj - parseFloat(obj));
  };

  jQuery.trim = function (text) {
    return text == null ? "" : (text + "").replace(rtrim, "");
  }; // Register as a named AMD module, since jQuery can be concatenated with other
  // files that may use define, but not via a proper concatenation script that
  // understands anonymous AMD modules. A named AMD is safest and most robust
  // way to register. Lowercase jquery is used because AMD module names are
  // derived from file names, and jQuery is normally delivered in a lowercase
  // file name. Do this after creating the global so that if an AMD module wants
  // to call noConflict to hide this version of jQuery, it will work.
  // Note that for maximum portability, libraries that are not jQuery should
  // declare themselves as anonymous modules, and avoid setting a global if an
  // AMD loader is present. jQuery is a special case. For more information, see
  // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon


  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return jQuery;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }

  var // Map over jQuery in case of overwrite
  _jQuery = window.jQuery,
      // Map over the $ in case of overwrite
  _$ = window.$;

  jQuery.noConflict = function (deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }

    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }

    return jQuery;
  }; // Expose jQuery and $ identifiers, even in AMD
  // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
  // and CommonJS for browser emulators (#13566)


  if (typeof noGlobal === "undefined") {
    window.jQuery = window.$ = jQuery;
  }

  return jQuery;
});

/***/ }),

/***/ "./node_modules/vue-loader/dist/exportHelper.js":
/*!******************************************************!*\
  !*** ./node_modules/vue-loader/dist/exportHelper.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
})); // runtime helper for setting properties on components
// in a tree-shakable way

exports.default = function (sfc, props) {
  var target = sfc.__vccOpts || sfc;

  var _iterator = _createForOfIteratorHelper(props),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
          key = _step$value[0],
          val = _step$value[1];

      target[key] = val;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return target;
};

/***/ }),

/***/ "./node_modules/vue/dist/vue.esm-browser.js":
/*!**************************************************!*\
  !*** ./node_modules/vue/dist/vue.esm-browser.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseTransition": function() { return /* binding */ BaseTransition; },
/* harmony export */   "Comment": function() { return /* binding */ Comment; },
/* harmony export */   "EffectScope": function() { return /* binding */ EffectScope; },
/* harmony export */   "Fragment": function() { return /* binding */ Fragment; },
/* harmony export */   "KeepAlive": function() { return /* binding */ KeepAlive; },
/* harmony export */   "ReactiveEffect": function() { return /* binding */ ReactiveEffect; },
/* harmony export */   "Static": function() { return /* binding */ Static; },
/* harmony export */   "Suspense": function() { return /* binding */ Suspense; },
/* harmony export */   "Teleport": function() { return /* binding */ Teleport; },
/* harmony export */   "Text": function() { return /* binding */ Text; },
/* harmony export */   "Transition": function() { return /* binding */ Transition; },
/* harmony export */   "TransitionGroup": function() { return /* binding */ TransitionGroup; },
/* harmony export */   "VueElement": function() { return /* binding */ VueElement; },
/* harmony export */   "callWithAsyncErrorHandling": function() { return /* binding */ callWithAsyncErrorHandling; },
/* harmony export */   "callWithErrorHandling": function() { return /* binding */ callWithErrorHandling; },
/* harmony export */   "camelize": function() { return /* binding */ camelize; },
/* harmony export */   "capitalize": function() { return /* binding */ capitalize; },
/* harmony export */   "cloneVNode": function() { return /* binding */ cloneVNode; },
/* harmony export */   "compatUtils": function() { return /* binding */ compatUtils; },
/* harmony export */   "compile": function() { return /* binding */ compileToFunction; },
/* harmony export */   "computed": function() { return /* binding */ computed$1; },
/* harmony export */   "createApp": function() { return /* binding */ createApp; },
/* harmony export */   "createBlock": function() { return /* binding */ createBlock; },
/* harmony export */   "createCommentVNode": function() { return /* binding */ createCommentVNode; },
/* harmony export */   "createElementBlock": function() { return /* binding */ createElementBlock; },
/* harmony export */   "createElementVNode": function() { return /* binding */ createBaseVNode; },
/* harmony export */   "createHydrationRenderer": function() { return /* binding */ createHydrationRenderer; },
/* harmony export */   "createPropsRestProxy": function() { return /* binding */ createPropsRestProxy; },
/* harmony export */   "createRenderer": function() { return /* binding */ createRenderer; },
/* harmony export */   "createSSRApp": function() { return /* binding */ createSSRApp; },
/* harmony export */   "createSlots": function() { return /* binding */ createSlots; },
/* harmony export */   "createStaticVNode": function() { return /* binding */ createStaticVNode; },
/* harmony export */   "createTextVNode": function() { return /* binding */ createTextVNode; },
/* harmony export */   "createVNode": function() { return /* binding */ createVNode; },
/* harmony export */   "customRef": function() { return /* binding */ customRef; },
/* harmony export */   "defineAsyncComponent": function() { return /* binding */ defineAsyncComponent; },
/* harmony export */   "defineComponent": function() { return /* binding */ defineComponent; },
/* harmony export */   "defineCustomElement": function() { return /* binding */ defineCustomElement; },
/* harmony export */   "defineEmits": function() { return /* binding */ defineEmits; },
/* harmony export */   "defineExpose": function() { return /* binding */ defineExpose; },
/* harmony export */   "defineProps": function() { return /* binding */ defineProps; },
/* harmony export */   "defineSSRCustomElement": function() { return /* binding */ defineSSRCustomElement; },
/* harmony export */   "devtools": function() { return /* binding */ devtools; },
/* harmony export */   "effect": function() { return /* binding */ effect; },
/* harmony export */   "effectScope": function() { return /* binding */ effectScope; },
/* harmony export */   "getCurrentInstance": function() { return /* binding */ getCurrentInstance; },
/* harmony export */   "getCurrentScope": function() { return /* binding */ getCurrentScope; },
/* harmony export */   "getTransitionRawChildren": function() { return /* binding */ getTransitionRawChildren; },
/* harmony export */   "guardReactiveProps": function() { return /* binding */ guardReactiveProps; },
/* harmony export */   "h": function() { return /* binding */ h; },
/* harmony export */   "handleError": function() { return /* binding */ handleError; },
/* harmony export */   "hydrate": function() { return /* binding */ hydrate; },
/* harmony export */   "initCustomFormatter": function() { return /* binding */ initCustomFormatter; },
/* harmony export */   "initDirectivesForSSR": function() { return /* binding */ initDirectivesForSSR; },
/* harmony export */   "inject": function() { return /* binding */ inject; },
/* harmony export */   "isMemoSame": function() { return /* binding */ isMemoSame; },
/* harmony export */   "isProxy": function() { return /* binding */ isProxy; },
/* harmony export */   "isReactive": function() { return /* binding */ isReactive; },
/* harmony export */   "isReadonly": function() { return /* binding */ isReadonly; },
/* harmony export */   "isRef": function() { return /* binding */ isRef; },
/* harmony export */   "isRuntimeOnly": function() { return /* binding */ isRuntimeOnly; },
/* harmony export */   "isShallow": function() { return /* binding */ isShallow; },
/* harmony export */   "isVNode": function() { return /* binding */ isVNode; },
/* harmony export */   "markRaw": function() { return /* binding */ markRaw; },
/* harmony export */   "mergeDefaults": function() { return /* binding */ mergeDefaults; },
/* harmony export */   "mergeProps": function() { return /* binding */ mergeProps; },
/* harmony export */   "nextTick": function() { return /* binding */ nextTick; },
/* harmony export */   "normalizeClass": function() { return /* binding */ normalizeClass; },
/* harmony export */   "normalizeProps": function() { return /* binding */ normalizeProps; },
/* harmony export */   "normalizeStyle": function() { return /* binding */ normalizeStyle; },
/* harmony export */   "onActivated": function() { return /* binding */ onActivated; },
/* harmony export */   "onBeforeMount": function() { return /* binding */ onBeforeMount; },
/* harmony export */   "onBeforeUnmount": function() { return /* binding */ onBeforeUnmount; },
/* harmony export */   "onBeforeUpdate": function() { return /* binding */ onBeforeUpdate; },
/* harmony export */   "onDeactivated": function() { return /* binding */ onDeactivated; },
/* harmony export */   "onErrorCaptured": function() { return /* binding */ onErrorCaptured; },
/* harmony export */   "onMounted": function() { return /* binding */ onMounted; },
/* harmony export */   "onRenderTracked": function() { return /* binding */ onRenderTracked; },
/* harmony export */   "onRenderTriggered": function() { return /* binding */ onRenderTriggered; },
/* harmony export */   "onScopeDispose": function() { return /* binding */ onScopeDispose; },
/* harmony export */   "onServerPrefetch": function() { return /* binding */ onServerPrefetch; },
/* harmony export */   "onUnmounted": function() { return /* binding */ onUnmounted; },
/* harmony export */   "onUpdated": function() { return /* binding */ onUpdated; },
/* harmony export */   "openBlock": function() { return /* binding */ openBlock; },
/* harmony export */   "popScopeId": function() { return /* binding */ popScopeId; },
/* harmony export */   "provide": function() { return /* binding */ provide; },
/* harmony export */   "proxyRefs": function() { return /* binding */ proxyRefs; },
/* harmony export */   "pushScopeId": function() { return /* binding */ pushScopeId; },
/* harmony export */   "queuePostFlushCb": function() { return /* binding */ queuePostFlushCb; },
/* harmony export */   "reactive": function() { return /* binding */ reactive; },
/* harmony export */   "readonly": function() { return /* binding */ readonly; },
/* harmony export */   "ref": function() { return /* binding */ ref; },
/* harmony export */   "registerRuntimeCompiler": function() { return /* binding */ registerRuntimeCompiler; },
/* harmony export */   "render": function() { return /* binding */ render; },
/* harmony export */   "renderList": function() { return /* binding */ renderList; },
/* harmony export */   "renderSlot": function() { return /* binding */ renderSlot; },
/* harmony export */   "resolveComponent": function() { return /* binding */ resolveComponent; },
/* harmony export */   "resolveDirective": function() { return /* binding */ resolveDirective; },
/* harmony export */   "resolveDynamicComponent": function() { return /* binding */ resolveDynamicComponent; },
/* harmony export */   "resolveFilter": function() { return /* binding */ resolveFilter; },
/* harmony export */   "resolveTransitionHooks": function() { return /* binding */ resolveTransitionHooks; },
/* harmony export */   "setBlockTracking": function() { return /* binding */ setBlockTracking; },
/* harmony export */   "setDevtoolsHook": function() { return /* binding */ setDevtoolsHook; },
/* harmony export */   "setTransitionHooks": function() { return /* binding */ setTransitionHooks; },
/* harmony export */   "shallowReactive": function() { return /* binding */ shallowReactive; },
/* harmony export */   "shallowReadonly": function() { return /* binding */ shallowReadonly; },
/* harmony export */   "shallowRef": function() { return /* binding */ shallowRef; },
/* harmony export */   "ssrContextKey": function() { return /* binding */ ssrContextKey; },
/* harmony export */   "ssrUtils": function() { return /* binding */ ssrUtils; },
/* harmony export */   "stop": function() { return /* binding */ stop; },
/* harmony export */   "toDisplayString": function() { return /* binding */ toDisplayString; },
/* harmony export */   "toHandlerKey": function() { return /* binding */ toHandlerKey; },
/* harmony export */   "toHandlers": function() { return /* binding */ toHandlers; },
/* harmony export */   "toRaw": function() { return /* binding */ toRaw; },
/* harmony export */   "toRef": function() { return /* binding */ toRef; },
/* harmony export */   "toRefs": function() { return /* binding */ toRefs; },
/* harmony export */   "transformVNodeArgs": function() { return /* binding */ transformVNodeArgs; },
/* harmony export */   "triggerRef": function() { return /* binding */ triggerRef; },
/* harmony export */   "unref": function() { return /* binding */ unref; },
/* harmony export */   "useAttrs": function() { return /* binding */ useAttrs; },
/* harmony export */   "useCssModule": function() { return /* binding */ useCssModule; },
/* harmony export */   "useCssVars": function() { return /* binding */ useCssVars; },
/* harmony export */   "useSSRContext": function() { return /* binding */ useSSRContext; },
/* harmony export */   "useSlots": function() { return /* binding */ useSlots; },
/* harmony export */   "useTransitionState": function() { return /* binding */ useTransitionState; },
/* harmony export */   "vModelCheckbox": function() { return /* binding */ vModelCheckbox; },
/* harmony export */   "vModelDynamic": function() { return /* binding */ vModelDynamic; },
/* harmony export */   "vModelRadio": function() { return /* binding */ vModelRadio; },
/* harmony export */   "vModelSelect": function() { return /* binding */ vModelSelect; },
/* harmony export */   "vModelText": function() { return /* binding */ vModelText; },
/* harmony export */   "vShow": function() { return /* binding */ vShow; },
/* harmony export */   "version": function() { return /* binding */ version; },
/* harmony export */   "warn": function() { return /* binding */ warn$1; },
/* harmony export */   "watch": function() { return /* binding */ watch; },
/* harmony export */   "watchEffect": function() { return /* binding */ watchEffect; },
/* harmony export */   "watchPostEffect": function() { return /* binding */ watchPostEffect; },
/* harmony export */   "watchSyncEffect": function() { return /* binding */ watchSyncEffect; },
/* harmony export */   "withAsyncContext": function() { return /* binding */ withAsyncContext; },
/* harmony export */   "withCtx": function() { return /* binding */ withCtx; },
/* harmony export */   "withDefaults": function() { return /* binding */ withDefaults; },
/* harmony export */   "withDirectives": function() { return /* binding */ withDirectives; },
/* harmony export */   "withKeys": function() { return /* binding */ withKeys; },
/* harmony export */   "withMemo": function() { return /* binding */ withMemo; },
/* harmony export */   "withModifiers": function() { return /* binding */ withModifiers; },
/* harmony export */   "withScopeId": function() { return /* binding */ withScopeId; }
/* harmony export */ });
var _PatchFlagNames,_slotFlagsText,_ErrorTypeStrings,_errorMessages,_helperNameMap,_deprecationData,_registerRuntimeHelpe,_DOMErrorMessages;function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function");}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,writable:true,configurable:true}});if(superClass)_setPrototypeOf(subClass,superClass);}function _setPrototypeOf(o,p){_setPrototypeOf=Object.setPrototypeOf||function _setPrototypeOf(o,p){o.__proto__=p;return o;};return _setPrototypeOf(o,p);}function _createSuper(Derived){var hasNativeReflectConstruct=_isNativeReflectConstruct();return function _createSuperInternal(){var Super=_getPrototypeOf(Derived),result;if(hasNativeReflectConstruct){var NewTarget=_getPrototypeOf(this).constructor;result=Reflect.construct(Super,arguments,NewTarget);}else{result=Super.apply(this,arguments);}return _possibleConstructorReturn(this,result);};}function _possibleConstructorReturn(self,call){if(call&&(_typeof(call)==="object"||typeof call==="function")){return call;}return _assertThisInitialized(self);}function _assertThisInitialized(self){if(self===void 0){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return self;}function _isNativeReflectConstruct(){if(typeof Reflect==="undefined"||!Reflect.construct)return false;if(Reflect.construct.sham)return false;if(typeof Proxy==="function")return true;try{Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}));return true;}catch(e){return false;}}function _getPrototypeOf(o){_getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function _getPrototypeOf(o){return o.__proto__||Object.getPrototypeOf(o);};return _getPrototypeOf(o);}function _createForOfIteratorHelper(o,allowArrayLike){var it=typeof Symbol!=="undefined"&&o[Symbol.iterator]||o["@@iterator"];if(!it){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length==="number"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e2){throw _e2;},f:F};}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=it.call(o);},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e3){didErr=true;err=_e3;},f:function f(){try{if(!normalCompletion&&it.return!=null)it.return();}finally{if(didErr)throw err;}}};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}function _createClass(Constructor,protoProps,staticProps){if(protoProps)_defineProperties(Constructor.prototype,protoProps);if(staticProps)_defineProperties(Constructor,staticProps);return Constructor;}function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else{_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}function _slicedToArray(arr,i){return _arrayWithHoles(arr)||_iterableToArrayLimit(arr,i)||_unsupportedIterableToArray(arr,i)||_nonIterableRest();}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _iterableToArrayLimit(arr,i){var _i=arr&&(typeof Symbol!=="undefined"&&arr[Symbol.iterator]||arr["@@iterator"]);if(_i==null)return;var _arr=[];var _n=true;var _d=false;var _s,_e;try{for(_i=_i.call(arr);!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"]!=null)_i["return"]();}finally{if(_d)throw _e;}}return _arr;}function _arrayWithHoles(arr){if(Array.isArray(arr))return arr;}function _toConsumableArray(arr){return _arrayWithoutHoles(arr)||_iterableToArray(arr)||_unsupportedIterableToArray(arr)||_nonIterableSpread();}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o==="string")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n==="Object"&&o.constructor)n=o.constructor.name;if(n==="Map"||n==="Set")return Array.from(o);if(n==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _iterableToArray(iter){if(typeof Symbol!=="undefined"&&iter[Symbol.iterator]!=null||iter["@@iterator"]!=null)return Array.from(iter);}function _arrayWithoutHoles(arr){if(Array.isArray(arr))return _arrayLikeToArray(arr);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */function makeMap(str,expectsLowerCase){var map=Object.create(null);var list=str.split(',');for(var i=0;i<list.length;i++){map[list[i]]=true;}return expectsLowerCase?function(val){return!!map[val.toLowerCase()];}:function(val){return!!map[val];};}/**
 * dev only flag -> name mapping
 */var PatchFlagNames=(_PatchFlagNames={},_defineProperty(_PatchFlagNames,1/* TEXT */,"TEXT"),_defineProperty(_PatchFlagNames,2/* CLASS */,"CLASS"),_defineProperty(_PatchFlagNames,4/* STYLE */,"STYLE"),_defineProperty(_PatchFlagNames,8/* PROPS */,"PROPS"),_defineProperty(_PatchFlagNames,16/* FULL_PROPS */,"FULL_PROPS"),_defineProperty(_PatchFlagNames,32/* HYDRATE_EVENTS */,"HYDRATE_EVENTS"),_defineProperty(_PatchFlagNames,64/* STABLE_FRAGMENT */,"STABLE_FRAGMENT"),_defineProperty(_PatchFlagNames,128/* KEYED_FRAGMENT */,"KEYED_FRAGMENT"),_defineProperty(_PatchFlagNames,256/* UNKEYED_FRAGMENT */,"UNKEYED_FRAGMENT"),_defineProperty(_PatchFlagNames,512/* NEED_PATCH */,"NEED_PATCH"),_defineProperty(_PatchFlagNames,1024/* DYNAMIC_SLOTS */,"DYNAMIC_SLOTS"),_defineProperty(_PatchFlagNames,2048/* DEV_ROOT_FRAGMENT */,"DEV_ROOT_FRAGMENT"),_defineProperty(_PatchFlagNames,-1/* HOISTED */,"HOISTED"),_defineProperty(_PatchFlagNames,-2/* BAIL */,"BAIL"),_PatchFlagNames);/**
 * Dev only
 */var slotFlagsText=(_slotFlagsText={},_defineProperty(_slotFlagsText,1/* STABLE */,'STABLE'),_defineProperty(_slotFlagsText,2/* DYNAMIC */,'DYNAMIC'),_defineProperty(_slotFlagsText,3/* FORWARDED */,'FORWARDED'),_slotFlagsText);var GLOBALS_WHITE_LISTED='Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,'+'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,'+'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';var isGloballyWhitelisted=/*#__PURE__*/makeMap(GLOBALS_WHITE_LISTED);var range=2;function generateCodeFrame(source){var start=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var end=arguments.length>2&&arguments[2]!==undefined?arguments[2]:source.length;// Split the content into individual lines but capture the newline sequence
// that separated each line. This is important because the actual sequence is
// needed to properly take into account the full line length for offset
// comparison
var lines=source.split(/(\r?\n)/);// Separate the lines and newline sequences into separate arrays for easier referencing
var newlineSequences=lines.filter(function(_,idx){return idx%2===1;});lines=lines.filter(function(_,idx){return idx%2===0;});var count=0;var res=[];for(var i=0;i<lines.length;i++){count+=lines[i].length+(newlineSequences[i]&&newlineSequences[i].length||0);if(count>=start){for(var j=i-range;j<=i+range||end>count;j++){if(j<0||j>=lines.length)continue;var line=j+1;res.push("".concat(line).concat(' '.repeat(Math.max(3-String(line).length,0)),"|  ").concat(lines[j]));var lineLength=lines[j].length;var newLineSeqLength=newlineSequences[j]&&newlineSequences[j].length||0;if(j===i){// push underline
var pad=start-(count-(lineLength+newLineSeqLength));var length=Math.max(1,end>count?lineLength-pad:end-start);res.push("   |  "+' '.repeat(pad)+'^'.repeat(length));}else if(j>i){if(end>count){var _length=Math.max(Math.min(end-count,lineLength),1);res.push("   |  "+'^'.repeat(_length));}count+=lineLength+newLineSeqLength;}}break;}}return res.join('\n');}/**
 * On the client we only need to offer special cases for boolean attributes that
 * have different names from their corresponding dom properties:
 * - itemscope -> N/A
 * - allowfullscreen -> allowFullscreen
 * - formnovalidate -> formNoValidate
 * - ismap -> isMap
 * - nomodule -> noModule
 * - novalidate -> noValidate
 * - readonly -> readOnly
 */var specialBooleanAttrs="itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly";var isSpecialBooleanAttr=/*#__PURE__*/makeMap(specialBooleanAttrs);/**
 * Boolean attributes should be included if the value is truthy or ''.
 * e.g. `<select multiple>` compiles to `{ multiple: '' }`
 */function includeBooleanAttr(value){return!!value||value==='';}function normalizeStyle(value){if(isArray(value)){var res={};for(var i=0;i<value.length;i++){var item=value[i];var normalized=isString(item)?parseStringStyle(item):normalizeStyle(item);if(normalized){for(var key in normalized){res[key]=normalized[key];}}}return res;}else if(isString(value)){return value;}else if(isObject(value)){return value;}}var listDelimiterRE=/;(?![^(]*\))/g;var propertyDelimiterRE=/:(.+)/;function parseStringStyle(cssText){var ret={};cssText.split(listDelimiterRE).forEach(function(item){if(item){var tmp=item.split(propertyDelimiterRE);tmp.length>1&&(ret[tmp[0].trim()]=tmp[1].trim());}});return ret;}function normalizeClass(value){var res='';if(isString(value)){res=value;}else if(isArray(value)){for(var i=0;i<value.length;i++){var normalized=normalizeClass(value[i]);if(normalized){res+=normalized+' ';}}}else if(isObject(value)){for(var name in value){if(value[name]){res+=name+' ';}}}return res.trim();}function normalizeProps(props){if(!props)return null;var klass=props.class,style=props.style;if(klass&&!isString(klass)){props.class=normalizeClass(klass);}if(style){props.style=normalizeStyle(style);}return props;}// These tag configs are shared between compiler-dom and runtime-dom, so they
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element
var HTML_TAGS='html,body,base,head,link,meta,style,title,address,article,aside,footer,'+'header,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,'+'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,'+'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,'+'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,'+'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,'+'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,'+'option,output,progress,select,textarea,details,dialog,menu,'+'summary,template,blockquote,iframe,tfoot';// https://developer.mozilla.org/en-US/docs/Web/SVG/Element
var SVG_TAGS='svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,'+'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,'+'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,'+'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,'+'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,'+'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,'+'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,'+'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,'+'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,'+'text,textPath,title,tspan,unknown,use,view';var VOID_TAGS='area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `true` flag.
 */var isHTMLTag=/*#__PURE__*/makeMap(HTML_TAGS);/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `true` flag.
 */var isSVGTag=/*#__PURE__*/makeMap(SVG_TAGS);/**
 * Compiler only.
 * Do NOT use in runtime code paths unless behind `true` flag.
 */var isVoidTag=/*#__PURE__*/makeMap(VOID_TAGS);function looseCompareArrays(a,b){if(a.length!==b.length)return false;var equal=true;for(var i=0;equal&&i<a.length;i++){equal=looseEqual(a[i],b[i]);}return equal;}function looseEqual(a,b){if(a===b)return true;var aValidType=isDate(a);var bValidType=isDate(b);if(aValidType||bValidType){return aValidType&&bValidType?a.getTime()===b.getTime():false;}aValidType=isArray(a);bValidType=isArray(b);if(aValidType||bValidType){return aValidType&&bValidType?looseCompareArrays(a,b):false;}aValidType=isObject(a);bValidType=isObject(b);if(aValidType||bValidType){/* istanbul ignore if: this if will probably never be called */if(!aValidType||!bValidType){return false;}var aKeysCount=Object.keys(a).length;var bKeysCount=Object.keys(b).length;if(aKeysCount!==bKeysCount){return false;}for(var key in a){var aHasKey=a.hasOwnProperty(key);var bHasKey=b.hasOwnProperty(key);if(aHasKey&&!bHasKey||!aHasKey&&bHasKey||!looseEqual(a[key],b[key])){return false;}}}return String(a)===String(b);}function looseIndexOf(arr,val){return arr.findIndex(function(item){return looseEqual(item,val);});}/**
 * For converting {{ interpolation }} values to displayed strings.
 * @private
 */var toDisplayString=function toDisplayString(val){return isString(val)?val:val==null?'':isArray(val)||isObject(val)&&(val.toString===objectToString||!isFunction(val.toString))?JSON.stringify(val,replacer,2):String(val);};var replacer=function replacer(_key,val){// can't use isRef here since @vue/shared has no deps
if(val&&val.__v_isRef){return replacer(_key,val.value);}else if(isMap(val)){return _defineProperty({},"Map(".concat(val.size,")"),_toConsumableArray(val.entries()).reduce(function(entries,_ref){var _ref2=_slicedToArray(_ref,2),key=_ref2[0],val=_ref2[1];entries["".concat(key," =>")]=val;return entries;},{}));}else if(isSet(val)){return _defineProperty({},"Set(".concat(val.size,")"),_toConsumableArray(val.values()));}else if(isObject(val)&&!isArray(val)&&!isPlainObject(val)){return String(val);}return val;};var EMPTY_OBJ=Object.freeze({});var EMPTY_ARR=Object.freeze([]);var NOOP=function NOOP(){};/**
 * Always return false.
 */var NO=function NO(){return false;};var onRE=/^on[^a-z]/;var isOn=function isOn(key){return onRE.test(key);};var isModelListener=function isModelListener(key){return key.startsWith('onUpdate:');};var extend=Object.assign;var remove=function remove(arr,el){var i=arr.indexOf(el);if(i>-1){arr.splice(i,1);}};var hasOwnProperty=Object.prototype.hasOwnProperty;var hasOwn=function hasOwn(val,key){return hasOwnProperty.call(val,key);};var isArray=Array.isArray;var isMap=function isMap(val){return toTypeString(val)==='[object Map]';};var isSet=function isSet(val){return toTypeString(val)==='[object Set]';};var isDate=function isDate(val){return val instanceof Date;};var isFunction=function isFunction(val){return typeof val==='function';};var isString=function isString(val){return typeof val==='string';};var isSymbol=function isSymbol(val){return _typeof(val)==='symbol';};var isObject=function isObject(val){return val!==null&&_typeof(val)==='object';};var isPromise=function isPromise(val){return isObject(val)&&isFunction(val.then)&&isFunction(val.catch);};var objectToString=Object.prototype.toString;var toTypeString=function toTypeString(value){return objectToString.call(value);};var toRawType=function toRawType(value){// extract "RawType" from strings like "[object RawType]"
return toTypeString(value).slice(8,-1);};var isPlainObject=function isPlainObject(val){return toTypeString(val)==='[object Object]';};var isIntegerKey=function isIntegerKey(key){return isString(key)&&key!=='NaN'&&key[0]!=='-'&&''+parseInt(key,10)===key;};var isReservedProp=/*#__PURE__*/makeMap(// the leading comma is intentional so empty string "" is also included
',key,ref,ref_for,ref_key,'+'onVnodeBeforeMount,onVnodeMounted,'+'onVnodeBeforeUpdate,onVnodeUpdated,'+'onVnodeBeforeUnmount,onVnodeUnmounted');var isBuiltInDirective=/*#__PURE__*/makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');var cacheStringFunction=function cacheStringFunction(fn){var cache=Object.create(null);return function(str){var hit=cache[str];return hit||(cache[str]=fn(str));};};var camelizeRE=/-(\w)/g;/**
 * @private
 */var camelize=cacheStringFunction(function(str){return str.replace(camelizeRE,function(_,c){return c?c.toUpperCase():'';});});var hyphenateRE=/\B([A-Z])/g;/**
 * @private
 */var hyphenate=cacheStringFunction(function(str){return str.replace(hyphenateRE,'-$1').toLowerCase();});/**
 * @private
 */var capitalize=cacheStringFunction(function(str){return str.charAt(0).toUpperCase()+str.slice(1);});/**
 * @private
 */var toHandlerKey=cacheStringFunction(function(str){return str?"on".concat(capitalize(str)):"";});// compare whether a value has changed, accounting for NaN.
var hasChanged=function hasChanged(value,oldValue){return!Object.is(value,oldValue);};var invokeArrayFns=function invokeArrayFns(fns,arg){for(var i=0;i<fns.length;i++){fns[i](arg);}};var def=function def(obj,key,value){Object.defineProperty(obj,key,{configurable:true,enumerable:false,value:value});};var toNumber=function toNumber(val){var n=parseFloat(val);return isNaN(n)?val:n;};var _globalThis;var getGlobalThis=function getGlobalThis(){return _globalThis||(_globalThis=typeof globalThis!=='undefined'?globalThis:typeof self!=='undefined'?self:typeof window!=='undefined'?window:typeof __webpack_require__.g!=='undefined'?__webpack_require__.g:{});};function warn(msg){var _console;for(var _len=arguments.length,args=new Array(_len>1?_len-1:0),_key2=1;_key2<_len;_key2++){args[_key2-1]=arguments[_key2];}(_console=console).warn.apply(_console,["[Vue warn] ".concat(msg)].concat(args));}var activeEffectScope;var EffectScope=/*#__PURE__*/function(){function EffectScope(){var detached=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;_classCallCheck(this,EffectScope);this.active=true;this.effects=[];this.cleanups=[];if(!detached&&activeEffectScope){this.parent=activeEffectScope;this.index=(activeEffectScope.scopes||(activeEffectScope.scopes=[])).push(this)-1;}}_createClass(EffectScope,[{key:"run",value:function run(fn){if(this.active){try{activeEffectScope=this;return fn();}finally{activeEffectScope=this.parent;}}else{warn("cannot run an inactive effect scope.");}}},{key:"on",value:function on(){activeEffectScope=this;}},{key:"off",value:function off(){activeEffectScope=this.parent;}},{key:"stop",value:function stop(fromParent){if(this.active){var i,l;for(i=0,l=this.effects.length;i<l;i++){this.effects[i].stop();}for(i=0,l=this.cleanups.length;i<l;i++){this.cleanups[i]();}if(this.scopes){for(i=0,l=this.scopes.length;i<l;i++){this.scopes[i].stop(true);}}// nested scope, dereference from parent to avoid memory leaks
if(this.parent&&!fromParent){// optimized O(1) removal
var _last=this.parent.scopes.pop();if(_last&&_last!==this){this.parent.scopes[this.index]=_last;_last.index=this.index;}}this.active=false;}}}]);return EffectScope;}();function effectScope(detached){return new EffectScope(detached);}function recordEffectScope(effect){var scope=arguments.length>1&&arguments[1]!==undefined?arguments[1]:activeEffectScope;if(scope&&scope.active){scope.effects.push(effect);}}function getCurrentScope(){return activeEffectScope;}function onScopeDispose(fn){if(activeEffectScope){activeEffectScope.cleanups.push(fn);}else{warn("onScopeDispose() is called when there is no active effect scope"+" to be associated with.");}}var createDep=function createDep(effects){var dep=new Set(effects);dep.w=0;dep.n=0;return dep;};var wasTracked=function wasTracked(dep){return(dep.w&trackOpBit)>0;};var newTracked=function newTracked(dep){return(dep.n&trackOpBit)>0;};var initDepMarkers=function initDepMarkers(_ref5){var deps=_ref5.deps;if(deps.length){for(var i=0;i<deps.length;i++){deps[i].w|=trackOpBit;// set was tracked
}}};var finalizeDepMarkers=function finalizeDepMarkers(effect){var deps=effect.deps;if(deps.length){var ptr=0;for(var i=0;i<deps.length;i++){var dep=deps[i];if(wasTracked(dep)&&!newTracked(dep)){dep.delete(effect);}else{deps[ptr++]=dep;}// clear bits
dep.w&=~trackOpBit;dep.n&=~trackOpBit;}deps.length=ptr;}};var targetMap=new WeakMap();// The number of effects currently being tracked recursively.
var effectTrackDepth=0;var trackOpBit=1;/**
 * The bitwise track markers support at most 30 levels of recursion.
 * This value is chosen to enable modern JS engines to use a SMI on all platforms.
 * When recursion depth is greater, fall back to using a full cleanup.
 */var maxMarkerBits=30;var activeEffect;var ITERATE_KEY=Symbol('iterate');var MAP_KEY_ITERATE_KEY=Symbol('Map key iterate');var ReactiveEffect=/*#__PURE__*/function(){function ReactiveEffect(fn){var scheduler=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var scope=arguments.length>2?arguments[2]:undefined;_classCallCheck(this,ReactiveEffect);this.fn=fn;this.scheduler=scheduler;this.active=true;this.deps=[];this.parent=undefined;recordEffectScope(this,scope);}_createClass(ReactiveEffect,[{key:"run",value:function run(){if(!this.active){return this.fn();}var parent=activeEffect;var lastShouldTrack=shouldTrack;while(parent){if(parent===this){return;}parent=parent.parent;}try{this.parent=activeEffect;activeEffect=this;shouldTrack=true;trackOpBit=1<<++effectTrackDepth;if(effectTrackDepth<=maxMarkerBits){initDepMarkers(this);}else{cleanupEffect(this);}return this.fn();}finally{if(effectTrackDepth<=maxMarkerBits){finalizeDepMarkers(this);}trackOpBit=1<<--effectTrackDepth;activeEffect=this.parent;shouldTrack=lastShouldTrack;this.parent=undefined;}}},{key:"stop",value:function stop(){if(this.active){cleanupEffect(this);if(this.onStop){this.onStop();}this.active=false;}}}]);return ReactiveEffect;}();function cleanupEffect(effect){var deps=effect.deps;if(deps.length){for(var i=0;i<deps.length;i++){deps[i].delete(effect);}deps.length=0;}}function effect(fn,options){if(fn.effect){fn=fn.effect.fn;}var _effect=new ReactiveEffect(fn);if(options){extend(_effect,options);if(options.scope)recordEffectScope(_effect,options.scope);}if(!options||!options.lazy){_effect.run();}var runner=_effect.run.bind(_effect);runner.effect=_effect;return runner;}function stop(runner){runner.effect.stop();}var shouldTrack=true;var trackStack=[];function pauseTracking(){trackStack.push(shouldTrack);shouldTrack=false;}function resetTracking(){var last=trackStack.pop();shouldTrack=last===undefined?true:last;}function track(target,type,key){if(shouldTrack&&activeEffect){var depsMap=targetMap.get(target);if(!depsMap){targetMap.set(target,depsMap=new Map());}var dep=depsMap.get(key);if(!dep){depsMap.set(key,dep=createDep());}var eventInfo={effect:activeEffect,target:target,type:type,key:key};trackEffects(dep,eventInfo);}}function trackEffects(dep,debuggerEventExtraInfo){var shouldTrack=false;if(effectTrackDepth<=maxMarkerBits){if(!newTracked(dep)){dep.n|=trackOpBit;// set newly tracked
shouldTrack=!wasTracked(dep);}}else{// Full cleanup mode.
shouldTrack=!dep.has(activeEffect);}if(shouldTrack){dep.add(activeEffect);activeEffect.deps.push(dep);if(activeEffect.onTrack){activeEffect.onTrack(Object.assign({effect:activeEffect},debuggerEventExtraInfo));}}}function trigger(target,type,key,newValue,oldValue,oldTarget){var depsMap=targetMap.get(target);if(!depsMap){// never been tracked
return;}var deps=[];if(type==="clear"/* CLEAR */){// collection being cleared
// trigger all effects for target
deps=_toConsumableArray(depsMap.values());}else if(key==='length'&&isArray(target)){depsMap.forEach(function(dep,key){if(key==='length'||key>=newValue){deps.push(dep);}});}else{// schedule runs for SET | ADD | DELETE
if(key!==void 0){deps.push(depsMap.get(key));}// also run for iteration key on ADD | DELETE | Map.SET
switch(type){case"add"/* ADD */:if(!isArray(target)){deps.push(depsMap.get(ITERATE_KEY));if(isMap(target)){deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));}}else if(isIntegerKey(key)){// new index added to array -> length changes
deps.push(depsMap.get('length'));}break;case"delete"/* DELETE */:if(!isArray(target)){deps.push(depsMap.get(ITERATE_KEY));if(isMap(target)){deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));}}break;case"set"/* SET */:if(isMap(target)){deps.push(depsMap.get(ITERATE_KEY));}break;}}var eventInfo={target:target,type:type,key:key,newValue:newValue,oldValue:oldValue,oldTarget:oldTarget};if(deps.length===1){if(deps[0]){{triggerEffects(deps[0],eventInfo);}}}else{var effects=[];var _iterator=_createForOfIteratorHelper(deps),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var dep=_step.value;if(dep){effects.push.apply(effects,_toConsumableArray(dep));}}}catch(err){_iterator.e(err);}finally{_iterator.f();}{triggerEffects(createDep(effects),eventInfo);}}}function triggerEffects(dep,debuggerEventExtraInfo){// spread into array for stabilization
var _iterator2=_createForOfIteratorHelper(isArray(dep)?dep:_toConsumableArray(dep)),_step2;try{for(_iterator2.s();!(_step2=_iterator2.n()).done;){var _effect2=_step2.value;if(_effect2!==activeEffect||_effect2.allowRecurse){if(_effect2.onTrigger){_effect2.onTrigger(extend({effect:_effect2},debuggerEventExtraInfo));}if(_effect2.scheduler){_effect2.scheduler();}else{_effect2.run();}}}}catch(err){_iterator2.e(err);}finally{_iterator2.f();}}var isNonTrackableKeys=/*#__PURE__*/makeMap("__proto__,__v_isRef,__isVue");var builtInSymbols=new Set(Object.getOwnPropertyNames(Symbol).map(function(key){return Symbol[key];}).filter(isSymbol));var get=/*#__PURE__*/createGetter();var shallowGet=/*#__PURE__*/createGetter(false,true);var readonlyGet=/*#__PURE__*/createGetter(true);var shallowReadonlyGet=/*#__PURE__*/createGetter(true,true);var arrayInstrumentations=/*#__PURE__*/createArrayInstrumentations();function createArrayInstrumentations(){var instrumentations={};['includes','indexOf','lastIndexOf'].forEach(function(key){instrumentations[key]=function(){var arr=toRaw(this);for(var i=0,l=this.length;i<l;i++){track(arr,"get"/* GET */,i+'');}// we run the method using the original args first (which may be reactive)
for(var _len2=arguments.length,args=new Array(_len2),_key3=0;_key3<_len2;_key3++){args[_key3]=arguments[_key3];}var res=arr[key].apply(arr,args);if(res===-1||res===false){// if that didn't work, run it again using raw values.
return arr[key].apply(arr,_toConsumableArray(args.map(toRaw)));}else{return res;}};});['push','pop','shift','unshift','splice'].forEach(function(key){instrumentations[key]=function(){pauseTracking();for(var _len3=arguments.length,args=new Array(_len3),_key4=0;_key4<_len3;_key4++){args[_key4]=arguments[_key4];}var res=toRaw(this)[key].apply(this,args);resetTracking();return res;};});return instrumentations;}function createGetter(){var isReadonly=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;var shallow=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return function get(target,key,receiver){if(key==="__v_isReactive"/* IS_REACTIVE */){return!isReadonly;}else if(key==="__v_isReadonly"/* IS_READONLY */){return isReadonly;}else if(key==="__v_isShallow"/* IS_SHALLOW */){return shallow;}else if(key==="__v_raw"/* RAW */&&receiver===(isReadonly?shallow?shallowReadonlyMap:readonlyMap:shallow?shallowReactiveMap:reactiveMap).get(target)){return target;}var targetIsArray=isArray(target);if(!isReadonly&&targetIsArray&&hasOwn(arrayInstrumentations,key)){return Reflect.get(arrayInstrumentations,key,receiver);}var res=Reflect.get(target,key,receiver);if(isSymbol(key)?builtInSymbols.has(key):isNonTrackableKeys(key)){return res;}if(!isReadonly){track(target,"get"/* GET */,key);}if(shallow){return res;}if(isRef(res)){// ref unwrapping - does not apply for Array + integer key.
var shouldUnwrap=!targetIsArray||!isIntegerKey(key);return shouldUnwrap?res.value:res;}if(isObject(res)){// Convert returned value into a proxy as well. we do the isObject check
// here to avoid invalid value warning. Also need to lazy access readonly
// and reactive here to avoid circular dependency.
return isReadonly?readonly(res):reactive(res);}return res;};}var set=/*#__PURE__*/createSetter();var shallowSet=/*#__PURE__*/createSetter(true);function createSetter(){var shallow=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;return function set(target,key,value,receiver){var oldValue=target[key];if(isReadonly(oldValue)&&isRef(oldValue)&&!isRef(value)){return false;}if(!shallow&&!isReadonly(value)){if(!isShallow(value)){value=toRaw(value);oldValue=toRaw(oldValue);}if(!isArray(target)&&isRef(oldValue)&&!isRef(value)){oldValue.value=value;return true;}}var hadKey=isArray(target)&&isIntegerKey(key)?Number(key)<target.length:hasOwn(target,key);var result=Reflect.set(target,key,value,receiver);// don't trigger if target is something up in the prototype chain of original
if(target===toRaw(receiver)){if(!hadKey){trigger(target,"add"/* ADD */,key,value);}else if(hasChanged(value,oldValue)){trigger(target,"set"/* SET */,key,value,oldValue);}}return result;};}function deleteProperty(target,key){var hadKey=hasOwn(target,key);var oldValue=target[key];var result=Reflect.deleteProperty(target,key);if(result&&hadKey){trigger(target,"delete"/* DELETE */,key,undefined,oldValue);}return result;}function has(target,key){var result=Reflect.has(target,key);if(!isSymbol(key)||!builtInSymbols.has(key)){track(target,"has"/* HAS */,key);}return result;}function ownKeys(target){track(target,"iterate"/* ITERATE */,isArray(target)?'length':ITERATE_KEY);return Reflect.ownKeys(target);}var mutableHandlers={get:get,set:set,deleteProperty:deleteProperty,has:has,ownKeys:ownKeys};var readonlyHandlers={get:readonlyGet,set:function set(target,key){{console.warn("Set operation on key \"".concat(String(key),"\" failed: target is readonly."),target);}return true;},deleteProperty:function deleteProperty(target,key){{console.warn("Delete operation on key \"".concat(String(key),"\" failed: target is readonly."),target);}return true;}};var shallowReactiveHandlers=/*#__PURE__*/extend({},mutableHandlers,{get:shallowGet,set:shallowSet});// Props handlers are special in the sense that it should not unwrap top-level
// refs (in order to allow refs to be explicitly passed down), but should
// retain the reactivity of the normal readonly object.
var shallowReadonlyHandlers=/*#__PURE__*/extend({},readonlyHandlers,{get:shallowReadonlyGet});var toShallow=function toShallow(value){return value;};var getProto=function getProto(v){return Reflect.getPrototypeOf(v);};function get$1(target,key){var isReadonly=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var isShallow=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;// #1772: readonly(reactive(Map)) should return readonly + reactive version
// of the value
target=target["__v_raw"/* RAW */];var rawTarget=toRaw(target);var rawKey=toRaw(key);if(key!==rawKey){!isReadonly&&track(rawTarget,"get"/* GET */,key);}!isReadonly&&track(rawTarget,"get"/* GET */,rawKey);var _getProto=getProto(rawTarget),has=_getProto.has;var wrap=isShallow?toShallow:isReadonly?toReadonly:toReactive;if(has.call(rawTarget,key)){return wrap(target.get(key));}else if(has.call(rawTarget,rawKey)){return wrap(target.get(rawKey));}else if(target!==rawTarget){// #3602 readonly(reactive(Map))
// ensure that the nested reactive `Map` can do tracking for itself
target.get(key);}}function has$1(key){var isReadonly=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var target=this["__v_raw"/* RAW */];var rawTarget=toRaw(target);var rawKey=toRaw(key);if(key!==rawKey){!isReadonly&&track(rawTarget,"has"/* HAS */,key);}!isReadonly&&track(rawTarget,"has"/* HAS */,rawKey);return key===rawKey?target.has(key):target.has(key)||target.has(rawKey);}function size(target){var isReadonly=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;target=target["__v_raw"/* RAW */];!isReadonly&&track(toRaw(target),"iterate"/* ITERATE */,ITERATE_KEY);return Reflect.get(target,'size',target);}function add(value){value=toRaw(value);var target=toRaw(this);var proto=getProto(target);var hadKey=proto.has.call(target,value);if(!hadKey){target.add(value);trigger(target,"add"/* ADD */,value,value);}return this;}function set$1(key,value){value=toRaw(value);var target=toRaw(this);var _getProto2=getProto(target),has=_getProto2.has,get=_getProto2.get;var hadKey=has.call(target,key);if(!hadKey){key=toRaw(key);hadKey=has.call(target,key);}else{checkIdentityKeys(target,has,key);}var oldValue=get.call(target,key);target.set(key,value);if(!hadKey){trigger(target,"add"/* ADD */,key,value);}else if(hasChanged(value,oldValue)){trigger(target,"set"/* SET */,key,value,oldValue);}return this;}function deleteEntry(key){var target=toRaw(this);var _getProto3=getProto(target),has=_getProto3.has,get=_getProto3.get;var hadKey=has.call(target,key);if(!hadKey){key=toRaw(key);hadKey=has.call(target,key);}else{checkIdentityKeys(target,has,key);}var oldValue=get?get.call(target,key):undefined;// forward the operation before queueing reactions
var result=target.delete(key);if(hadKey){trigger(target,"delete"/* DELETE */,key,undefined,oldValue);}return result;}function clear(){var target=toRaw(this);var hadItems=target.size!==0;var oldTarget=isMap(target)?new Map(target):new Set(target);// forward the operation before queueing reactions
var result=target.clear();if(hadItems){trigger(target,"clear"/* CLEAR */,undefined,undefined,oldTarget);}return result;}function createForEach(isReadonly,isShallow){return function forEach(callback,thisArg){var observed=this;var target=observed["__v_raw"/* RAW */];var rawTarget=toRaw(target);var wrap=isShallow?toShallow:isReadonly?toReadonly:toReactive;!isReadonly&&track(rawTarget,"iterate"/* ITERATE */,ITERATE_KEY);return target.forEach(function(value,key){// important: make sure the callback is
// 1. invoked with the reactive map as `this` and 3rd arg
// 2. the value received should be a corresponding reactive/readonly.
return callback.call(thisArg,wrap(value),wrap(key),observed);});};}function createIterableMethod(method,isReadonly,isShallow){return function(){var target=this["__v_raw"/* RAW */];var rawTarget=toRaw(target);var targetIsMap=isMap(rawTarget);var isPair=method==='entries'||method===Symbol.iterator&&targetIsMap;var isKeyOnly=method==='keys'&&targetIsMap;var innerIterator=target[method].apply(target,arguments);var wrap=isShallow?toShallow:isReadonly?toReadonly:toReactive;!isReadonly&&track(rawTarget,"iterate"/* ITERATE */,isKeyOnly?MAP_KEY_ITERATE_KEY:ITERATE_KEY);// return a wrapped iterator which returns observed versions of the
// values emitted from the real iterator
return _defineProperty({// iterator protocol
next:function next(){var _innerIterator$next=innerIterator.next(),value=_innerIterator$next.value,done=_innerIterator$next.done;return done?{value:value,done:done}:{value:isPair?[wrap(value[0]),wrap(value[1])]:wrap(value),done:done};}},Symbol.iterator,function(){return this;});};}function createReadonlyMethod(type){return function(){{var key=(arguments.length<=0?undefined:arguments[0])?"on key \"".concat(arguments.length<=0?undefined:arguments[0],"\" "):"";console.warn("".concat(capitalize(type)," operation ").concat(key,"failed: target is readonly."),toRaw(this));}return type==="delete"/* DELETE */?false:this;};}function createInstrumentations(){var mutableInstrumentations={get:function get(key){return get$1(this,key);},get size(){return size(this);},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(false,false)};var shallowInstrumentations={get:function get(key){return get$1(this,key,false,true);},get size(){return size(this);},has:has$1,add:add,set:set$1,delete:deleteEntry,clear:clear,forEach:createForEach(false,true)};var readonlyInstrumentations={get:function get(key){return get$1(this,key,true);},get size(){return size(this,true);},has:function has(key){return has$1.call(this,key,true);},add:createReadonlyMethod("add"/* ADD */),set:createReadonlyMethod("set"/* SET */),delete:createReadonlyMethod("delete"/* DELETE */),clear:createReadonlyMethod("clear"/* CLEAR */),forEach:createForEach(true,false)};var shallowReadonlyInstrumentations={get:function get(key){return get$1(this,key,true,true);},get size(){return size(this,true);},has:function has(key){return has$1.call(this,key,true);},add:createReadonlyMethod("add"/* ADD */),set:createReadonlyMethod("set"/* SET */),delete:createReadonlyMethod("delete"/* DELETE */),clear:createReadonlyMethod("clear"/* CLEAR */),forEach:createForEach(true,true)};var iteratorMethods=['keys','values','entries',Symbol.iterator];iteratorMethods.forEach(function(method){mutableInstrumentations[method]=createIterableMethod(method,false,false);readonlyInstrumentations[method]=createIterableMethod(method,true,false);shallowInstrumentations[method]=createIterableMethod(method,false,true);shallowReadonlyInstrumentations[method]=createIterableMethod(method,true,true);});return[mutableInstrumentations,readonlyInstrumentations,shallowInstrumentations,shallowReadonlyInstrumentations];}var _createInstrumentatio=/* #__PURE__*/createInstrumentations(),_createInstrumentatio2=_slicedToArray(_createInstrumentatio,4),mutableInstrumentations=_createInstrumentatio2[0],readonlyInstrumentations=_createInstrumentatio2[1],shallowInstrumentations=_createInstrumentatio2[2],shallowReadonlyInstrumentations=_createInstrumentatio2[3];function createInstrumentationGetter(isReadonly,shallow){var instrumentations=shallow?isReadonly?shallowReadonlyInstrumentations:shallowInstrumentations:isReadonly?readonlyInstrumentations:mutableInstrumentations;return function(target,key,receiver){if(key==="__v_isReactive"/* IS_REACTIVE */){return!isReadonly;}else if(key==="__v_isReadonly"/* IS_READONLY */){return isReadonly;}else if(key==="__v_raw"/* RAW */){return target;}return Reflect.get(hasOwn(instrumentations,key)&&key in target?instrumentations:target,key,receiver);};}var mutableCollectionHandlers={get:/*#__PURE__*/createInstrumentationGetter(false,false)};var shallowCollectionHandlers={get:/*#__PURE__*/createInstrumentationGetter(false,true)};var readonlyCollectionHandlers={get:/*#__PURE__*/createInstrumentationGetter(true,false)};var shallowReadonlyCollectionHandlers={get:/*#__PURE__*/createInstrumentationGetter(true,true)};function checkIdentityKeys(target,has,key){var rawKey=toRaw(key);if(rawKey!==key&&has.call(target,rawKey)){var type=toRawType(target);console.warn("Reactive ".concat(type," contains both the raw and reactive ")+"versions of the same object".concat(type==="Map"?" as keys":"",", ")+"which can lead to inconsistencies. "+"Avoid differentiating between the raw and reactive versions "+"of an object and only use the reactive version if possible.");}}var reactiveMap=new WeakMap();var shallowReactiveMap=new WeakMap();var readonlyMap=new WeakMap();var shallowReadonlyMap=new WeakMap();function targetTypeMap(rawType){switch(rawType){case'Object':case'Array':return 1/* COMMON */;case'Map':case'Set':case'WeakMap':case'WeakSet':return 2/* COLLECTION */;default:return 0/* INVALID */;}}function getTargetType(value){return value["__v_skip"/* SKIP */]||!Object.isExtensible(value)?0/* INVALID */:targetTypeMap(toRawType(value));}function reactive(target){// if trying to observe a readonly proxy, return the readonly version.
if(isReadonly(target)){return target;}return createReactiveObject(target,false,mutableHandlers,mutableCollectionHandlers,reactiveMap);}/**
 * Return a shallowly-reactive copy of the original object, where only the root
 * level properties are reactive. It also does not auto-unwrap refs (even at the
 * root level).
 */function shallowReactive(target){return createReactiveObject(target,false,shallowReactiveHandlers,shallowCollectionHandlers,shallowReactiveMap);}/**
 * Creates a readonly copy of the original object. Note the returned copy is not
 * made reactive, but `readonly` can be called on an already reactive object.
 */function readonly(target){return createReactiveObject(target,true,readonlyHandlers,readonlyCollectionHandlers,readonlyMap);}/**
 * Returns a reactive-copy of the original object, where only the root level
 * properties are readonly, and does NOT unwrap refs nor recursively convert
 * returned properties.
 * This is used for creating the props proxy object for stateful components.
 */function shallowReadonly(target){return createReactiveObject(target,true,shallowReadonlyHandlers,shallowReadonlyCollectionHandlers,shallowReadonlyMap);}function createReactiveObject(target,isReadonly,baseHandlers,collectionHandlers,proxyMap){if(!isObject(target)){{console.warn("value cannot be made reactive: ".concat(String(target)));}return target;}// target is already a Proxy, return it.
// exception: calling readonly() on a reactive object
if(target["__v_raw"/* RAW */]&&!(isReadonly&&target["__v_isReactive"/* IS_REACTIVE */])){return target;}// target already has corresponding Proxy
var existingProxy=proxyMap.get(target);if(existingProxy){return existingProxy;}// only a whitelist of value types can be observed.
var targetType=getTargetType(target);if(targetType===0/* INVALID */){return target;}var proxy=new Proxy(target,targetType===2/* COLLECTION */?collectionHandlers:baseHandlers);proxyMap.set(target,proxy);return proxy;}function isReactive(value){if(isReadonly(value)){return isReactive(value["__v_raw"/* RAW */]);}return!!(value&&value["__v_isReactive"/* IS_REACTIVE */]);}function isReadonly(value){return!!(value&&value["__v_isReadonly"/* IS_READONLY */]);}function isShallow(value){return!!(value&&value["__v_isShallow"/* IS_SHALLOW */]);}function isProxy(value){return isReactive(value)||isReadonly(value);}function toRaw(observed){var raw=observed&&observed["__v_raw"/* RAW */];return raw?toRaw(raw):observed;}function markRaw(value){def(value,"__v_skip"/* SKIP */,true);return value;}var toReactive=function toReactive(value){return isObject(value)?reactive(value):value;};var toReadonly=function toReadonly(value){return isObject(value)?readonly(value):value;};function trackRefValue(ref){if(shouldTrack&&activeEffect){ref=toRaw(ref);{trackEffects(ref.dep||(ref.dep=createDep()),{target:ref,type:"get"/* GET */,key:'value'});}}}function triggerRefValue(ref,newVal){ref=toRaw(ref);if(ref.dep){{triggerEffects(ref.dep,{target:ref,type:"set"/* SET */,key:'value',newValue:newVal});}}}function isRef(r){return!!(r&&r.__v_isRef===true);}function ref(value){return createRef(value,false);}function shallowRef(value){return createRef(value,true);}function createRef(rawValue,shallow){if(isRef(rawValue)){return rawValue;}return new RefImpl(rawValue,shallow);}var RefImpl=/*#__PURE__*/function(){function RefImpl(value,__v_isShallow){_classCallCheck(this,RefImpl);this.__v_isShallow=__v_isShallow;this.dep=undefined;this.__v_isRef=true;this._rawValue=__v_isShallow?value:toRaw(value);this._value=__v_isShallow?value:toReactive(value);}_createClass(RefImpl,[{key:"value",get:function get(){trackRefValue(this);return this._value;},set:function set(newVal){newVal=this.__v_isShallow?newVal:toRaw(newVal);if(hasChanged(newVal,this._rawValue)){this._rawValue=newVal;this._value=this.__v_isShallow?newVal:toReactive(newVal);triggerRefValue(this,newVal);}}}]);return RefImpl;}();function triggerRef(ref){triggerRefValue(ref,ref.value);}function unref(ref){return isRef(ref)?ref.value:ref;}var shallowUnwrapHandlers={get:function get(target,key,receiver){return unref(Reflect.get(target,key,receiver));},set:function set(target,key,value,receiver){var oldValue=target[key];if(isRef(oldValue)&&!isRef(value)){oldValue.value=value;return true;}else{return Reflect.set(target,key,value,receiver);}}};function proxyRefs(objectWithRefs){return isReactive(objectWithRefs)?objectWithRefs:new Proxy(objectWithRefs,shallowUnwrapHandlers);}var CustomRefImpl=/*#__PURE__*/function(){function CustomRefImpl(factory){var _this=this;_classCallCheck(this,CustomRefImpl);this.dep=undefined;this.__v_isRef=true;var _factory=factory(function(){return trackRefValue(_this);},function(){return triggerRefValue(_this);}),get=_factory.get,set=_factory.set;this._get=get;this._set=set;}_createClass(CustomRefImpl,[{key:"value",get:function get(){return this._get();},set:function set(newVal){this._set(newVal);}}]);return CustomRefImpl;}();function customRef(factory){return new CustomRefImpl(factory);}function toRefs(object){if(!isProxy(object)){console.warn("toRefs() expects a reactive object but received a plain one.");}var ret=isArray(object)?new Array(object.length):{};for(var key in object){ret[key]=toRef(object,key);}return ret;}var ObjectRefImpl=/*#__PURE__*/function(){function ObjectRefImpl(_object,_key,_defaultValue){_classCallCheck(this,ObjectRefImpl);this._object=_object;this._key=_key;this._defaultValue=_defaultValue;this.__v_isRef=true;}_createClass(ObjectRefImpl,[{key:"value",get:function get(){var val=this._object[this._key];return val===undefined?this._defaultValue:val;},set:function set(newVal){this._object[this._key]=newVal;}}]);return ObjectRefImpl;}();function toRef(object,key,defaultValue){var val=object[key];return isRef(val)?val:new ObjectRefImpl(object,key,defaultValue);}var ComputedRefImpl=/*#__PURE__*/function(){function ComputedRefImpl(getter,_setter,isReadonly,isSSR){var _this2=this;_classCallCheck(this,ComputedRefImpl);this._setter=_setter;this.dep=undefined;this.__v_isRef=true;this._dirty=true;this.effect=new ReactiveEffect(getter,function(){if(!_this2._dirty){_this2._dirty=true;triggerRefValue(_this2);}});this.effect.computed=this;this.effect.active=this._cacheable=!isSSR;this["__v_isReadonly"/* IS_READONLY */]=isReadonly;}_createClass(ComputedRefImpl,[{key:"value",get:function get(){// the computed ref may get wrapped by other proxies e.g. readonly() #3376
var self=toRaw(this);trackRefValue(self);if(self._dirty||!self._cacheable){self._dirty=false;self._value=self.effect.run();}return self._value;},set:function set(newValue){this._setter(newValue);}}]);return ComputedRefImpl;}();function computed(getterOrOptions,debugOptions){var isSSR=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var getter;var setter;var onlyGetter=isFunction(getterOrOptions);if(onlyGetter){getter=getterOrOptions;setter=function setter(){console.warn('Write operation failed: computed value is readonly');};}else{getter=getterOrOptions.get;setter=getterOrOptions.set;}var cRef=new ComputedRefImpl(getter,setter,onlyGetter||!setter,isSSR);if(debugOptions&&!isSSR){cRef.effect.onTrack=debugOptions.onTrack;cRef.effect.onTrigger=debugOptions.onTrigger;}return cRef;}var stack=[];function pushWarningContext(vnode){stack.push(vnode);}function popWarningContext(){stack.pop();}function warn$1(msg){// avoid props formatting or warn handler tracking deps that might be mutated
// during patch, leading to infinite recursion.
pauseTracking();var instance=stack.length?stack[stack.length-1].component:null;var appWarnHandler=instance&&instance.appContext.config.warnHandler;var trace=getComponentTrace();for(var _len4=arguments.length,args=new Array(_len4>1?_len4-1:0),_key5=1;_key5<_len4;_key5++){args[_key5-1]=arguments[_key5];}if(appWarnHandler){callWithErrorHandling(appWarnHandler,instance,11/* APP_WARN_HANDLER */,[msg+args.join(''),instance&&instance.proxy,trace.map(function(_ref7){var vnode=_ref7.vnode;return"at <".concat(formatComponentName(instance,vnode.type),">");}).join('\n'),trace]);}else{var _console2;var warnArgs=["[Vue warn]: ".concat(msg)].concat(args);/* istanbul ignore if */if(trace.length&&// avoid spamming console during tests
!false){warnArgs.push.apply(warnArgs,["\n"].concat(_toConsumableArray(formatTrace(trace))));}(_console2=console).warn.apply(_console2,_toConsumableArray(warnArgs));}resetTracking();}function getComponentTrace(){var currentVNode=stack[stack.length-1];if(!currentVNode){return[];}// we can't just use the stack because it will be incomplete during updates
// that did not start from the root. Re-construct the parent chain using
// instance parent pointers.
var normalizedStack=[];while(currentVNode){var _last2=normalizedStack[0];if(_last2&&_last2.vnode===currentVNode){_last2.recurseCount++;}else{normalizedStack.push({vnode:currentVNode,recurseCount:0});}var parentInstance=currentVNode.component&&currentVNode.component.parent;currentVNode=parentInstance&&parentInstance.vnode;}return normalizedStack;}/* istanbul ignore next */function formatTrace(trace){var logs=[];trace.forEach(function(entry,i){logs.push.apply(logs,_toConsumableArray(i===0?[]:["\n"]).concat(_toConsumableArray(formatTraceEntry(entry))));});return logs;}function formatTraceEntry(_ref8){var vnode=_ref8.vnode,recurseCount=_ref8.recurseCount;var postfix=recurseCount>0?"... (".concat(recurseCount," recursive calls)"):"";var isRoot=vnode.component?vnode.component.parent==null:false;var open=" at <".concat(formatComponentName(vnode.component,vnode.type,isRoot));var close=">"+postfix;return vnode.props?[open].concat(_toConsumableArray(formatProps(vnode.props)),[close]):[open+close];}/* istanbul ignore next */function formatProps(props){var res=[];var keys=Object.keys(props);keys.slice(0,3).forEach(function(key){res.push.apply(res,_toConsumableArray(formatProp(key,props[key])));});if(keys.length>3){res.push(" ...");}return res;}/* istanbul ignore next */function formatProp(key,value,raw){if(isString(value)){value=JSON.stringify(value);return raw?value:["".concat(key,"=").concat(value)];}else if(typeof value==='number'||typeof value==='boolean'||value==null){return raw?value:["".concat(key,"=").concat(value)];}else if(isRef(value)){value=formatProp(key,toRaw(value.value),true);return raw?value:["".concat(key,"=Ref<"),value,">"];}else if(isFunction(value)){return["".concat(key,"=fn").concat(value.name?"<".concat(value.name,">"):"")];}else{value=toRaw(value);return raw?value:["".concat(key,"="),value];}}var ErrorTypeStrings=(_ErrorTypeStrings={},_defineProperty(_ErrorTypeStrings,"sp"/* SERVER_PREFETCH */,'serverPrefetch hook'),_defineProperty(_ErrorTypeStrings,"bc"/* BEFORE_CREATE */,'beforeCreate hook'),_defineProperty(_ErrorTypeStrings,"c"/* CREATED */,'created hook'),_defineProperty(_ErrorTypeStrings,"bm"/* BEFORE_MOUNT */,'beforeMount hook'),_defineProperty(_ErrorTypeStrings,"m"/* MOUNTED */,'mounted hook'),_defineProperty(_ErrorTypeStrings,"bu"/* BEFORE_UPDATE */,'beforeUpdate hook'),_defineProperty(_ErrorTypeStrings,"u"/* UPDATED */,'updated'),_defineProperty(_ErrorTypeStrings,"bum"/* BEFORE_UNMOUNT */,'beforeUnmount hook'),_defineProperty(_ErrorTypeStrings,"um"/* UNMOUNTED */,'unmounted hook'),_defineProperty(_ErrorTypeStrings,"a"/* ACTIVATED */,'activated hook'),_defineProperty(_ErrorTypeStrings,"da"/* DEACTIVATED */,'deactivated hook'),_defineProperty(_ErrorTypeStrings,"ec"/* ERROR_CAPTURED */,'errorCaptured hook'),_defineProperty(_ErrorTypeStrings,"rtc"/* RENDER_TRACKED */,'renderTracked hook'),_defineProperty(_ErrorTypeStrings,"rtg"/* RENDER_TRIGGERED */,'renderTriggered hook'),_defineProperty(_ErrorTypeStrings,0/* SETUP_FUNCTION */,'setup function'),_defineProperty(_ErrorTypeStrings,1/* RENDER_FUNCTION */,'render function'),_defineProperty(_ErrorTypeStrings,2/* WATCH_GETTER */,'watcher getter'),_defineProperty(_ErrorTypeStrings,3/* WATCH_CALLBACK */,'watcher callback'),_defineProperty(_ErrorTypeStrings,4/* WATCH_CLEANUP */,'watcher cleanup function'),_defineProperty(_ErrorTypeStrings,5/* NATIVE_EVENT_HANDLER */,'native event handler'),_defineProperty(_ErrorTypeStrings,6/* COMPONENT_EVENT_HANDLER */,'component event handler'),_defineProperty(_ErrorTypeStrings,7/* VNODE_HOOK */,'vnode hook'),_defineProperty(_ErrorTypeStrings,8/* DIRECTIVE_HOOK */,'directive hook'),_defineProperty(_ErrorTypeStrings,9/* TRANSITION_HOOK */,'transition hook'),_defineProperty(_ErrorTypeStrings,10/* APP_ERROR_HANDLER */,'app errorHandler'),_defineProperty(_ErrorTypeStrings,11/* APP_WARN_HANDLER */,'app warnHandler'),_defineProperty(_ErrorTypeStrings,12/* FUNCTION_REF */,'ref function'),_defineProperty(_ErrorTypeStrings,13/* ASYNC_COMPONENT_LOADER */,'async component loader'),_defineProperty(_ErrorTypeStrings,14/* SCHEDULER */,'scheduler flush. This is likely a Vue internals bug. '+'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'),_ErrorTypeStrings);function callWithErrorHandling(fn,instance,type,args){var res;try{res=args?fn.apply(void 0,_toConsumableArray(args)):fn();}catch(err){handleError(err,instance,type);}return res;}function callWithAsyncErrorHandling(fn,instance,type,args){if(isFunction(fn)){var res=callWithErrorHandling(fn,instance,type,args);if(res&&isPromise(res)){res.catch(function(err){handleError(err,instance,type);});}return res;}var values=[];for(var i=0;i<fn.length;i++){values.push(callWithAsyncErrorHandling(fn[i],instance,type,args));}return values;}function handleError(err,instance,type){var throwInDev=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;var contextVNode=instance?instance.vnode:null;if(instance){var cur=instance.parent;// the exposed instance is the render proxy to keep it consistent with 2.x
var exposedInstance=instance.proxy;// in production the hook receives only the error code
var errorInfo=ErrorTypeStrings[type];while(cur){var errorCapturedHooks=cur.ec;if(errorCapturedHooks){for(var i=0;i<errorCapturedHooks.length;i++){if(errorCapturedHooks[i](err,exposedInstance,errorInfo)===false){return;}}}cur=cur.parent;}// app-level handling
var appErrorHandler=instance.appContext.config.errorHandler;if(appErrorHandler){callWithErrorHandling(appErrorHandler,null,10/* APP_ERROR_HANDLER */,[err,exposedInstance,errorInfo]);return;}}logError(err,type,contextVNode,throwInDev);}function logError(err,type,contextVNode){var throwInDev=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;{var info=ErrorTypeStrings[type];if(contextVNode){pushWarningContext(contextVNode);}warn$1("Unhandled error".concat(info?" during execution of ".concat(info):""));if(contextVNode){popWarningContext();}// crash in dev by default so it's more noticeable
if(throwInDev){throw err;}else{console.error(err);}}}var isFlushing=false;var isFlushPending=false;var queue=[];var flushIndex=0;var pendingPreFlushCbs=[];var activePreFlushCbs=null;var preFlushIndex=0;var pendingPostFlushCbs=[];var activePostFlushCbs=null;var postFlushIndex=0;var resolvedPromise=Promise.resolve();var currentFlushPromise=null;var currentPreFlushParentJob=null;var RECURSION_LIMIT=100;function nextTick(fn){var p=currentFlushPromise||resolvedPromise;return fn?p.then(this?fn.bind(this):fn):p;}// #2768
// Use binary-search to find a suitable position in the queue,
// so that the queue maintains the increasing order of job's id,
// which can prevent the job from being skipped and also can avoid repeated patching.
function findInsertionIndex(id){// the start index should be `flushIndex + 1`
var start=flushIndex+1;var end=queue.length;while(start<end){var middle=start+end>>>1;var middleJobId=getId(queue[middle]);middleJobId<id?start=middle+1:end=middle;}return start;}function queueJob(job){// the dedupe search uses the startIndex argument of Array.includes()
// by default the search index includes the current job that is being run
// so it cannot recursively trigger itself again.
// if the job is a watch() callback, the search will start with a +1 index to
// allow it recursively trigger itself - it is the user's responsibility to
// ensure it doesn't end up in an infinite loop.
if((!queue.length||!queue.includes(job,isFlushing&&job.allowRecurse?flushIndex+1:flushIndex))&&job!==currentPreFlushParentJob){if(job.id==null){queue.push(job);}else{queue.splice(findInsertionIndex(job.id),0,job);}queueFlush();}}function queueFlush(){if(!isFlushing&&!isFlushPending){isFlushPending=true;currentFlushPromise=resolvedPromise.then(flushJobs);}}function invalidateJob(job){var i=queue.indexOf(job);if(i>flushIndex){queue.splice(i,1);}}function queueCb(cb,activeQueue,pendingQueue,index){if(!isArray(cb)){if(!activeQueue||!activeQueue.includes(cb,cb.allowRecurse?index+1:index)){pendingQueue.push(cb);}}else{// if cb is an array, it is a component lifecycle hook which can only be
// triggered by a job, which is already deduped in the main queue, so
// we can skip duplicate check here to improve perf
pendingQueue.push.apply(pendingQueue,_toConsumableArray(cb));}queueFlush();}function queuePreFlushCb(cb){queueCb(cb,activePreFlushCbs,pendingPreFlushCbs,preFlushIndex);}function queuePostFlushCb(cb){queueCb(cb,activePostFlushCbs,pendingPostFlushCbs,postFlushIndex);}function flushPreFlushCbs(seen){var parentJob=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(pendingPreFlushCbs.length){currentPreFlushParentJob=parentJob;activePreFlushCbs=_toConsumableArray(new Set(pendingPreFlushCbs));pendingPreFlushCbs.length=0;{seen=seen||new Map();}for(preFlushIndex=0;preFlushIndex<activePreFlushCbs.length;preFlushIndex++){if(checkRecursiveUpdates(seen,activePreFlushCbs[preFlushIndex])){continue;}activePreFlushCbs[preFlushIndex]();}activePreFlushCbs=null;preFlushIndex=0;currentPreFlushParentJob=null;// recursively flush until it drains
flushPreFlushCbs(seen,parentJob);}}function flushPostFlushCbs(seen){if(pendingPostFlushCbs.length){var deduped=_toConsumableArray(new Set(pendingPostFlushCbs));pendingPostFlushCbs.length=0;// #1947 already has active queue, nested flushPostFlushCbs call
if(activePostFlushCbs){var _activePostFlushCbs;(_activePostFlushCbs=activePostFlushCbs).push.apply(_activePostFlushCbs,_toConsumableArray(deduped));return;}activePostFlushCbs=deduped;{seen=seen||new Map();}activePostFlushCbs.sort(function(a,b){return getId(a)-getId(b);});for(postFlushIndex=0;postFlushIndex<activePostFlushCbs.length;postFlushIndex++){if(checkRecursiveUpdates(seen,activePostFlushCbs[postFlushIndex])){continue;}activePostFlushCbs[postFlushIndex]();}activePostFlushCbs=null;postFlushIndex=0;}}var getId=function getId(job){return job.id==null?Infinity:job.id;};function flushJobs(seen){isFlushPending=false;isFlushing=true;{seen=seen||new Map();}flushPreFlushCbs(seen);// Sort queue before flush.
// This ensures that:
// 1. Components are updated from parent to child. (because parent is always
//    created before the child so its render effect will have smaller
//    priority number)
// 2. If a component is unmounted during a parent component's update,
//    its update can be skipped.
queue.sort(function(a,b){return getId(a)-getId(b);});// conditional usage of checkRecursiveUpdate must be determined out of
// try ... catch block since Rollup by default de-optimizes treeshaking
// inside try-catch. This can leave all warning code unshaked. Although
// they would get eventually shaken by a minifier like terser, some minifiers
// would fail to do that (e.g. https://github.com/evanw/esbuild/issues/1610)
var check=function check(job){return checkRecursiveUpdates(seen,job);};try{for(flushIndex=0;flushIndex<queue.length;flushIndex++){var job=queue[flushIndex];if(job&&job.active!==false){if( true&&check(job)){continue;}// console.log(`running:`, job.id)
callWithErrorHandling(job,null,14/* SCHEDULER */);}}}finally{flushIndex=0;queue.length=0;flushPostFlushCbs(seen);isFlushing=false;currentFlushPromise=null;// some postFlushCb queued jobs!
// keep flushing until it drains.
if(queue.length||pendingPreFlushCbs.length||pendingPostFlushCbs.length){flushJobs(seen);}}}function checkRecursiveUpdates(seen,fn){if(!seen.has(fn)){seen.set(fn,1);}else{var count=seen.get(fn);if(count>RECURSION_LIMIT){var instance=fn.ownerInstance;var componentName=instance&&getComponentName(instance.type);warn$1("Maximum recursive updates exceeded".concat(componentName?" in component <".concat(componentName,">"):"",". ")+"This means you have a reactive effect that is mutating its own "+"dependencies and thus recursively triggering itself. Possible sources "+"include component template, render function, updated hook or "+"watcher source function.");return true;}else{seen.set(fn,count+1);}}}/* eslint-disable no-restricted-globals */var isHmrUpdating=false;var hmrDirtyComponents=new Set();// Expose the HMR runtime on the global object
// This makes it entirely tree-shakable without polluting the exports and makes
// it easier to be used in toolings like vue-loader
// Note: for a component to be eligible for HMR it also needs the __hmrId option
// to be set so that its instances can be registered / removed.
{getGlobalThis().__VUE_HMR_RUNTIME__={createRecord:tryWrap(createRecord),rerender:tryWrap(rerender),reload:tryWrap(reload)};}var map=new Map();function registerHMR(instance){var id=instance.type.__hmrId;var record=map.get(id);if(!record){createRecord(id,instance.type);record=map.get(id);}record.instances.add(instance);}function unregisterHMR(instance){map.get(instance.type.__hmrId).instances.delete(instance);}function createRecord(id,initialDef){if(map.has(id)){return false;}map.set(id,{initialDef:normalizeClassComponent(initialDef),instances:new Set()});return true;}function normalizeClassComponent(component){return isClassComponent(component)?component.__vccOpts:component;}function rerender(id,newRender){var record=map.get(id);if(!record){return;}// update initial record (for not-yet-rendered component)
record.initialDef.render=newRender;_toConsumableArray(record.instances).forEach(function(instance){if(newRender){instance.render=newRender;normalizeClassComponent(instance.type).render=newRender;}instance.renderCache=[];// this flag forces child components with slot content to update
isHmrUpdating=true;instance.update();isHmrUpdating=false;});}function reload(id,newComp){var record=map.get(id);if(!record)return;newComp=normalizeClassComponent(newComp);// update initial def (for not-yet-rendered components)
updateComponentDef(record.initialDef,newComp);// create a snapshot which avoids the set being mutated during updates
var instances=_toConsumableArray(record.instances);var _iterator3=_createForOfIteratorHelper(instances),_step3;try{for(_iterator3.s();!(_step3=_iterator3.n()).done;){var instance=_step3.value;var oldComp=normalizeClassComponent(instance.type);if(!hmrDirtyComponents.has(oldComp)){// 1. Update existing comp definition to match new one
if(oldComp!==record.initialDef){updateComponentDef(oldComp,newComp);}// 2. mark definition dirty. This forces the renderer to replace the
// component on patch.
hmrDirtyComponents.add(oldComp);}// 3. invalidate options resolution cache
instance.appContext.optionsCache.delete(instance.type);// 4. actually update
if(instance.ceReload){// custom element
hmrDirtyComponents.add(oldComp);instance.ceReload(newComp.styles);hmrDirtyComponents.delete(oldComp);}else if(instance.parent){// 4. Force the parent instance to re-render. This will cause all updated
// components to be unmounted and re-mounted. Queue the update so that we
// don't end up forcing the same parent to re-render multiple times.
queueJob(instance.parent.update);// instance is the inner component of an async custom element
// invoke to reset styles
if(instance.parent.type.__asyncLoader&&instance.parent.ceReload){instance.parent.ceReload(newComp.styles);}}else if(instance.appContext.reload){// root instance mounted via createApp() has a reload method
instance.appContext.reload();}else if(typeof window!=='undefined'){// root instance inside tree created via raw render(). Force reload.
window.location.reload();}else{console.warn('[HMR] Root or manually mounted instance modified. Full reload required.');}}// 5. make sure to cleanup dirty hmr components after update
}catch(err){_iterator3.e(err);}finally{_iterator3.f();}queuePostFlushCb(function(){var _iterator4=_createForOfIteratorHelper(instances),_step4;try{for(_iterator4.s();!(_step4=_iterator4.n()).done;){var instance=_step4.value;hmrDirtyComponents.delete(normalizeClassComponent(instance.type));}}catch(err){_iterator4.e(err);}finally{_iterator4.f();}});}function updateComponentDef(oldComp,newComp){extend(oldComp,newComp);for(var key in oldComp){if(key!=='__file'&&!(key in newComp)){delete oldComp[key];}}}function tryWrap(fn){return function(id,arg){try{return fn(id,arg);}catch(e){console.error(e);console.warn("[HMR] Something went wrong during Vue component hot-reload. "+"Full reload required.");}};}var devtools;var buffer=[];var devtoolsNotInstalled=false;function emit(event){for(var _len5=arguments.length,args=new Array(_len5>1?_len5-1:0),_key6=1;_key6<_len5;_key6++){args[_key6-1]=arguments[_key6];}if(devtools){var _devtools;(_devtools=devtools).emit.apply(_devtools,[event].concat(args));}else if(!devtoolsNotInstalled){buffer.push({event:event,args:args});}}function setDevtoolsHook(hook,target){var _a,_b;devtools=hook;if(devtools){devtools.enabled=true;buffer.forEach(function(_ref9){var _devtools2;var event=_ref9.event,args=_ref9.args;return(_devtools2=devtools).emit.apply(_devtools2,[event].concat(_toConsumableArray(args)));});buffer=[];}else if(// handle late devtools injection - only do this if we are in an actual
// browser environment to avoid the timer handle stalling test runner exit
// (#4815)
// eslint-disable-next-line no-restricted-globals
typeof window!=='undefined'&&// some envs mock window but not fully
window.HTMLElement&&// also exclude jsdom
!((_b=(_a=window.navigator)===null||_a===void 0?void 0:_a.userAgent)===null||_b===void 0?void 0:_b.includes('jsdom'))){var replay=target.__VUE_DEVTOOLS_HOOK_REPLAY__=target.__VUE_DEVTOOLS_HOOK_REPLAY__||[];replay.push(function(newHook){setDevtoolsHook(newHook,target);});// clear buffer after 3s - the user probably doesn't have devtools installed
// at all, and keeping the buffer will cause memory leaks (#4738)
setTimeout(function(){if(!devtools){target.__VUE_DEVTOOLS_HOOK_REPLAY__=null;devtoolsNotInstalled=true;buffer=[];}},3000);}else{// non-browser env, assume not installed
devtoolsNotInstalled=true;buffer=[];}}function devtoolsInitApp(app,version){emit("app:init"/* APP_INIT */,app,version,{Fragment:Fragment,Text:Text,Comment:Comment,Static:Static});}function devtoolsUnmountApp(app){emit("app:unmount"/* APP_UNMOUNT */,app);}var devtoolsComponentAdded=/*#__PURE__*/createDevtoolsComponentHook("component:added"/* COMPONENT_ADDED */);var devtoolsComponentUpdated=/*#__PURE__*/createDevtoolsComponentHook("component:updated"/* COMPONENT_UPDATED */);var devtoolsComponentRemoved=/*#__PURE__*/createDevtoolsComponentHook("component:removed"/* COMPONENT_REMOVED */);function createDevtoolsComponentHook(hook){return function(component){emit(hook,component.appContext.app,component.uid,component.parent?component.parent.uid:undefined,component);};}var devtoolsPerfStart=/*#__PURE__*/createDevtoolsPerformanceHook("perf:start"/* PERFORMANCE_START */);var devtoolsPerfEnd=/*#__PURE__*/createDevtoolsPerformanceHook("perf:end"/* PERFORMANCE_END */);function createDevtoolsPerformanceHook(hook){return function(component,type,time){emit(hook,component.appContext.app,component.uid,component,type,time);};}function devtoolsComponentEmit(component,event,params){emit("component:emit"/* COMPONENT_EMIT */,component.appContext.app,component,event,params);}function emit$1(instance,event){var props=instance.vnode.props||EMPTY_OBJ;for(var _len6=arguments.length,rawArgs=new Array(_len6>2?_len6-2:0),_key7=2;_key7<_len6;_key7++){rawArgs[_key7-2]=arguments[_key7];}{var emitsOptions=instance.emitsOptions,_instance$propsOption=_slicedToArray(instance.propsOptions,1),propsOptions=_instance$propsOption[0];if(emitsOptions){if(!(event in emitsOptions)&&!false){if(!propsOptions||!(toHandlerKey(event)in propsOptions)){warn$1("Component emitted event \"".concat(event,"\" but it is neither declared in ")+"the emits option nor as an \"".concat(toHandlerKey(event),"\" prop."));}}else{var validator=emitsOptions[event];if(isFunction(validator)){var isValid=validator.apply(void 0,rawArgs);if(!isValid){warn$1("Invalid event arguments: event validation failed for event \"".concat(event,"\"."));}}}}}var args=rawArgs;var isModelListener=event.startsWith('update:');// for v-model update:xxx events, apply modifiers on args
var modelArg=isModelListener&&event.slice(7);if(modelArg&&modelArg in props){var modifiersKey="".concat(modelArg==='modelValue'?'model':modelArg,"Modifiers");var _ref10=props[modifiersKey]||EMPTY_OBJ,number=_ref10.number,trim=_ref10.trim;if(trim){args=rawArgs.map(function(a){return a.trim();});}else if(number){args=rawArgs.map(toNumber);}}{devtoolsComponentEmit(instance,event,args);}{var lowerCaseEvent=event.toLowerCase();if(lowerCaseEvent!==event&&props[toHandlerKey(lowerCaseEvent)]){warn$1("Event \"".concat(lowerCaseEvent,"\" is emitted in component ")+"".concat(formatComponentName(instance,instance.type)," but the handler is registered for \"").concat(event,"\". ")+"Note that HTML attributes are case-insensitive and you cannot use "+"v-on to listen to camelCase events when using in-DOM templates. "+"You should probably use \"".concat(hyphenate(event),"\" instead of \"").concat(event,"\"."));}}var handlerName;var handler=props[handlerName=toHandlerKey(event)]||// also try camelCase event handler (#2249)
props[handlerName=toHandlerKey(camelize(event))];// for v-model update:xxx events, also trigger kebab-case equivalent
// for props passed via kebab-case
if(!handler&&isModelListener){handler=props[handlerName=toHandlerKey(hyphenate(event))];}if(handler){callWithAsyncErrorHandling(handler,instance,6/* COMPONENT_EVENT_HANDLER */,args);}var onceHandler=props[handlerName+"Once"];if(onceHandler){if(!instance.emitted){instance.emitted={};}else if(instance.emitted[handlerName]){return;}instance.emitted[handlerName]=true;callWithAsyncErrorHandling(onceHandler,instance,6/* COMPONENT_EVENT_HANDLER */,args);}}function normalizeEmitsOptions(comp,appContext){var asMixin=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var cache=appContext.emitsCache;var cached=cache.get(comp);if(cached!==undefined){return cached;}var raw=comp.emits;var normalized={};// apply mixin/extends props
var hasExtends=false;if(!isFunction(comp)){var extendEmits=function extendEmits(raw){var normalizedFromExtend=normalizeEmitsOptions(raw,appContext,true);if(normalizedFromExtend){hasExtends=true;extend(normalized,normalizedFromExtend);}};if(!asMixin&&appContext.mixins.length){appContext.mixins.forEach(extendEmits);}if(comp.extends){extendEmits(comp.extends);}if(comp.mixins){comp.mixins.forEach(extendEmits);}}if(!raw&&!hasExtends){cache.set(comp,null);return null;}if(isArray(raw)){raw.forEach(function(key){return normalized[key]=null;});}else{extend(normalized,raw);}cache.set(comp,normalized);return normalized;}// Check if an incoming prop key is a declared emit event listener.
// e.g. With `emits: { click: null }`, props named `onClick` and `onclick` are
// both considered matched listeners.
function isEmitListener(options,key){if(!options||!isOn(key)){return false;}key=key.slice(2).replace(/Once$/,'');return hasOwn(options,key[0].toLowerCase()+key.slice(1))||hasOwn(options,hyphenate(key))||hasOwn(options,key);}/**
 * mark the current rendering instance for asset resolution (e.g.
 * resolveComponent, resolveDirective) during render
 */var currentRenderingInstance=null;var currentScopeId=null;/**
 * Note: rendering calls maybe nested. The function returns the parent rendering
 * instance if present, which should be restored after the render is done:
 *
 * ```js
 * const prev = setCurrentRenderingInstance(i)
 * // ...render
 * setCurrentRenderingInstance(prev)
 * ```
 */function setCurrentRenderingInstance(instance){var prev=currentRenderingInstance;currentRenderingInstance=instance;currentScopeId=instance&&instance.type.__scopeId||null;return prev;}/**
 * Set scope id when creating hoisted vnodes.
 * @private compiler helper
 */function pushScopeId(id){currentScopeId=id;}/**
 * Technically we no longer need this after 3.0.8 but we need to keep the same
 * API for backwards compat w/ code generated by compilers.
 * @private
 */function popScopeId(){currentScopeId=null;}/**
 * Only for backwards compat
 * @private
 */var withScopeId=function withScopeId(_id){return withCtx;};/**
 * Wrap a slot function to memoize current rendering instance
 * @private compiler helper
 */function withCtx(fn)// false only
{var ctx=arguments.length>1&&arguments[1]!==undefined?arguments[1]:currentRenderingInstance;var isNonScopedSlot=arguments.length>2?arguments[2]:undefined;if(!ctx)return fn;// already normalized
if(fn._n){return fn;}var renderFnWithContext=function renderFnWithContext(){// If a user calls a compiled slot inside a template expression (#1745), it
// can mess up block tracking, so by default we disable block tracking and
// force bail out when invoking a compiled slot (indicated by the ._d flag).
// This isn't necessary if rendering a compiled `<slot>`, so we flip the
// ._d flag off when invoking the wrapped fn inside `renderSlot`.
if(renderFnWithContext._d){setBlockTracking(-1);}var prevInstance=setCurrentRenderingInstance(ctx);var res=fn.apply(void 0,arguments);setCurrentRenderingInstance(prevInstance);if(renderFnWithContext._d){setBlockTracking(1);}{devtoolsComponentUpdated(ctx);}return res;};// mark normalized to avoid duplicated wrapping
renderFnWithContext._n=true;// mark this as compiled by default
// this is used in vnode.ts -> normalizeChildren() to set the slot
// rendering flag.
renderFnWithContext._c=true;// disable block tracking by default
renderFnWithContext._d=true;return renderFnWithContext;}/**
 * dev only flag to track whether $attrs was used during render.
 * If $attrs was used during render then the warning for failed attrs
 * fallthrough can be suppressed.
 */var accessedAttrs=false;function markAttrsAccessed(){accessedAttrs=true;}function renderComponentRoot(instance){var Component=instance.type,vnode=instance.vnode,proxy=instance.proxy,withProxy=instance.withProxy,props=instance.props,_instance$propsOption2=_slicedToArray(instance.propsOptions,1),propsOptions=_instance$propsOption2[0],slots=instance.slots,attrs=instance.attrs,emit=instance.emit,render=instance.render,renderCache=instance.renderCache,data=instance.data,setupState=instance.setupState,ctx=instance.ctx,inheritAttrs=instance.inheritAttrs;var result;var fallthroughAttrs;var prev=setCurrentRenderingInstance(instance);{accessedAttrs=false;}try{if(vnode.shapeFlag&4/* STATEFUL_COMPONENT */){// withProxy is a proxy with a different `has` trap only for
// runtime-compiled render functions using `with` block.
var proxyToUse=withProxy||proxy;result=normalizeVNode(render.call(proxyToUse,proxyToUse,renderCache,props,setupState,data,ctx));fallthroughAttrs=attrs;}else{// functional
var _render=Component;// in dev, mark attrs accessed if optional props (attrs === props)
if( true&&attrs===props){markAttrsAccessed();}result=normalizeVNode(_render.length>1?_render(props, true?{get attrs(){markAttrsAccessed();return attrs;},slots:slots,emit:emit}:0):_render(props,null/* we know it doesn't need it */));fallthroughAttrs=Component.props?attrs:getFunctionalFallthrough(attrs);}}catch(err){blockStack.length=0;handleError(err,instance,1/* RENDER_FUNCTION */);result=createVNode(Comment);}// attr merging
// in dev mode, comments are preserved, and it's possible for a template
// to have comments along side the root element which makes it a fragment
var root=result;var setRoot=undefined;if(result.patchFlag>0&&result.patchFlag&2048/* DEV_ROOT_FRAGMENT */){var _getChildRoot=getChildRoot(result);var _getChildRoot2=_slicedToArray(_getChildRoot,2);root=_getChildRoot2[0];setRoot=_getChildRoot2[1];}if(fallthroughAttrs&&inheritAttrs!==false){var keys=Object.keys(fallthroughAttrs);var _root=root,shapeFlag=_root.shapeFlag;if(keys.length){if(shapeFlag&(1/* ELEMENT */|6/* COMPONENT */)){if(propsOptions&&keys.some(isModelListener)){// If a v-model listener (onUpdate:xxx) has a corresponding declared
// prop, it indicates this component expects to handle v-model and
// it should not fallthrough.
// related: #1543, #1643, #1989
fallthroughAttrs=filterModelListeners(fallthroughAttrs,propsOptions);}root=cloneVNode(root,fallthroughAttrs);}else if(!accessedAttrs&&root.type!==Comment){var allAttrs=Object.keys(attrs);var eventAttrs=[];var extraAttrs=[];for(var i=0,l=allAttrs.length;i<l;i++){var key=allAttrs[i];if(isOn(key)){// ignore v-model handlers when they fail to fallthrough
if(!isModelListener(key)){// remove `on`, lowercase first letter to reflect event casing
// accurately
eventAttrs.push(key[2].toLowerCase()+key.slice(3));}}else{extraAttrs.push(key);}}if(extraAttrs.length){warn$1("Extraneous non-props attributes ("+"".concat(extraAttrs.join(', '),") ")+"were passed to component but could not be automatically inherited "+"because component renders fragment or text root nodes.");}if(eventAttrs.length){warn$1("Extraneous non-emits event listeners ("+"".concat(eventAttrs.join(', '),") ")+"were passed to component but could not be automatically inherited "+"because component renders fragment or text root nodes. "+"If the listener is intended to be a component custom event listener only, "+"declare it using the \"emits\" option.");}}}}// inherit directives
if(vnode.dirs){if(!isElementRoot(root)){warn$1("Runtime directive used on component with non-element root node. "+"The directives will not function as intended.");}root.dirs=root.dirs?root.dirs.concat(vnode.dirs):vnode.dirs;}// inherit transition data
if(vnode.transition){if(!isElementRoot(root)){warn$1("Component inside <Transition> renders non-element root node "+"that cannot be animated.");}root.transition=vnode.transition;}if(setRoot){setRoot(root);}else{result=root;}setCurrentRenderingInstance(prev);return result;}/**
 * dev only
 * In dev mode, template root level comments are rendered, which turns the
 * template into a fragment root, but we need to locate the single element
 * root for attrs and scope id processing.
 */var getChildRoot=function getChildRoot(vnode){var rawChildren=vnode.children;var dynamicChildren=vnode.dynamicChildren;var childRoot=filterSingleRoot(rawChildren);if(!childRoot){return[vnode,undefined];}var index=rawChildren.indexOf(childRoot);var dynamicIndex=dynamicChildren?dynamicChildren.indexOf(childRoot):-1;var setRoot=function setRoot(updatedRoot){rawChildren[index]=updatedRoot;if(dynamicChildren){if(dynamicIndex>-1){dynamicChildren[dynamicIndex]=updatedRoot;}else if(updatedRoot.patchFlag>0){vnode.dynamicChildren=[].concat(_toConsumableArray(dynamicChildren),[updatedRoot]);}}};return[normalizeVNode(childRoot),setRoot];};function filterSingleRoot(children){var singleRoot;for(var i=0;i<children.length;i++){var child=children[i];if(isVNode(child)){// ignore user comment
if(child.type!==Comment||child.children==='v-if'){if(singleRoot){// has more than 1 non-comment child, return now
return;}else{singleRoot=child;}}}else{return;}}return singleRoot;}var getFunctionalFallthrough=function getFunctionalFallthrough(attrs){var res;for(var key in attrs){if(key==='class'||key==='style'||isOn(key)){(res||(res={}))[key]=attrs[key];}}return res;};var filterModelListeners=function filterModelListeners(attrs,props){var res={};for(var key in attrs){if(!isModelListener(key)||!(key.slice(9)in props)){res[key]=attrs[key];}}return res;};var isElementRoot=function isElementRoot(vnode){return vnode.shapeFlag&(6/* COMPONENT */|1/* ELEMENT */)||vnode.type===Comment// potential v-if branch switch
;};function shouldUpdateComponent(prevVNode,nextVNode,optimized){var prevProps=prevVNode.props,prevChildren=prevVNode.children,component=prevVNode.component;var nextProps=nextVNode.props,nextChildren=nextVNode.children,patchFlag=nextVNode.patchFlag;var emits=component.emitsOptions;// Parent component's render function was hot-updated. Since this may have
// caused the child component's slots content to have changed, we need to
// force the child to update as well.
if((prevChildren||nextChildren)&&isHmrUpdating){return true;}// force child update for runtime directive or transition on component vnode.
if(nextVNode.dirs||nextVNode.transition){return true;}if(optimized&&patchFlag>=0){if(patchFlag&1024/* DYNAMIC_SLOTS */){// slot content that references values that might have changed,
// e.g. in a v-for
return true;}if(patchFlag&16/* FULL_PROPS */){if(!prevProps){return!!nextProps;}// presence of this flag indicates props are always non-null
return hasPropsChanged(prevProps,nextProps,emits);}else if(patchFlag&8/* PROPS */){var dynamicProps=nextVNode.dynamicProps;for(var i=0;i<dynamicProps.length;i++){var key=dynamicProps[i];if(nextProps[key]!==prevProps[key]&&!isEmitListener(emits,key)){return true;}}}}else{// this path is only taken by manually written render functions
// so presence of any children leads to a forced update
if(prevChildren||nextChildren){if(!nextChildren||!nextChildren.$stable){return true;}}if(prevProps===nextProps){return false;}if(!prevProps){return!!nextProps;}if(!nextProps){return true;}return hasPropsChanged(prevProps,nextProps,emits);}return false;}function hasPropsChanged(prevProps,nextProps,emitsOptions){var nextKeys=Object.keys(nextProps);if(nextKeys.length!==Object.keys(prevProps).length){return true;}for(var i=0;i<nextKeys.length;i++){var key=nextKeys[i];if(nextProps[key]!==prevProps[key]&&!isEmitListener(emitsOptions,key)){return true;}}return false;}function updateHOCHostEl(_ref11,el// HostNode
){var vnode=_ref11.vnode,parent=_ref11.parent;while(parent&&parent.subTree===vnode){(vnode=parent.vnode).el=el;parent=parent.parent;}}var isSuspense=function isSuspense(type){return type.__isSuspense;};// Suspense exposes a component-like API, and is treated like a component
// in the compiler, but internally it's a special built-in type that hooks
// directly into the renderer.
var SuspenseImpl={name:'Suspense',// In order to make Suspense tree-shakable, we need to avoid importing it
// directly in the renderer. The renderer checks for the __isSuspense flag
// on a vnode's type and calls the `process` method, passing in renderer
// internals.
__isSuspense:true,process:function process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,// platform-specific impl passed from renderer
rendererInternals){if(n1==null){mountSuspense(n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,rendererInternals);}else{patchSuspense(n1,n2,container,anchor,parentComponent,isSVG,slotScopeIds,optimized,rendererInternals);}},hydrate:hydrateSuspense,create:createSuspenseBoundary,normalize:normalizeSuspenseChildren};// Force-casted public typing for h and TSX props inference
var Suspense=SuspenseImpl;function triggerEvent(vnode,name){var eventListener=vnode.props&&vnode.props[name];if(isFunction(eventListener)){eventListener();}}function mountSuspense(vnode,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,rendererInternals){var patch=rendererInternals.p,createElement=rendererInternals.o.createElement;var hiddenContainer=createElement('div');var suspense=vnode.suspense=createSuspenseBoundary(vnode,parentSuspense,parentComponent,container,hiddenContainer,anchor,isSVG,slotScopeIds,optimized,rendererInternals);// start mounting the content subtree in an off-dom container
patch(null,suspense.pendingBranch=vnode.ssContent,hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds);// now check if we have encountered any async deps
if(suspense.deps>0){// has async
// invoke @fallback event
triggerEvent(vnode,'onPending');triggerEvent(vnode,'onFallback');// mount the fallback tree
patch(null,vnode.ssFallback,container,anchor,parentComponent,null,// fallback tree will not have suspense context
isSVG,slotScopeIds);setActiveBranch(suspense,vnode.ssFallback);}else{// Suspense has no async deps. Just resolve.
suspense.resolve();}}function patchSuspense(n1,n2,container,anchor,parentComponent,isSVG,slotScopeIds,optimized,_ref12){var patch=_ref12.p,unmount=_ref12.um,createElement=_ref12.o.createElement;var suspense=n2.suspense=n1.suspense;suspense.vnode=n2;n2.el=n1.el;var newBranch=n2.ssContent;var newFallback=n2.ssFallback;var activeBranch=suspense.activeBranch,pendingBranch=suspense.pendingBranch,isInFallback=suspense.isInFallback,isHydrating=suspense.isHydrating;if(pendingBranch){suspense.pendingBranch=newBranch;if(isSameVNodeType(newBranch,pendingBranch)){// same root type but content may have changed.
patch(pendingBranch,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds,optimized);if(suspense.deps<=0){suspense.resolve();}else if(isInFallback){patch(activeBranch,newFallback,container,anchor,parentComponent,null,// fallback tree will not have suspense context
isSVG,slotScopeIds,optimized);setActiveBranch(suspense,newFallback);}}else{// toggled before pending tree is resolved
suspense.pendingId++;if(isHydrating){// if toggled before hydration is finished, the current DOM tree is
// no longer valid. set it as the active branch so it will be unmounted
// when resolved
suspense.isHydrating=false;suspense.activeBranch=pendingBranch;}else{unmount(pendingBranch,parentComponent,suspense);}// increment pending ID. this is used to invalidate async callbacks
// reset suspense state
suspense.deps=0;// discard effects from pending branch
suspense.effects.length=0;// discard previous container
suspense.hiddenContainer=createElement('div');if(isInFallback){// already in fallback state
patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds,optimized);if(suspense.deps<=0){suspense.resolve();}else{patch(activeBranch,newFallback,container,anchor,parentComponent,null,// fallback tree will not have suspense context
isSVG,slotScopeIds,optimized);setActiveBranch(suspense,newFallback);}}else if(activeBranch&&isSameVNodeType(newBranch,activeBranch)){// toggled "back" to current active branch
patch(activeBranch,newBranch,container,anchor,parentComponent,suspense,isSVG,slotScopeIds,optimized);// force resolve
suspense.resolve(true);}else{// switched to a 3rd branch
patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds,optimized);if(suspense.deps<=0){suspense.resolve();}}}}else{if(activeBranch&&isSameVNodeType(newBranch,activeBranch)){// root did not change, just normal patch
patch(activeBranch,newBranch,container,anchor,parentComponent,suspense,isSVG,slotScopeIds,optimized);setActiveBranch(suspense,newBranch);}else{// root node toggled
// invoke @pending event
triggerEvent(n2,'onPending');// mount pending branch in off-dom container
suspense.pendingBranch=newBranch;suspense.pendingId++;patch(null,newBranch,suspense.hiddenContainer,null,parentComponent,suspense,isSVG,slotScopeIds,optimized);if(suspense.deps<=0){// incoming branch has no async deps, resolve now.
suspense.resolve();}else{var timeout=suspense.timeout,pendingId=suspense.pendingId;if(timeout>0){setTimeout(function(){if(suspense.pendingId===pendingId){suspense.fallback(newFallback);}},timeout);}else if(timeout===0){suspense.fallback(newFallback);}}}}}var hasWarned=false;function createSuspenseBoundary(vnode,parent,parentComponent,container,hiddenContainer,anchor,isSVG,slotScopeIds,optimized,rendererInternals){var isHydrating=arguments.length>10&&arguments[10]!==undefined?arguments[10]:false;/* istanbul ignore if */if(!hasWarned){hasWarned=true;// @ts-ignore `console.info` cannot be null error
console[console.info?'info':'log']("<Suspense> is an experimental feature and its API will likely change.");}var patch=rendererInternals.p,_move=rendererInternals.m,_unmount2=rendererInternals.um,_next=rendererInternals.n,_rendererInternals$o=rendererInternals.o,parentNode=_rendererInternals$o.parentNode,remove=_rendererInternals$o.remove;var timeout=toNumber(vnode.props&&vnode.props.timeout);var suspense={vnode:vnode,parent:parent,parentComponent:parentComponent,isSVG:isSVG,container:container,hiddenContainer:hiddenContainer,anchor:anchor,deps:0,pendingId:0,timeout:typeof timeout==='number'?timeout:-1,activeBranch:null,pendingBranch:null,isInFallback:true,isHydrating:isHydrating,isUnmounted:false,effects:[],resolve:function resolve(){var resume=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;{if(!resume&&!suspense.pendingBranch){throw new Error("suspense.resolve() is called without a pending branch.");}if(suspense.isUnmounted){throw new Error("suspense.resolve() is called on an already unmounted suspense boundary.");}}var vnode=suspense.vnode,activeBranch=suspense.activeBranch,pendingBranch=suspense.pendingBranch,pendingId=suspense.pendingId,effects=suspense.effects,parentComponent=suspense.parentComponent,container=suspense.container;if(suspense.isHydrating){suspense.isHydrating=false;}else if(!resume){var delayEnter=activeBranch&&pendingBranch.transition&&pendingBranch.transition.mode==='out-in';if(delayEnter){activeBranch.transition.afterLeave=function(){if(pendingId===suspense.pendingId){_move(pendingBranch,container,_anchor,0/* ENTER */);}};}// this is initial anchor on mount
var _anchor=suspense.anchor;// unmount current active tree
if(activeBranch){// if the fallback tree was mounted, it may have been moved
// as part of a parent suspense. get the latest anchor for insertion
_anchor=_next(activeBranch);_unmount2(activeBranch,parentComponent,suspense,true);}if(!delayEnter){// move content from off-dom container to actual container
_move(pendingBranch,container,_anchor,0/* ENTER */);}}setActiveBranch(suspense,pendingBranch);suspense.pendingBranch=null;suspense.isInFallback=false;// flush buffered effects
// check if there is a pending parent suspense
var parent=suspense.parent;var hasUnresolvedAncestor=false;while(parent){if(parent.pendingBranch){var _parent$effects;// found a pending parent suspense, merge buffered post jobs
// into that parent
(_parent$effects=parent.effects).push.apply(_parent$effects,_toConsumableArray(effects));hasUnresolvedAncestor=true;break;}parent=parent.parent;}// no pending parent suspense, flush all jobs
if(!hasUnresolvedAncestor){queuePostFlushCb(effects);}suspense.effects=[];// invoke @resolve event
triggerEvent(vnode,'onResolve');},fallback:function fallback(fallbackVNode){if(!suspense.pendingBranch){return;}var vnode=suspense.vnode,activeBranch=suspense.activeBranch,parentComponent=suspense.parentComponent,container=suspense.container,isSVG=suspense.isSVG;// invoke @fallback event
triggerEvent(vnode,'onFallback');var anchor=_next(activeBranch);var mountFallback=function mountFallback(){if(!suspense.isInFallback){return;}// mount the fallback tree
patch(null,fallbackVNode,container,anchor,parentComponent,null,// fallback tree will not have suspense context
isSVG,slotScopeIds,optimized);setActiveBranch(suspense,fallbackVNode);};var delayEnter=fallbackVNode.transition&&fallbackVNode.transition.mode==='out-in';if(delayEnter){activeBranch.transition.afterLeave=mountFallback;}suspense.isInFallback=true;// unmount current active branch
_unmount2(activeBranch,parentComponent,null,// no suspense so unmount hooks fire now
true// shouldRemove
);if(!delayEnter){mountFallback();}},move:function move(container,anchor,type){suspense.activeBranch&&_move(suspense.activeBranch,container,anchor,type);suspense.container=container;},next:function next(){return suspense.activeBranch&&_next(suspense.activeBranch);},registerDep:function registerDep(instance,setupRenderEffect){var isInPendingSuspense=!!suspense.pendingBranch;if(isInPendingSuspense){suspense.deps++;}var hydratedEl=instance.vnode.el;instance.asyncDep.catch(function(err){handleError(err,instance,0/* SETUP_FUNCTION */);}).then(function(asyncSetupResult){// retry when the setup() promise resolves.
// component may have been unmounted before resolve.
if(instance.isUnmounted||suspense.isUnmounted||suspense.pendingId!==instance.suspenseId){return;}// retry from this component
instance.asyncResolved=true;var vnode=instance.vnode;{pushWarningContext(vnode);}handleSetupResult(instance,asyncSetupResult,false);if(hydratedEl){// vnode may have been replaced if an update happened before the
// async dep is resolved.
vnode.el=hydratedEl;}var placeholder=!hydratedEl&&instance.subTree.el;setupRenderEffect(instance,vnode,// component may have been moved before resolve.
// if this is not a hydration, instance.subTree will be the comment
// placeholder.
parentNode(hydratedEl||instance.subTree.el),// anchor will not be used if this is hydration, so only need to
// consider the comment placeholder case.
hydratedEl?null:_next(instance.subTree),suspense,isSVG,optimized);if(placeholder){remove(placeholder);}updateHOCHostEl(instance,vnode.el);{popWarningContext();}// only decrease deps count if suspense is not already resolved
if(isInPendingSuspense&&--suspense.deps===0){suspense.resolve();}});},unmount:function unmount(parentSuspense,doRemove){suspense.isUnmounted=true;if(suspense.activeBranch){_unmount2(suspense.activeBranch,parentComponent,parentSuspense,doRemove);}if(suspense.pendingBranch){_unmount2(suspense.pendingBranch,parentComponent,parentSuspense,doRemove);}}};return suspense;}function hydrateSuspense(node,vnode,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,rendererInternals,hydrateNode){/* eslint-disable no-restricted-globals */var suspense=vnode.suspense=createSuspenseBoundary(vnode,parentSuspense,parentComponent,node.parentNode,document.createElement('div'),null,isSVG,slotScopeIds,optimized,rendererInternals,true/* hydrating */);// there are two possible scenarios for server-rendered suspense:
// - success: ssr content should be fully resolved
// - failure: ssr content should be the fallback branch.
// however, on the client we don't really know if it has failed or not
// attempt to hydrate the DOM assuming it has succeeded, but we still
// need to construct a suspense boundary first
var result=hydrateNode(node,suspense.pendingBranch=vnode.ssContent,parentComponent,suspense,slotScopeIds,optimized);if(suspense.deps===0){suspense.resolve();}return result;/* eslint-enable no-restricted-globals */}function normalizeSuspenseChildren(vnode){var shapeFlag=vnode.shapeFlag,children=vnode.children;var isSlotChildren=shapeFlag&32/* SLOTS_CHILDREN */;vnode.ssContent=normalizeSuspenseSlot(isSlotChildren?children.default:children);vnode.ssFallback=isSlotChildren?normalizeSuspenseSlot(children.fallback):createVNode(Comment);}function normalizeSuspenseSlot(s){var block;if(isFunction(s)){var trackBlock=isBlockTreeEnabled&&s._c;if(trackBlock){// disableTracking: false
// allow block tracking for compiled slots
// (see ./componentRenderContext.ts)
s._d=false;openBlock();}s=s();if(trackBlock){s._d=true;block=currentBlock;closeBlock();}}if(isArray(s)){var singleChild=filterSingleRoot(s);if(!singleChild){warn$1("<Suspense> slots expect a single root node.");}s=singleChild;}s=normalizeVNode(s);if(block&&!s.dynamicChildren){s.dynamicChildren=block.filter(function(c){return c!==s;});}return s;}function queueEffectWithSuspense(fn,suspense){if(suspense&&suspense.pendingBranch){if(isArray(fn)){var _suspense$effects;(_suspense$effects=suspense.effects).push.apply(_suspense$effects,_toConsumableArray(fn));}else{suspense.effects.push(fn);}}else{queuePostFlushCb(fn);}}function setActiveBranch(suspense,branch){suspense.activeBranch=branch;var vnode=suspense.vnode,parentComponent=suspense.parentComponent;var el=vnode.el=branch.el;// in case suspense is the root node of a component,
// recursively update the HOC el
if(parentComponent&&parentComponent.subTree===vnode){parentComponent.vnode.el=el;updateHOCHostEl(parentComponent,el);}}function provide(key,value){if(!currentInstance){{warn$1("provide() can only be used inside setup().");}}else{var provides=currentInstance.provides;// by default an instance inherits its parent's provides object
// but when it needs to provide values of its own, it creates its
// own provides object using parent provides object as prototype.
// this way in `inject` we can simply look up injections from direct
// parent and let the prototype chain do the work.
var parentProvides=currentInstance.parent&&currentInstance.parent.provides;if(parentProvides===provides){provides=currentInstance.provides=Object.create(parentProvides);}// TS doesn't allow symbol as index type
provides[key]=value;}}function inject(key,defaultValue){var treatDefaultAsFactory=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;// fallback to `currentRenderingInstance` so that this can be called in
// a functional component
var instance=currentInstance||currentRenderingInstance;if(instance){// #2400
// to support `app.use` plugins,
// fallback to appContext's `provides` if the instance is at root
var provides=instance.parent==null?instance.vnode.appContext&&instance.vnode.appContext.provides:instance.parent.provides;if(provides&&key in provides){// TS doesn't allow symbol as index type
return provides[key];}else if(arguments.length>1){return treatDefaultAsFactory&&isFunction(defaultValue)?defaultValue.call(instance.proxy):defaultValue;}else{warn$1("injection \"".concat(String(key),"\" not found."));}}else{warn$1("inject() can only be used inside setup() or functional components.");}}// Simple effect.
function watchEffect(effect,options){return doWatch(effect,null,options);}function watchPostEffect(effect,options){return doWatch(effect,null,Object.assign(options||{},{flush:'post'}));}function watchSyncEffect(effect,options){return doWatch(effect,null,Object.assign(options||{},{flush:'sync'}));}// initial value for watchers to trigger on undefined initial values
var INITIAL_WATCHER_VALUE={};// implementation
function watch(source,cb,options){if(!isFunction(cb)){warn$1("`watch(fn, options?)` signature has been moved to a separate API. "+"Use `watchEffect(fn, options?)` instead. `watch` now only "+"supports `watch(source, cb, options?) signature.");}return doWatch(source,cb,options);}function doWatch(source,cb){var _ref13=arguments.length>2&&arguments[2]!==undefined?arguments[2]:EMPTY_OBJ,immediate=_ref13.immediate,deep=_ref13.deep,flush=_ref13.flush,onTrack=_ref13.onTrack,onTrigger=_ref13.onTrigger;if(!cb){if(immediate!==undefined){warn$1("watch() \"immediate\" option is only respected when using the "+"watch(source, callback, options?) signature.");}if(deep!==undefined){warn$1("watch() \"deep\" option is only respected when using the "+"watch(source, callback, options?) signature.");}}var warnInvalidSource=function warnInvalidSource(s){warn$1("Invalid watch source: ",s,"A watch source can only be a getter/effect function, a ref, "+"a reactive object, or an array of these types.");};var instance=currentInstance;var getter;var forceTrigger=false;var isMultiSource=false;if(isRef(source)){getter=function getter(){return source.value;};forceTrigger=isShallow(source);}else if(isReactive(source)){getter=function getter(){return source;};deep=true;}else if(isArray(source)){isMultiSource=true;forceTrigger=source.some(isReactive);getter=function getter(){return source.map(function(s){if(isRef(s)){return s.value;}else if(isReactive(s)){return traverse(s);}else if(isFunction(s)){return callWithErrorHandling(s,instance,2/* WATCH_GETTER */);}else{warnInvalidSource(s);}});};}else if(isFunction(source)){if(cb){// getter with cb
getter=function getter(){return callWithErrorHandling(source,instance,2/* WATCH_GETTER */);};}else{// no cb -> simple effect
getter=function getter(){if(instance&&instance.isUnmounted){return;}if(cleanup){cleanup();}return callWithAsyncErrorHandling(source,instance,3/* WATCH_CALLBACK */,[onCleanup]);};}}else{getter=NOOP;warnInvalidSource(source);}if(cb&&deep){var baseGetter=getter;getter=function getter(){return traverse(baseGetter());};}var cleanup;var onCleanup=function onCleanup(fn){cleanup=effect.onStop=function(){callWithErrorHandling(fn,instance,4/* WATCH_CLEANUP */);};};var oldValue=isMultiSource?[]:INITIAL_WATCHER_VALUE;var job=function job(){if(!effect.active){return;}if(cb){// watch(source, cb)
var newValue=effect.run();if(deep||forceTrigger||(isMultiSource?newValue.some(function(v,i){return hasChanged(v,oldValue[i]);}):hasChanged(newValue,oldValue))||false){// cleanup before running cb again
if(cleanup){cleanup();}callWithAsyncErrorHandling(cb,instance,3/* WATCH_CALLBACK */,[newValue,// pass undefined as the old value when it's changed for the first time
oldValue===INITIAL_WATCHER_VALUE?undefined:oldValue,onCleanup]);oldValue=newValue;}}else{// watchEffect
effect.run();}};// important: mark the job as a watcher callback so that scheduler knows
// it is allowed to self-trigger (#1727)
job.allowRecurse=!!cb;var scheduler;if(flush==='sync'){scheduler=job;// the scheduler function gets called directly
}else if(flush==='post'){scheduler=function scheduler(){return queuePostRenderEffect(job,instance&&instance.suspense);};}else{// default: 'pre'
scheduler=function scheduler(){if(!instance||instance.isMounted){queuePreFlushCb(job);}else{// with 'pre' option, the first call must happen before
// the component is mounted so it is called synchronously.
job();}};}var effect=new ReactiveEffect(getter,scheduler);{effect.onTrack=onTrack;effect.onTrigger=onTrigger;}// initial run
if(cb){if(immediate){job();}else{oldValue=effect.run();}}else if(flush==='post'){queuePostRenderEffect(effect.run.bind(effect),instance&&instance.suspense);}else{effect.run();}return function(){effect.stop();if(instance&&instance.scope){remove(instance.scope.effects,effect);}};}// this.$watch
function instanceWatch(source,value,options){var publicThis=this.proxy;var getter=isString(source)?source.includes('.')?createPathGetter(publicThis,source):function(){return publicThis[source];}:source.bind(publicThis,publicThis);var cb;if(isFunction(value)){cb=value;}else{cb=value.handler;options=value;}var cur=currentInstance;setCurrentInstance(this);var res=doWatch(getter,cb.bind(publicThis),options);if(cur){setCurrentInstance(cur);}else{unsetCurrentInstance();}return res;}function createPathGetter(ctx,path){var segments=path.split('.');return function(){var cur=ctx;for(var i=0;i<segments.length&&cur;i++){cur=cur[segments[i]];}return cur;};}function traverse(value,seen){if(!isObject(value)||value["__v_skip"/* SKIP */]){return value;}seen=seen||new Set();if(seen.has(value)){return value;}seen.add(value);if(isRef(value)){traverse(value.value,seen);}else if(isArray(value)){for(var i=0;i<value.length;i++){traverse(value[i],seen);}}else if(isSet(value)||isMap(value)){value.forEach(function(v){traverse(v,seen);});}else if(isPlainObject(value)){for(var key in value){traverse(value[key],seen);}}return value;}function useTransitionState(){var state={isMounted:false,isLeaving:false,isUnmounting:false,leavingVNodes:new Map()};onMounted(function(){state.isMounted=true;});onBeforeUnmount(function(){state.isUnmounting=true;});return state;}var TransitionHookValidator=[Function,Array];var BaseTransitionImpl={name:"BaseTransition",props:{mode:String,appear:Boolean,persisted:Boolean,// enter
onBeforeEnter:TransitionHookValidator,onEnter:TransitionHookValidator,onAfterEnter:TransitionHookValidator,onEnterCancelled:TransitionHookValidator,// leave
onBeforeLeave:TransitionHookValidator,onLeave:TransitionHookValidator,onAfterLeave:TransitionHookValidator,onLeaveCancelled:TransitionHookValidator,// appear
onBeforeAppear:TransitionHookValidator,onAppear:TransitionHookValidator,onAfterAppear:TransitionHookValidator,onAppearCancelled:TransitionHookValidator},setup:function setup(props,_ref14){var slots=_ref14.slots;var instance=getCurrentInstance();var state=useTransitionState();var prevTransitionKey;return function(){var children=slots.default&&getTransitionRawChildren(slots.default(),true);if(!children||!children.length){return;}// warn multiple elements
if(children.length>1){warn$1('<transition> can only be used on a single element or component. Use '+'<transition-group> for lists.');}// there's no need to track reactivity for these props so use the raw
// props for a bit better perf
var rawProps=toRaw(props);var mode=rawProps.mode;// check mode
if(mode&&mode!=='in-out'&&mode!=='out-in'&&mode!=='default'){warn$1("invalid <transition> mode: ".concat(mode));}// at this point children has a guaranteed length of 1.
var child=children[0];if(state.isLeaving){return emptyPlaceholder(child);}// in the case of <transition><keep-alive/></transition>, we need to
// compare the type of the kept-alive children.
var innerChild=getKeepAliveChild(child);if(!innerChild){return emptyPlaceholder(child);}var enterHooks=resolveTransitionHooks(innerChild,rawProps,state,instance);setTransitionHooks(innerChild,enterHooks);var oldChild=instance.subTree;var oldInnerChild=oldChild&&getKeepAliveChild(oldChild);var transitionKeyChanged=false;var getTransitionKey=innerChild.type.getTransitionKey;if(getTransitionKey){var key=getTransitionKey();if(prevTransitionKey===undefined){prevTransitionKey=key;}else if(key!==prevTransitionKey){prevTransitionKey=key;transitionKeyChanged=true;}}// handle mode
if(oldInnerChild&&oldInnerChild.type!==Comment&&(!isSameVNodeType(innerChild,oldInnerChild)||transitionKeyChanged)){var leavingHooks=resolveTransitionHooks(oldInnerChild,rawProps,state,instance);// update old tree's hooks in case of dynamic transition
setTransitionHooks(oldInnerChild,leavingHooks);// switching between different views
if(mode==='out-in'){state.isLeaving=true;// return placeholder node and queue update when leave finishes
leavingHooks.afterLeave=function(){state.isLeaving=false;instance.update();};return emptyPlaceholder(child);}else if(mode==='in-out'&&innerChild.type!==Comment){leavingHooks.delayLeave=function(el,earlyRemove,delayedLeave){var leavingVNodesCache=getLeavingNodesForType(state,oldInnerChild);leavingVNodesCache[String(oldInnerChild.key)]=oldInnerChild;// early removal callback
el._leaveCb=function(){earlyRemove();el._leaveCb=undefined;delete enterHooks.delayedLeave;};enterHooks.delayedLeave=delayedLeave;};}}return child;};}};// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
var BaseTransition=BaseTransitionImpl;function getLeavingNodesForType(state,vnode){var leavingVNodes=state.leavingVNodes;var leavingVNodesCache=leavingVNodes.get(vnode.type);if(!leavingVNodesCache){leavingVNodesCache=Object.create(null);leavingVNodes.set(vnode.type,leavingVNodesCache);}return leavingVNodesCache;}// The transition hooks are attached to the vnode as vnode.transition
// and will be called at appropriate timing in the renderer.
function resolveTransitionHooks(vnode,props,state,instance){var appear=props.appear,mode=props.mode,_props$persisted=props.persisted,persisted=_props$persisted===void 0?false:_props$persisted,onBeforeEnter=props.onBeforeEnter,onEnter=props.onEnter,onAfterEnter=props.onAfterEnter,onEnterCancelled=props.onEnterCancelled,onBeforeLeave=props.onBeforeLeave,onLeave=props.onLeave,onAfterLeave=props.onAfterLeave,onLeaveCancelled=props.onLeaveCancelled,onBeforeAppear=props.onBeforeAppear,onAppear=props.onAppear,onAfterAppear=props.onAfterAppear,onAppearCancelled=props.onAppearCancelled;var key=String(vnode.key);var leavingVNodesCache=getLeavingNodesForType(state,vnode);var callHook=function callHook(hook,args){hook&&callWithAsyncErrorHandling(hook,instance,9/* TRANSITION_HOOK */,args);};var hooks={mode:mode,persisted:persisted,beforeEnter:function beforeEnter(el){var hook=onBeforeEnter;if(!state.isMounted){if(appear){hook=onBeforeAppear||onBeforeEnter;}else{return;}}// for same element (v-show)
if(el._leaveCb){el._leaveCb(true/* cancelled */);}// for toggled element with same key (v-if)
var leavingVNode=leavingVNodesCache[key];if(leavingVNode&&isSameVNodeType(vnode,leavingVNode)&&leavingVNode.el._leaveCb){// force early removal (not cancelled)
leavingVNode.el._leaveCb();}callHook(hook,[el]);},enter:function enter(el){var hook=onEnter;var afterHook=onAfterEnter;var cancelHook=onEnterCancelled;if(!state.isMounted){if(appear){hook=onAppear||onEnter;afterHook=onAfterAppear||onAfterEnter;cancelHook=onAppearCancelled||onEnterCancelled;}else{return;}}var called=false;var done=el._enterCb=function(cancelled){if(called)return;called=true;if(cancelled){callHook(cancelHook,[el]);}else{callHook(afterHook,[el]);}if(hooks.delayedLeave){hooks.delayedLeave();}el._enterCb=undefined;};if(hook){hook(el,done);if(hook.length<=1){done();}}else{done();}},leave:function leave(el,remove){var key=String(vnode.key);if(el._enterCb){el._enterCb(true/* cancelled */);}if(state.isUnmounting){return remove();}callHook(onBeforeLeave,[el]);var called=false;var done=el._leaveCb=function(cancelled){if(called)return;called=true;remove();if(cancelled){callHook(onLeaveCancelled,[el]);}else{callHook(onAfterLeave,[el]);}el._leaveCb=undefined;if(leavingVNodesCache[key]===vnode){delete leavingVNodesCache[key];}};leavingVNodesCache[key]=vnode;if(onLeave){onLeave(el,done);if(onLeave.length<=1){done();}}else{done();}},clone:function clone(vnode){return resolveTransitionHooks(vnode,props,state,instance);}};return hooks;}// the placeholder really only handles one special case: KeepAlive
// in the case of a KeepAlive in a leave phase we need to return a KeepAlive
// placeholder with empty content to avoid the KeepAlive instance from being
// unmounted.
function emptyPlaceholder(vnode){if(isKeepAlive(vnode)){vnode=cloneVNode(vnode);vnode.children=null;return vnode;}}function getKeepAliveChild(vnode){return isKeepAlive(vnode)?vnode.children?vnode.children[0]:undefined:vnode;}function setTransitionHooks(vnode,hooks){if(vnode.shapeFlag&6/* COMPONENT */&&vnode.component){setTransitionHooks(vnode.component.subTree,hooks);}else if(vnode.shapeFlag&128/* SUSPENSE */){vnode.ssContent.transition=hooks.clone(vnode.ssContent);vnode.ssFallback.transition=hooks.clone(vnode.ssFallback);}else{vnode.transition=hooks;}}function getTransitionRawChildren(children){var keepComment=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var ret=[];var keyedFragmentCount=0;for(var i=0;i<children.length;i++){var child=children[i];// handle fragment children case, e.g. v-for
if(child.type===Fragment){if(child.patchFlag&128/* KEYED_FRAGMENT */)keyedFragmentCount++;ret=ret.concat(getTransitionRawChildren(child.children,keepComment));}// comment placeholders should be skipped, e.g. v-if
else if(keepComment||child.type!==Comment){ret.push(child);}}// #1126 if a transition children list contains multiple sub fragments, these
// fragments will be merged into a flat children array. Since each v-for
// fragment may contain different static bindings inside, we need to de-op
// these children to force full diffs to ensure correct behavior.
if(keyedFragmentCount>1){for(var _i2=0;_i2<ret.length;_i2++){ret[_i2].patchFlag=-2/* BAIL */;}}return ret;}// implementation, close to no-op
function defineComponent(options){return isFunction(options)?{setup:options,name:options.name}:options;}var isAsyncWrapper=function isAsyncWrapper(i){return!!i.type.__asyncLoader;};function defineAsyncComponent(source){if(isFunction(source)){source={loader:source};}var _source=source,loader=_source.loader,loadingComponent=_source.loadingComponent,errorComponent=_source.errorComponent,_source$delay=_source.delay,delay=_source$delay===void 0?200:_source$delay,timeout=_source.timeout,_source$suspensible=_source.suspensible,suspensible=_source$suspensible===void 0?true:_source$suspensible,userOnError=_source.onError;var pendingRequest=null;var resolvedComp;var retries=0;var retry=function retry(){retries++;pendingRequest=null;return load();};var load=function load(){var thisRequest;return pendingRequest||(thisRequest=pendingRequest=loader().catch(function(err){err=err instanceof Error?err:new Error(String(err));if(userOnError){return new Promise(function(resolve,reject){var userRetry=function userRetry(){return resolve(retry());};var userFail=function userFail(){return reject(err);};userOnError(err,userRetry,userFail,retries+1);});}else{throw err;}}).then(function(comp){if(thisRequest!==pendingRequest&&pendingRequest){return pendingRequest;}if(!comp){warn$1("Async component loader resolved to undefined. "+"If you are using retry(), make sure to return its return value.");}// interop module default
if(comp&&(comp.__esModule||comp[Symbol.toStringTag]==='Module')){comp=comp.default;}if(comp&&!isObject(comp)&&!isFunction(comp)){throw new Error("Invalid async component load result: ".concat(comp));}resolvedComp=comp;return comp;}));};return defineComponent({name:'AsyncComponentWrapper',__asyncLoader:load,get __asyncResolved(){return resolvedComp;},setup:function setup(){var instance=currentInstance;// already resolved
if(resolvedComp){return function(){return createInnerComp(resolvedComp,instance);};}var onError=function onError(err){pendingRequest=null;handleError(err,instance,13/* ASYNC_COMPONENT_LOADER */,!errorComponent/* do not throw in dev if user provided error component */);};// suspense-controlled or SSR.
if(suspensible&&instance.suspense||false){return load().then(function(comp){return function(){return createInnerComp(comp,instance);};}).catch(function(err){onError(err);return function(){return errorComponent?createVNode(errorComponent,{error:err}):null;};});}var loaded=ref(false);var error=ref();var delayed=ref(!!delay);if(delay){setTimeout(function(){delayed.value=false;},delay);}if(timeout!=null){setTimeout(function(){if(!loaded.value&&!error.value){var err=new Error("Async component timed out after ".concat(timeout,"ms."));onError(err);error.value=err;}},timeout);}load().then(function(){loaded.value=true;if(instance.parent&&isKeepAlive(instance.parent.vnode)){// parent is keep-alive, force update so the loaded component's
// name is taken into account
queueJob(instance.parent.update);}}).catch(function(err){onError(err);error.value=err;});return function(){if(loaded.value&&resolvedComp){return createInnerComp(resolvedComp,instance);}else if(error.value&&errorComponent){return createVNode(errorComponent,{error:error.value});}else if(loadingComponent&&!delayed.value){return createVNode(loadingComponent);}};}});}function createInnerComp(comp,_ref15){var _ref15$vnode=_ref15.vnode,ref=_ref15$vnode.ref,props=_ref15$vnode.props,children=_ref15$vnode.children;var vnode=createVNode(comp,props,children);// ensure inner component inherits the async wrapper's ref owner
vnode.ref=ref;return vnode;}var isKeepAlive=function isKeepAlive(vnode){return vnode.type.__isKeepAlive;};var KeepAliveImpl={name:"KeepAlive",// Marker for special handling inside the renderer. We are not using a ===
// check directly on KeepAlive in the renderer, because importing it directly
// would prevent it from being tree-shaken.
__isKeepAlive:true,props:{include:[String,RegExp,Array],exclude:[String,RegExp,Array],max:[String,Number]},setup:function setup(props,_ref16){var slots=_ref16.slots;var instance=getCurrentInstance();// KeepAlive communicates with the instantiated renderer via the
// ctx where the renderer passes in its internals,
// and the KeepAlive instance exposes activate/deactivate implementations.
// The whole point of this is to avoid importing KeepAlive directly in the
// renderer to facilitate tree-shaking.
var sharedContext=instance.ctx;// if the internal renderer is not registered, it indicates that this is server-side rendering,
// for KeepAlive, we just need to render its children
if(!sharedContext.renderer){return slots.default;}var cache=new Map();var keys=new Set();var current=null;{instance.__v_cache=cache;}var parentSuspense=instance.suspense;var _sharedContext$render=sharedContext.renderer,patch=_sharedContext$render.p,move=_sharedContext$render.m,_unmount=_sharedContext$render.um,createElement=_sharedContext$render.o.createElement;var storageContainer=createElement('div');sharedContext.activate=function(vnode,container,anchor,isSVG,optimized){var instance=vnode.component;move(vnode,container,anchor,0/* ENTER */,parentSuspense);// in case props have changed
patch(instance.vnode,vnode,container,anchor,instance,parentSuspense,isSVG,vnode.slotScopeIds,optimized);queuePostRenderEffect(function(){instance.isDeactivated=false;if(instance.a){invokeArrayFns(instance.a);}var vnodeHook=vnode.props&&vnode.props.onVnodeMounted;if(vnodeHook){invokeVNodeHook(vnodeHook,instance.parent,vnode);}},parentSuspense);{// Update components tree
devtoolsComponentAdded(instance);}};sharedContext.deactivate=function(vnode){var instance=vnode.component;move(vnode,storageContainer,null,1/* LEAVE */,parentSuspense);queuePostRenderEffect(function(){if(instance.da){invokeArrayFns(instance.da);}var vnodeHook=vnode.props&&vnode.props.onVnodeUnmounted;if(vnodeHook){invokeVNodeHook(vnodeHook,instance.parent,vnode);}instance.isDeactivated=true;},parentSuspense);{// Update components tree
devtoolsComponentAdded(instance);}};function unmount(vnode){// reset the shapeFlag so it can be properly unmounted
resetShapeFlag(vnode);_unmount(vnode,instance,parentSuspense,true);}function pruneCache(filter){cache.forEach(function(vnode,key){var name=getComponentName(vnode.type);if(name&&(!filter||!filter(name))){pruneCacheEntry(key);}});}function pruneCacheEntry(key){var cached=cache.get(key);if(!current||cached.type!==current.type){unmount(cached);}else if(current){// current active instance should no longer be kept-alive.
// we can't unmount it now but it might be later, so reset its flag now.
resetShapeFlag(current);}cache.delete(key);keys.delete(key);}// prune cache on include/exclude prop change
watch(function(){return[props.include,props.exclude];},function(_ref17){var _ref18=_slicedToArray(_ref17,2),include=_ref18[0],exclude=_ref18[1];include&&pruneCache(function(name){return matches(include,name);});exclude&&pruneCache(function(name){return!matches(exclude,name);});},// prune post-render after `current` has been updated
{flush:'post',deep:true});// cache sub tree after render
var pendingCacheKey=null;var cacheSubtree=function cacheSubtree(){// fix #1621, the pendingCacheKey could be 0
if(pendingCacheKey!=null){cache.set(pendingCacheKey,getInnerChild(instance.subTree));}};onMounted(cacheSubtree);onUpdated(cacheSubtree);onBeforeUnmount(function(){cache.forEach(function(cached){var subTree=instance.subTree,suspense=instance.suspense;var vnode=getInnerChild(subTree);if(cached.type===vnode.type){// current instance will be unmounted as part of keep-alive's unmount
resetShapeFlag(vnode);// but invoke its deactivated hook here
var da=vnode.component.da;da&&queuePostRenderEffect(da,suspense);return;}unmount(cached);});});return function(){pendingCacheKey=null;if(!slots.default){return null;}var children=slots.default();var rawVNode=children[0];if(children.length>1){{warn$1("KeepAlive should contain exactly one component child.");}current=null;return children;}else if(!isVNode(rawVNode)||!(rawVNode.shapeFlag&4/* STATEFUL_COMPONENT */)&&!(rawVNode.shapeFlag&128/* SUSPENSE */)){current=null;return rawVNode;}var vnode=getInnerChild(rawVNode);var comp=vnode.type;// for async components, name check should be based in its loaded
// inner component if available
var name=getComponentName(isAsyncWrapper(vnode)?vnode.type.__asyncResolved||{}:comp);var include=props.include,exclude=props.exclude,max=props.max;if(include&&(!name||!matches(include,name))||exclude&&name&&matches(exclude,name)){current=vnode;return rawVNode;}var key=vnode.key==null?comp:vnode.key;var cachedVNode=cache.get(key);// clone vnode if it's reused because we are going to mutate it
if(vnode.el){vnode=cloneVNode(vnode);if(rawVNode.shapeFlag&128/* SUSPENSE */){rawVNode.ssContent=vnode;}}// #1513 it's possible for the returned vnode to be cloned due to attr
// fallthrough or scopeId, so the vnode here may not be the final vnode
// that is mounted. Instead of caching it directly, we store the pending
// key and cache `instance.subTree` (the normalized vnode) in
// beforeMount/beforeUpdate hooks.
pendingCacheKey=key;if(cachedVNode){// copy over mounted state
vnode.el=cachedVNode.el;vnode.component=cachedVNode.component;if(vnode.transition){// recursively update transition hooks on subTree
setTransitionHooks(vnode,vnode.transition);}// avoid vnode being mounted as fresh
vnode.shapeFlag|=512/* COMPONENT_KEPT_ALIVE */;// make this key the freshest
keys.delete(key);keys.add(key);}else{keys.add(key);// prune oldest entry
if(max&&keys.size>parseInt(max,10)){pruneCacheEntry(keys.values().next().value);}}// avoid vnode being unmounted
vnode.shapeFlag|=256/* COMPONENT_SHOULD_KEEP_ALIVE */;current=vnode;return rawVNode;};}};// export the public type for h/tsx inference
// also to avoid inline import() in generated d.ts files
var KeepAlive=KeepAliveImpl;function matches(pattern,name){if(isArray(pattern)){return pattern.some(function(p){return matches(p,name);});}else if(isString(pattern)){return pattern.split(',').includes(name);}else if(pattern.test){return pattern.test(name);}/* istanbul ignore next */return false;}function onActivated(hook,target){registerKeepAliveHook(hook,"a"/* ACTIVATED */,target);}function onDeactivated(hook,target){registerKeepAliveHook(hook,"da"/* DEACTIVATED */,target);}function registerKeepAliveHook(hook,type){var target=arguments.length>2&&arguments[2]!==undefined?arguments[2]:currentInstance;// cache the deactivate branch check wrapper for injected hooks so the same
// hook can be properly deduped by the scheduler. "__wdc" stands for "with
// deactivation check".
var wrappedHook=hook.__wdc||(hook.__wdc=function(){// only fire the hook if the target instance is NOT in a deactivated branch.
var current=target;while(current){if(current.isDeactivated){return;}current=current.parent;}return hook();});injectHook(type,wrappedHook,target);// In addition to registering it on the target instance, we walk up the parent
// chain and register it on all ancestor instances that are keep-alive roots.
// This avoids the need to walk the entire component tree when invoking these
// hooks, and more importantly, avoids the need to track child components in
// arrays.
if(target){var current=target.parent;while(current&&current.parent){if(isKeepAlive(current.parent.vnode)){injectToKeepAliveRoot(wrappedHook,type,target,current);}current=current.parent;}}}function injectToKeepAliveRoot(hook,type,target,keepAliveRoot){// injectHook wraps the original for error handling, so make sure to remove
// the wrapped version.
var injected=injectHook(type,hook,keepAliveRoot,true/* prepend */);onUnmounted(function(){remove(keepAliveRoot[type],injected);},target);}function resetShapeFlag(vnode){var shapeFlag=vnode.shapeFlag;if(shapeFlag&256/* COMPONENT_SHOULD_KEEP_ALIVE */){shapeFlag-=256/* COMPONENT_SHOULD_KEEP_ALIVE */;}if(shapeFlag&512/* COMPONENT_KEPT_ALIVE */){shapeFlag-=512/* COMPONENT_KEPT_ALIVE */;}vnode.shapeFlag=shapeFlag;}function getInnerChild(vnode){return vnode.shapeFlag&128/* SUSPENSE */?vnode.ssContent:vnode;}function injectHook(type,hook){var target=arguments.length>2&&arguments[2]!==undefined?arguments[2]:currentInstance;var prepend=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;if(target){var hooks=target[type]||(target[type]=[]);// cache the error handling wrapper for injected hooks so the same hook
// can be properly deduped by the scheduler. "__weh" stands for "with error
// handling".
var wrappedHook=hook.__weh||(hook.__weh=function(){if(target.isUnmounted){return;}// disable tracking inside all lifecycle hooks
// since they can potentially be called inside effects.
pauseTracking();// Set currentInstance during hook invocation.
// This assumes the hook does not synchronously trigger other hooks, which
// can only be false when the user does something really funky.
setCurrentInstance(target);for(var _len7=arguments.length,args=new Array(_len7),_key8=0;_key8<_len7;_key8++){args[_key8]=arguments[_key8];}var res=callWithAsyncErrorHandling(hook,target,type,args);unsetCurrentInstance();resetTracking();return res;});if(prepend){hooks.unshift(wrappedHook);}else{hooks.push(wrappedHook);}return wrappedHook;}else{var apiName=toHandlerKey(ErrorTypeStrings[type].replace(/ hook$/,''));warn$1("".concat(apiName," is called when there is no active component instance to be ")+"associated with. "+"Lifecycle injection APIs can only be used during execution of setup()."+(" If you are using async setup(), make sure to register lifecycle "+"hooks before the first await statement."));}}var createHook=function createHook(lifecycle){return function(hook){var target=arguments.length>1&&arguments[1]!==undefined?arguments[1]:currentInstance;return(// post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
(!isInSSRComponentSetup||lifecycle==="sp"/* SERVER_PREFETCH */)&&injectHook(lifecycle,hook,target));};};var onBeforeMount=createHook("bm"/* BEFORE_MOUNT */);var onMounted=createHook("m"/* MOUNTED */);var onBeforeUpdate=createHook("bu"/* BEFORE_UPDATE */);var onUpdated=createHook("u"/* UPDATED */);var onBeforeUnmount=createHook("bum"/* BEFORE_UNMOUNT */);var onUnmounted=createHook("um"/* UNMOUNTED */);var onServerPrefetch=createHook("sp"/* SERVER_PREFETCH */);var onRenderTriggered=createHook("rtg"/* RENDER_TRIGGERED */);var onRenderTracked=createHook("rtc"/* RENDER_TRACKED */);function onErrorCaptured(hook){var target=arguments.length>1&&arguments[1]!==undefined?arguments[1]:currentInstance;injectHook("ec"/* ERROR_CAPTURED */,hook,target);}function createDuplicateChecker(){var cache=Object.create(null);return function(type,key){if(cache[key]){warn$1("".concat(type," property \"").concat(key,"\" is already defined in ").concat(cache[key],"."));}else{cache[key]=type;}};}var shouldCacheAccess=true;function applyOptions(instance){var options=resolveMergedOptions(instance);var publicThis=instance.proxy;var ctx=instance.ctx;// do not cache property access on public proxy during state initialization
shouldCacheAccess=false;// call beforeCreate first before accessing other options since
// the hook may mutate resolved options (#2791)
if(options.beforeCreate){callHook(options.beforeCreate,instance,"bc"/* BEFORE_CREATE */);}var dataOptions=options.data,computedOptions=options.computed,methods=options.methods,watchOptions=options.watch,provideOptions=options.provide,injectOptions=options.inject,created=options.created,beforeMount=options.beforeMount,mounted=options.mounted,beforeUpdate=options.beforeUpdate,updated=options.updated,activated=options.activated,deactivated=options.deactivated,beforeDestroy=options.beforeDestroy,beforeUnmount=options.beforeUnmount,destroyed=options.destroyed,unmounted=options.unmounted,render=options.render,renderTracked=options.renderTracked,renderTriggered=options.renderTriggered,errorCaptured=options.errorCaptured,serverPrefetch=options.serverPrefetch,expose=options.expose,inheritAttrs=options.inheritAttrs,components=options.components,directives=options.directives,filters=options.filters;var checkDuplicateProperties=createDuplicateChecker();{var _instance$propsOption3=_slicedToArray(instance.propsOptions,1),propsOptions=_instance$propsOption3[0];if(propsOptions){for(var key in propsOptions){checkDuplicateProperties("Props"/* PROPS */,key);}}}// options initialization order (to be consistent with Vue 2):
// - props (already done outside of this function)
// - inject
// - methods
// - data (deferred since it relies on `this` access)
// - computed
// - watch (deferred since it relies on `this` access)
if(injectOptions){resolveInjections(injectOptions,ctx,checkDuplicateProperties,instance.appContext.config.unwrapInjectedRef);}if(methods){for(var _key9 in methods){var methodHandler=methods[_key9];if(isFunction(methodHandler)){// In dev mode, we use the `createRenderContext` function to define
// methods to the proxy target, and those are read-only but
// reconfigurable, so it needs to be redefined here
{Object.defineProperty(ctx,_key9,{value:methodHandler.bind(publicThis),configurable:true,enumerable:true,writable:true});}{checkDuplicateProperties("Methods"/* METHODS */,_key9);}}else{warn$1("Method \"".concat(_key9,"\" has type \"").concat(_typeof(methodHandler),"\" in the component definition. ")+"Did you reference the function correctly?");}}}if(dataOptions){(function(){if(!isFunction(dataOptions)){warn$1("The data option must be a function. "+"Plain object usage is no longer supported.");}var data=dataOptions.call(publicThis,publicThis);if(isPromise(data)){warn$1("data() returned a Promise - note data() cannot be async; If you "+"intend to perform data fetching before component renders, use "+"async setup() + <Suspense>.");}if(!isObject(data)){warn$1("data() should return an object.");}else{instance.data=reactive(data);{var _loop=function _loop(_key10){checkDuplicateProperties("Data"/* DATA */,_key10);// expose data on ctx during dev
if(_key10[0]!=='$'&&_key10[0]!=='_'){Object.defineProperty(ctx,_key10,{configurable:true,enumerable:true,get:function get(){return data[_key10];},set:NOOP});}};for(var _key10 in data){_loop(_key10);}}}})();}// state initialization complete at this point - start caching access
shouldCacheAccess=true;if(computedOptions){var _loop2=function _loop2(_key11){var opt=computedOptions[_key11];var get=isFunction(opt)?opt.bind(publicThis,publicThis):isFunction(opt.get)?opt.get.bind(publicThis,publicThis):NOOP;if(get===NOOP){warn$1("Computed property \"".concat(_key11,"\" has no getter."));}var set=!isFunction(opt)&&isFunction(opt.set)?opt.set.bind(publicThis):function(){warn$1("Write operation failed: computed property \"".concat(_key11,"\" is readonly."));};var c=computed$1({get:get,set:set});Object.defineProperty(ctx,_key11,{enumerable:true,configurable:true,get:function get(){return c.value;},set:function set(v){return c.value=v;}});{checkDuplicateProperties("Computed"/* COMPUTED */,_key11);}};for(var _key11 in computedOptions){_loop2(_key11);}}if(watchOptions){for(var _key12 in watchOptions){createWatcher(watchOptions[_key12],ctx,publicThis,_key12);}}if(provideOptions){var provides=isFunction(provideOptions)?provideOptions.call(publicThis):provideOptions;Reflect.ownKeys(provides).forEach(function(key){provide(key,provides[key]);});}if(created){callHook(created,instance,"c"/* CREATED */);}function registerLifecycleHook(register,hook){if(isArray(hook)){hook.forEach(function(_hook){return register(_hook.bind(publicThis));});}else if(hook){register(hook.bind(publicThis));}}registerLifecycleHook(onBeforeMount,beforeMount);registerLifecycleHook(onMounted,mounted);registerLifecycleHook(onBeforeUpdate,beforeUpdate);registerLifecycleHook(onUpdated,updated);registerLifecycleHook(onActivated,activated);registerLifecycleHook(onDeactivated,deactivated);registerLifecycleHook(onErrorCaptured,errorCaptured);registerLifecycleHook(onRenderTracked,renderTracked);registerLifecycleHook(onRenderTriggered,renderTriggered);registerLifecycleHook(onBeforeUnmount,beforeUnmount);registerLifecycleHook(onUnmounted,unmounted);registerLifecycleHook(onServerPrefetch,serverPrefetch);if(isArray(expose)){if(expose.length){var exposed=instance.exposed||(instance.exposed={});expose.forEach(function(key){Object.defineProperty(exposed,key,{get:function get(){return publicThis[key];},set:function set(val){return publicThis[key]=val;}});});}else if(!instance.exposed){instance.exposed={};}}// options that are handled when creating the instance but also need to be
// applied from mixins
if(render&&instance.render===NOOP){instance.render=render;}if(inheritAttrs!=null){instance.inheritAttrs=inheritAttrs;}// asset options.
if(components)instance.components=components;if(directives)instance.directives=directives;}function resolveInjections(injectOptions,ctx){var checkDuplicateProperties=arguments.length>2&&arguments[2]!==undefined?arguments[2]:NOOP;var unwrapRef=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;if(isArray(injectOptions)){injectOptions=normalizeInject(injectOptions);}var _loop3=function _loop3(key){var opt=injectOptions[key];var injected=void 0;if(isObject(opt)){if('default'in opt){injected=inject(opt.from||key,opt.default,true/* treat default function as factory */);}else{injected=inject(opt.from||key);}}else{injected=inject(opt);}if(isRef(injected)){// TODO remove the check in 3.3
if(unwrapRef){Object.defineProperty(ctx,key,{enumerable:true,configurable:true,get:function get(){return injected.value;},set:function set(v){return injected.value=v;}});}else{{warn$1("injected property \"".concat(key,"\" is a ref and will be auto-unwrapped ")+"and no longer needs `.value` in the next minor release. "+"To opt-in to the new behavior now, "+"set `app.config.unwrapInjectedRef = true` (this config is "+"temporary and will not be needed in the future.)");}ctx[key]=injected;}}else{ctx[key]=injected;}{checkDuplicateProperties("Inject"/* INJECT */,key);}};for(var key in injectOptions){_loop3(key);}}function callHook(hook,instance,type){callWithAsyncErrorHandling(isArray(hook)?hook.map(function(h){return h.bind(instance.proxy);}):hook.bind(instance.proxy),instance,type);}function createWatcher(raw,ctx,publicThis,key){var getter=key.includes('.')?createPathGetter(publicThis,key):function(){return publicThis[key];};if(isString(raw)){var handler=ctx[raw];if(isFunction(handler)){watch(getter,handler);}else{warn$1("Invalid watch handler specified by key \"".concat(raw,"\""),handler);}}else if(isFunction(raw)){watch(getter,raw.bind(publicThis));}else if(isObject(raw)){if(isArray(raw)){raw.forEach(function(r){return createWatcher(r,ctx,publicThis,key);});}else{var _handler=isFunction(raw.handler)?raw.handler.bind(publicThis):ctx[raw.handler];if(isFunction(_handler)){watch(getter,_handler,raw);}else{warn$1("Invalid watch handler specified by key \"".concat(raw.handler,"\""),_handler);}}}else{warn$1("Invalid watch option: \"".concat(key,"\""),raw);}}/**
 * Resolve merged options and cache it on the component.
 * This is done only once per-component since the merging does not involve
 * instances.
 */function resolveMergedOptions(instance){var base=instance.type;var mixins=base.mixins,extendsOptions=base.extends;var _instance$appContext=instance.appContext,globalMixins=_instance$appContext.mixins,cache=_instance$appContext.optionsCache,optionMergeStrategies=_instance$appContext.config.optionMergeStrategies;var cached=cache.get(base);var resolved;if(cached){resolved=cached;}else if(!globalMixins.length&&!mixins&&!extendsOptions){{resolved=base;}}else{resolved={};if(globalMixins.length){globalMixins.forEach(function(m){return mergeOptions(resolved,m,optionMergeStrategies,true);});}mergeOptions(resolved,base,optionMergeStrategies);}cache.set(base,resolved);return resolved;}function mergeOptions(to,from,strats){var asMixin=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var mixins=from.mixins,extendsOptions=from.extends;if(extendsOptions){mergeOptions(to,extendsOptions,strats,true);}if(mixins){mixins.forEach(function(m){return mergeOptions(to,m,strats,true);});}for(var key in from){if(asMixin&&key==='expose'){warn$1("\"expose\" option is ignored when declared in mixins or extends. "+"It should only be declared in the base component itself.");}else{var strat=internalOptionMergeStrats[key]||strats&&strats[key];to[key]=strat?strat(to[key],from[key]):from[key];}}return to;}var internalOptionMergeStrats={data:mergeDataFn,props:mergeObjectOptions,emits:mergeObjectOptions,// objects
methods:mergeObjectOptions,computed:mergeObjectOptions,// lifecycle
beforeCreate:mergeAsArray,created:mergeAsArray,beforeMount:mergeAsArray,mounted:mergeAsArray,beforeUpdate:mergeAsArray,updated:mergeAsArray,beforeDestroy:mergeAsArray,beforeUnmount:mergeAsArray,destroyed:mergeAsArray,unmounted:mergeAsArray,activated:mergeAsArray,deactivated:mergeAsArray,errorCaptured:mergeAsArray,serverPrefetch:mergeAsArray,// assets
components:mergeObjectOptions,directives:mergeObjectOptions,// watch
watch:mergeWatchOptions,// provide / inject
provide:mergeDataFn,inject:mergeInject};function mergeDataFn(to,from){if(!from){return to;}if(!to){return from;}return function mergedDataFn(){return extend(isFunction(to)?to.call(this,this):to,isFunction(from)?from.call(this,this):from);};}function mergeInject(to,from){return mergeObjectOptions(normalizeInject(to),normalizeInject(from));}function normalizeInject(raw){if(isArray(raw)){var res={};for(var i=0;i<raw.length;i++){res[raw[i]]=raw[i];}return res;}return raw;}function mergeAsArray(to,from){return to?_toConsumableArray(new Set([].concat(to,from))):from;}function mergeObjectOptions(to,from){return to?extend(extend(Object.create(null),to),from):from;}function mergeWatchOptions(to,from){if(!to)return from;if(!from)return to;var merged=extend(Object.create(null),to);for(var key in from){merged[key]=mergeAsArray(to[key],from[key]);}return merged;}function initProps(instance,rawProps,isStateful){var isSSR=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var props={};var attrs={};def(attrs,InternalObjectKey,1);instance.propsDefaults=Object.create(null);setFullProps(instance,rawProps,props,attrs);// ensure all declared prop keys are present
for(var key in instance.propsOptions[0]){if(!(key in props)){props[key]=undefined;}}// validation
{validateProps(rawProps||{},props,instance);}if(isStateful){// stateful
instance.props=isSSR?props:shallowReactive(props);}else{if(!instance.type.props){// functional w/ optional props, props === attrs
instance.props=attrs;}else{// functional w/ declared props
instance.props=props;}}instance.attrs=attrs;}function updateProps(instance,rawProps,rawPrevProps,optimized){var props=instance.props,attrs=instance.attrs,patchFlag=instance.vnode.patchFlag;var rawCurrentProps=toRaw(props);var _instance$propsOption4=_slicedToArray(instance.propsOptions,1),options=_instance$propsOption4[0];var hasAttrsChanged=false;if(// always force full diff in dev
// - #1942 if hmr is enabled with sfc component
// - vite#872 non-sfc component used by sfc component
!(instance.type.__hmrId||instance.parent&&instance.parent.type.__hmrId)&&(optimized||patchFlag>0)&&!(patchFlag&16/* FULL_PROPS */)){if(patchFlag&8/* PROPS */){// Compiler-generated props & no keys change, just set the updated
// the props.
var propsToUpdate=instance.vnode.dynamicProps;for(var i=0;i<propsToUpdate.length;i++){var key=propsToUpdate[i];// PROPS flag guarantees rawProps to be non-null
var value=rawProps[key];if(options){// attr / props separation was done on init and will be consistent
// in this code path, so just check if attrs have it.
if(hasOwn(attrs,key)){if(value!==attrs[key]){attrs[key]=value;hasAttrsChanged=true;}}else{var camelizedKey=camelize(key);props[camelizedKey]=resolvePropValue(options,rawCurrentProps,camelizedKey,value,instance,false/* isAbsent */);}}else{if(value!==attrs[key]){attrs[key]=value;hasAttrsChanged=true;}}}}}else{// full props update.
if(setFullProps(instance,rawProps,props,attrs)){hasAttrsChanged=true;}// in case of dynamic props, check if we need to delete keys from
// the props object
var kebabKey;for(var _key13 in rawCurrentProps){if(!rawProps||// for camelCase
!hasOwn(rawProps,_key13)&&(// it's possible the original props was passed in as kebab-case
// and converted to camelCase (#955)
(kebabKey=hyphenate(_key13))===_key13||!hasOwn(rawProps,kebabKey))){if(options){if(rawPrevProps&&(// for camelCase
rawPrevProps[_key13]!==undefined||// for kebab-case
rawPrevProps[kebabKey]!==undefined)){props[_key13]=resolvePropValue(options,rawCurrentProps,_key13,undefined,instance,true/* isAbsent */);}}else{delete props[_key13];}}}// in the case of functional component w/o props declaration, props and
// attrs point to the same object so it should already have been updated.
if(attrs!==rawCurrentProps){for(var _key14 in attrs){if(!rawProps||!hasOwn(rawProps,_key14)&&!false){delete attrs[_key14];hasAttrsChanged=true;}}}}// trigger updates for $attrs in case it's used in component slots
if(hasAttrsChanged){trigger(instance,"set"/* SET */,'$attrs');}{validateProps(rawProps||{},props,instance);}}function setFullProps(instance,rawProps,props,attrs){var _instance$propsOption5=_slicedToArray(instance.propsOptions,2),options=_instance$propsOption5[0],needCastKeys=_instance$propsOption5[1];var hasAttrsChanged=false;var rawCastValues;if(rawProps){for(var key in rawProps){// key, ref are reserved and never passed down
if(isReservedProp(key)){continue;}var value=rawProps[key];// prop option names are camelized during normalization, so to support
// kebab -> camel conversion here we need to camelize the key.
var camelKey=void 0;if(options&&hasOwn(options,camelKey=camelize(key))){if(!needCastKeys||!needCastKeys.includes(camelKey)){props[camelKey]=value;}else{(rawCastValues||(rawCastValues={}))[camelKey]=value;}}else if(!isEmitListener(instance.emitsOptions,key)){if(!(key in attrs)||value!==attrs[key]){attrs[key]=value;hasAttrsChanged=true;}}}}if(needCastKeys){var rawCurrentProps=toRaw(props);var castValues=rawCastValues||EMPTY_OBJ;for(var i=0;i<needCastKeys.length;i++){var _key15=needCastKeys[i];props[_key15]=resolvePropValue(options,rawCurrentProps,_key15,castValues[_key15],instance,!hasOwn(castValues,_key15));}}return hasAttrsChanged;}function resolvePropValue(options,props,key,value,instance,isAbsent){var opt=options[key];if(opt!=null){var hasDefault=hasOwn(opt,'default');// default values
if(hasDefault&&value===undefined){var defaultValue=opt.default;if(opt.type!==Function&&isFunction(defaultValue)){var propsDefaults=instance.propsDefaults;if(key in propsDefaults){value=propsDefaults[key];}else{setCurrentInstance(instance);value=propsDefaults[key]=defaultValue.call(null,props);unsetCurrentInstance();}}else{value=defaultValue;}}// boolean casting
if(opt[0/* shouldCast */]){if(isAbsent&&!hasDefault){value=false;}else if(opt[1/* shouldCastTrue */]&&(value===''||value===hyphenate(key))){value=true;}}}return value;}function normalizePropsOptions(comp,appContext){var asMixin=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var cache=appContext.propsCache;var cached=cache.get(comp);if(cached){return cached;}var raw=comp.props;var normalized={};var needCastKeys=[];// apply mixin/extends props
var hasExtends=false;if(!isFunction(comp)){var extendProps=function extendProps(raw){hasExtends=true;var _normalizePropsOption=normalizePropsOptions(raw,appContext,true),_normalizePropsOption2=_slicedToArray(_normalizePropsOption,2),props=_normalizePropsOption2[0],keys=_normalizePropsOption2[1];extend(normalized,props);if(keys)needCastKeys.push.apply(needCastKeys,_toConsumableArray(keys));};if(!asMixin&&appContext.mixins.length){appContext.mixins.forEach(extendProps);}if(comp.extends){extendProps(comp.extends);}if(comp.mixins){comp.mixins.forEach(extendProps);}}if(!raw&&!hasExtends){cache.set(comp,EMPTY_ARR);return EMPTY_ARR;}if(isArray(raw)){for(var i=0;i<raw.length;i++){if(!isString(raw[i])){warn$1("props must be strings when using array syntax.",raw[i]);}var normalizedKey=camelize(raw[i]);if(validatePropName(normalizedKey)){normalized[normalizedKey]=EMPTY_OBJ;}}}else if(raw){if(!isObject(raw)){warn$1("invalid props options",raw);}for(var key in raw){var _normalizedKey=camelize(key);if(validatePropName(_normalizedKey)){var opt=raw[key];var prop=normalized[_normalizedKey]=isArray(opt)||isFunction(opt)?{type:opt}:opt;if(prop){var booleanIndex=getTypeIndex(Boolean,prop.type);var stringIndex=getTypeIndex(String,prop.type);prop[0/* shouldCast */]=booleanIndex>-1;prop[1/* shouldCastTrue */]=stringIndex<0||booleanIndex<stringIndex;// if the prop needs boolean casting or default value
if(booleanIndex>-1||hasOwn(prop,'default')){needCastKeys.push(_normalizedKey);}}}}}var res=[normalized,needCastKeys];cache.set(comp,res);return res;}function validatePropName(key){if(key[0]!=='$'){return true;}else{warn$1("Invalid prop name: \"".concat(key,"\" is a reserved property."));}return false;}// use function string name to check type constructors
// so that it works across vms / iframes.
function getType(ctor){var match=ctor&&ctor.toString().match(/^\s*function (\w+)/);return match?match[1]:ctor===null?'null':'';}function isSameType(a,b){return getType(a)===getType(b);}function getTypeIndex(type,expectedTypes){if(isArray(expectedTypes)){return expectedTypes.findIndex(function(t){return isSameType(t,type);});}else if(isFunction(expectedTypes)){return isSameType(expectedTypes,type)?0:-1;}return-1;}/**
 * dev only
 */function validateProps(rawProps,props,instance){var resolvedValues=toRaw(props);var options=instance.propsOptions[0];for(var key in options){var opt=options[key];if(opt==null)continue;validateProp(key,resolvedValues[key],opt,!hasOwn(rawProps,key)&&!hasOwn(rawProps,hyphenate(key)));}}/**
 * dev only
 */function validateProp(name,value,prop,isAbsent){var type=prop.type,required=prop.required,validator=prop.validator;// required!
if(required&&isAbsent){warn$1('Missing required prop: "'+name+'"');return;}// missing but optional
if(value==null&&!prop.required){return;}// type check
if(type!=null&&type!==true){var isValid=false;var types=isArray(type)?type:[type];var expectedTypes=[];// value is valid as long as one of the specified types match
for(var i=0;i<types.length&&!isValid;i++){var _assertType=assertType(value,types[i]),valid=_assertType.valid,expectedType=_assertType.expectedType;expectedTypes.push(expectedType||'');isValid=valid;}if(!isValid){warn$1(getInvalidTypeMessage(name,value,expectedTypes));return;}}// custom validator
if(validator&&!validator(value)){warn$1('Invalid prop: custom validator check failed for prop "'+name+'".');}}var isSimpleType=/*#__PURE__*/makeMap('String,Number,Boolean,Function,Symbol,BigInt');/**
 * dev only
 */function assertType(value,type){var valid;var expectedType=getType(type);if(isSimpleType(expectedType)){var t=_typeof(value);valid=t===expectedType.toLowerCase();// for primitive wrapper objects
if(!valid&&t==='object'){valid=value instanceof type;}}else if(expectedType==='Object'){valid=isObject(value);}else if(expectedType==='Array'){valid=isArray(value);}else if(expectedType==='null'){valid=value===null;}else{valid=value instanceof type;}return{valid:valid,expectedType:expectedType};}/**
 * dev only
 */function getInvalidTypeMessage(name,value,expectedTypes){var message="Invalid prop: type check failed for prop \"".concat(name,"\".")+" Expected ".concat(expectedTypes.map(capitalize).join(' | '));var expectedType=expectedTypes[0];var receivedType=toRawType(value);var expectedValue=styleValue(value,expectedType);var receivedValue=styleValue(value,receivedType);// check if we need to specify expected value
if(expectedTypes.length===1&&isExplicable(expectedType)&&!isBoolean(expectedType,receivedType)){message+=" with value ".concat(expectedValue);}message+=", got ".concat(receivedType," ");// check if we need to specify received value
if(isExplicable(receivedType)){message+="with value ".concat(receivedValue,".");}return message;}/**
 * dev only
 */function styleValue(value,type){if(type==='String'){return"\"".concat(value,"\"");}else if(type==='Number'){return"".concat(Number(value));}else{return"".concat(value);}}/**
 * dev only
 */function isExplicable(type){var explicitTypes=['string','number','boolean'];return explicitTypes.some(function(elem){return type.toLowerCase()===elem;});}/**
 * dev only
 */function isBoolean(){for(var _len8=arguments.length,args=new Array(_len8),_key16=0;_key16<_len8;_key16++){args[_key16]=arguments[_key16];}return args.some(function(elem){return elem.toLowerCase()==='boolean';});}var isInternalKey=function isInternalKey(key){return key[0]==='_'||key==='$stable';};var normalizeSlotValue=function normalizeSlotValue(value){return isArray(value)?value.map(normalizeVNode):[normalizeVNode(value)];};var normalizeSlot=function normalizeSlot(key,rawSlot,ctx){var normalized=withCtx(function(){if(currentInstance){warn$1("Slot \"".concat(key,"\" invoked outside of the render function: ")+"this will not track dependencies used in the slot. "+"Invoke the slot function inside the render function instead.");}return normalizeSlotValue(rawSlot.apply(void 0,arguments));},ctx);normalized._c=false;return normalized;};var normalizeObjectSlots=function normalizeObjectSlots(rawSlots,slots,instance){var ctx=rawSlots._ctx;for(var key in rawSlots){if(isInternalKey(key))continue;var value=rawSlots[key];if(isFunction(value)){slots[key]=normalizeSlot(key,value,ctx);}else if(value!=null){(function(){{warn$1("Non-function value encountered for slot \"".concat(key,"\". ")+"Prefer function slots for better performance.");}var normalized=normalizeSlotValue(value);slots[key]=function(){return normalized;};})();}}};var normalizeVNodeSlots=function normalizeVNodeSlots(instance,children){if(!isKeepAlive(instance.vnode)&&!false){warn$1("Non-function value encountered for default slot. "+"Prefer function slots for better performance.");}var normalized=normalizeSlotValue(children);instance.slots.default=function(){return normalized;};};var initSlots=function initSlots(instance,children){if(instance.vnode.shapeFlag&32/* SLOTS_CHILDREN */){var type=children._;if(type){// users can get the shallow readonly version of the slots object through `this.$slots`,
// we should avoid the proxy object polluting the slots of the internal instance
instance.slots=toRaw(children);// make compiler marker non-enumerable
def(children,'_',type);}else{normalizeObjectSlots(children,instance.slots={});}}else{instance.slots={};if(children){normalizeVNodeSlots(instance,children);}}def(instance.slots,InternalObjectKey,1);};var updateSlots=function updateSlots(instance,children,optimized){var vnode=instance.vnode,slots=instance.slots;var needDeletionCheck=true;var deletionComparisonTarget=EMPTY_OBJ;if(vnode.shapeFlag&32/* SLOTS_CHILDREN */){var type=children._;if(type){// compiled slots.
if(isHmrUpdating){// Parent was HMR updated so slot content may have changed.
// force update slots and mark instance for hmr as well
extend(slots,children);}else if(optimized&&type===1/* STABLE */){// compiled AND stable.
// no need to update, and skip stale slots removal.
needDeletionCheck=false;}else{// compiled but dynamic (v-if/v-for on slots) - update slots, but skip
// normalization.
extend(slots,children);// #2893
// when rendering the optimized slots by manually written render function,
// we need to delete the `slots._` flag if necessary to make subsequent updates reliable,
// i.e. let the `renderSlot` create the bailed Fragment
if(!optimized&&type===1/* STABLE */){delete slots._;}}}else{needDeletionCheck=!children.$stable;normalizeObjectSlots(children,slots);}deletionComparisonTarget=children;}else if(children){// non slot object children (direct value) passed to a component
normalizeVNodeSlots(instance,children);deletionComparisonTarget={default:1};}// delete stale slots
if(needDeletionCheck){for(var key in slots){if(!isInternalKey(key)&&!(key in deletionComparisonTarget)){delete slots[key];}}}};/**
Runtime helper for applying directives to a vnode. Example usage:

const comp = resolveComponent('comp')
const foo = resolveDirective('foo')
const bar = resolveDirective('bar')

return withDirectives(h(comp), [
  [foo, this.x],
  [bar, this.y]
])
*/function validateDirectiveName(name){if(isBuiltInDirective(name)){warn$1('Do not use built-in directive ids as custom directive id: '+name);}}/**
 * Adds directives to a VNode.
 */function withDirectives(vnode,directives){var internalInstance=currentRenderingInstance;if(internalInstance===null){warn$1("withDirectives can only be used inside render functions.");return vnode;}var instance=internalInstance.proxy;var bindings=vnode.dirs||(vnode.dirs=[]);for(var i=0;i<directives.length;i++){var _directives$i=_slicedToArray(directives[i],4),dir=_directives$i[0],value=_directives$i[1],arg=_directives$i[2],_directives$i$=_directives$i[3],modifiers=_directives$i$===void 0?EMPTY_OBJ:_directives$i$;if(isFunction(dir)){dir={mounted:dir,updated:dir};}if(dir.deep){traverse(value);}bindings.push({dir:dir,instance:instance,value:value,oldValue:void 0,arg:arg,modifiers:modifiers});}return vnode;}function invokeDirectiveHook(vnode,prevVNode,instance,name){var bindings=vnode.dirs;var oldBindings=prevVNode&&prevVNode.dirs;for(var i=0;i<bindings.length;i++){var binding=bindings[i];if(oldBindings){binding.oldValue=oldBindings[i].value;}var hook=binding.dir[name];if(hook){// disable tracking inside all lifecycle hooks
// since they can potentially be called inside effects.
pauseTracking();callWithAsyncErrorHandling(hook,instance,8/* DIRECTIVE_HOOK */,[vnode.el,binding,vnode,prevVNode]);resetTracking();}}}function createAppContext(){return{app:null,config:{isNativeTag:NO,performance:false,globalProperties:{},optionMergeStrategies:{},errorHandler:undefined,warnHandler:undefined,compilerOptions:{}},mixins:[],components:{},directives:{},provides:Object.create(null),optionsCache:new WeakMap(),propsCache:new WeakMap(),emitsCache:new WeakMap()};}var uid=0;function createAppAPI(render,hydrate){return function createApp(rootComponent){var rootProps=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(rootProps!=null&&!isObject(rootProps)){warn$1("root props passed to app.mount() must be an object.");rootProps=null;}var context=createAppContext();var installedPlugins=new Set();var isMounted=false;var app=context.app={_uid:uid++,_component:rootComponent,_props:rootProps,_container:null,_context:context,_instance:null,version:version,get config(){return context.config;},set config(v){{warn$1("app.config cannot be replaced. Modify individual options instead.");}},use:function use(plugin){for(var _len9=arguments.length,options=new Array(_len9>1?_len9-1:0),_key17=1;_key17<_len9;_key17++){options[_key17-1]=arguments[_key17];}if(installedPlugins.has(plugin)){warn$1("Plugin has already been applied to target app.");}else if(plugin&&isFunction(plugin.install)){installedPlugins.add(plugin);plugin.install.apply(plugin,[app].concat(options));}else if(isFunction(plugin)){installedPlugins.add(plugin);plugin.apply(void 0,[app].concat(options));}else{warn$1("A plugin must either be a function or an object with an \"install\" "+"function.");}return app;},mixin:function mixin(_mixin){{if(!context.mixins.includes(_mixin)){context.mixins.push(_mixin);}else{warn$1('Mixin has already been applied to target app'+(_mixin.name?": ".concat(_mixin.name):''));}}return app;},component:function component(name,_component){{validateComponentName(name,context.config);}if(!_component){return context.components[name];}if(context.components[name]){warn$1("Component \"".concat(name,"\" has already been registered in target app."));}context.components[name]=_component;return app;},directive:function directive(name,_directive){{validateDirectiveName(name);}if(!_directive){return context.directives[name];}if(context.directives[name]){warn$1("Directive \"".concat(name,"\" has already been registered in target app."));}context.directives[name]=_directive;return app;},mount:function mount(rootContainer,isHydrate,isSVG){if(!isMounted){var vnode=createVNode(rootComponent,rootProps);// store app context on the root VNode.
// this will be set on the root instance on initial mount.
vnode.appContext=context;// HMR root reload
{context.reload=function(){render(cloneVNode(vnode),rootContainer,isSVG);};}if(isHydrate&&hydrate){hydrate(vnode,rootContainer);}else{render(vnode,rootContainer,isSVG);}isMounted=true;app._container=rootContainer;rootContainer.__vue_app__=app;{app._instance=vnode.component;devtoolsInitApp(app,version);}return getExposeProxy(vnode.component)||vnode.component.proxy;}else{warn$1("App has already been mounted.\n"+"If you want to remount the same app, move your app creation logic "+"into a factory function and create fresh app instances for each "+"mount - e.g. `const createMyApp = () => createApp(App)`");}},unmount:function unmount(){if(isMounted){render(null,app._container);{app._instance=null;devtoolsUnmountApp(app);}delete app._container.__vue_app__;}else{warn$1("Cannot unmount an app that is not mounted.");}},provide:function provide(key,value){if(key in context.provides){warn$1("App already provides property with key \"".concat(String(key),"\". ")+"It will be overwritten with the new value.");}// TypeScript doesn't allow symbols as index type
// https://github.com/Microsoft/TypeScript/issues/24587
context.provides[key]=value;return app;}};return app;};}/**
 * Function for handling a template ref
 */function setRef(rawRef,oldRawRef,parentSuspense,vnode){var isUnmount=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;if(isArray(rawRef)){rawRef.forEach(function(r,i){return setRef(r,oldRawRef&&(isArray(oldRawRef)?oldRawRef[i]:oldRawRef),parentSuspense,vnode,isUnmount);});return;}if(isAsyncWrapper(vnode)&&!isUnmount){// when mounting async components, nothing needs to be done,
// because the template ref is forwarded to inner component
return;}var refValue=vnode.shapeFlag&4/* STATEFUL_COMPONENT */?getExposeProxy(vnode.component)||vnode.component.proxy:vnode.el;var value=isUnmount?null:refValue;var owner=rawRef.i,ref=rawRef.r;if(!owner){warn$1("Missing ref owner context. ref cannot be used on hoisted vnodes. "+"A vnode with ref must be created inside the render function.");return;}var oldRef=oldRawRef&&oldRawRef.r;var refs=owner.refs===EMPTY_OBJ?owner.refs={}:owner.refs;var setupState=owner.setupState;// dynamic ref changed. unset old ref
if(oldRef!=null&&oldRef!==ref){if(isString(oldRef)){refs[oldRef]=null;if(hasOwn(setupState,oldRef)){setupState[oldRef]=null;}}else if(isRef(oldRef)){oldRef.value=null;}}if(isFunction(ref)){callWithErrorHandling(ref,owner,12/* FUNCTION_REF */,[value,refs]);}else{var _isString=isString(ref);var _isRef=isRef(ref);if(_isString||_isRef){var doSet=function doSet(){if(rawRef.f){var existing=_isString?refs[ref]:ref.value;if(isUnmount){isArray(existing)&&remove(existing,refValue);}else{if(!isArray(existing)){if(_isString){refs[ref]=[refValue];}else{ref.value=[refValue];if(rawRef.k)refs[rawRef.k]=ref.value;}}else if(!existing.includes(refValue)){existing.push(refValue);}}}else if(_isString){refs[ref]=value;if(hasOwn(setupState,ref)){setupState[ref]=value;}}else if(isRef(ref)){ref.value=value;if(rawRef.k)refs[rawRef.k]=value;}else{warn$1('Invalid template ref type:',ref,"(".concat(_typeof(ref),")"));}};if(value){doSet.id=-1;queuePostRenderEffect(doSet,parentSuspense);}else{doSet();}}else{warn$1('Invalid template ref type:',ref,"(".concat(_typeof(ref),")"));}}}var hasMismatch=false;var isSVGContainer=function isSVGContainer(container){return /svg/.test(container.namespaceURI)&&container.tagName!=='foreignObject';};var isComment=function isComment(node){return node.nodeType===8;}/* COMMENT */;// Note: hydration is DOM-specific
// But we have to place it in core due to tight coupling with core - splitting
// it out creates a ton of unnecessary complexity.
// Hydration also depends on some renderer internal logic which needs to be
// passed in via arguments.
function createHydrationFunctions(rendererInternals){var mountComponent=rendererInternals.mt,patch=rendererInternals.p,_rendererInternals$o2=rendererInternals.o,patchProp=_rendererInternals$o2.patchProp,nextSibling=_rendererInternals$o2.nextSibling,parentNode=_rendererInternals$o2.parentNode,remove=_rendererInternals$o2.remove,insert=_rendererInternals$o2.insert,createComment=_rendererInternals$o2.createComment;var hydrate=function hydrate(vnode,container){if(!container.hasChildNodes()){warn$1("Attempting to hydrate existing markup but container is empty. "+"Performing full mount instead.");patch(null,vnode,container);flushPostFlushCbs();return;}hasMismatch=false;hydrateNode(container.firstChild,vnode,null,null,null);flushPostFlushCbs();if(hasMismatch&&!false){// this error should show up in production
console.error("Hydration completed but contains mismatches.");}};var hydrateNode=function hydrateNode(node,vnode,parentComponent,parentSuspense,slotScopeIds){var optimized=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;var isFragmentStart=isComment(node)&&node.data==='[';var onMismatch=function onMismatch(){return handleMismatch(node,vnode,parentComponent,parentSuspense,slotScopeIds,isFragmentStart);};var type=vnode.type,ref=vnode.ref,shapeFlag=vnode.shapeFlag;var domType=node.nodeType;vnode.el=node;var nextNode=null;switch(type){case Text:if(domType!==3/* TEXT */){nextNode=onMismatch();}else{if(node.data!==vnode.children){hasMismatch=true;warn$1("Hydration text mismatch:"+"\n- Client: ".concat(JSON.stringify(node.data))+"\n- Server: ".concat(JSON.stringify(vnode.children)));node.data=vnode.children;}nextNode=nextSibling(node);}break;case Comment:if(domType!==8/* COMMENT */||isFragmentStart){nextNode=onMismatch();}else{nextNode=nextSibling(node);}break;case Static:if(domType!==1/* ELEMENT */){nextNode=onMismatch();}else{// determine anchor, adopt content
nextNode=node;// if the static vnode has its content stripped during build,
// adopt it from the server-rendered HTML.
var needToAdoptContent=!vnode.children.length;for(var i=0;i<vnode.staticCount;i++){if(needToAdoptContent)vnode.children+=nextNode.outerHTML;if(i===vnode.staticCount-1){vnode.anchor=nextNode;}nextNode=nextSibling(nextNode);}return nextNode;}break;case Fragment:if(!isFragmentStart){nextNode=onMismatch();}else{nextNode=hydrateFragment(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized);}break;default:if(shapeFlag&1/* ELEMENT */){if(domType!==1/* ELEMENT */||vnode.type.toLowerCase()!==node.tagName.toLowerCase()){nextNode=onMismatch();}else{nextNode=hydrateElement(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized);}}else if(shapeFlag&6/* COMPONENT */){// when setting up the render effect, if the initial vnode already
// has .el set, the component will perform hydration instead of mount
// on its sub-tree.
vnode.slotScopeIds=slotScopeIds;var container=parentNode(node);mountComponent(vnode,container,null,parentComponent,parentSuspense,isSVGContainer(container),optimized);// component may be async, so in the case of fragments we cannot rely
// on component's rendered output to determine the end of the fragment
// instead, we do a lookahead to find the end anchor node.
nextNode=isFragmentStart?locateClosingAsyncAnchor(node):nextSibling(node);// #3787
// if component is async, it may get moved / unmounted before its
// inner component is loaded, so we need to give it a placeholder
// vnode that matches its adopted DOM.
if(isAsyncWrapper(vnode)){var subTree;if(isFragmentStart){subTree=createVNode(Fragment);subTree.anchor=nextNode?nextNode.previousSibling:container.lastChild;}else{subTree=node.nodeType===3?createTextVNode(''):createVNode('div');}subTree.el=node;vnode.component.subTree=subTree;}}else if(shapeFlag&64/* TELEPORT */){if(domType!==8/* COMMENT */){nextNode=onMismatch();}else{nextNode=vnode.type.hydrate(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized,rendererInternals,hydrateChildren);}}else if(shapeFlag&128/* SUSPENSE */){nextNode=vnode.type.hydrate(node,vnode,parentComponent,parentSuspense,isSVGContainer(parentNode(node)),slotScopeIds,optimized,rendererInternals,hydrateNode);}else{warn$1('Invalid HostVNode type:',type,"(".concat(_typeof(type),")"));}}if(ref!=null){setRef(ref,null,parentSuspense,vnode);}return nextNode;};var hydrateElement=function hydrateElement(el,vnode,parentComponent,parentSuspense,slotScopeIds,optimized){optimized=optimized||!!vnode.dynamicChildren;var type=vnode.type,props=vnode.props,patchFlag=vnode.patchFlag,shapeFlag=vnode.shapeFlag,dirs=vnode.dirs;// #4006 for form elements with non-string v-model value bindings
// e.g. <option :value="obj">, <input type="checkbox" :true-value="1">
var forcePatchValue=type==='input'&&dirs||type==='option';// skip props & children if this is hoisted static nodes
// #5405 in dev, always hydrate children for HMR
{if(dirs){invokeDirectiveHook(vnode,null,parentComponent,'created');}// props
if(props){if(forcePatchValue||!optimized||patchFlag&(16/* FULL_PROPS */|32/* HYDRATE_EVENTS */)){for(var key in props){if(forcePatchValue&&key.endsWith('value')||isOn(key)&&!isReservedProp(key)){patchProp(el,key,null,props[key],false,undefined,parentComponent);}}}else if(props.onClick){// Fast path for click listeners (which is most often) to avoid
// iterating through props.
patchProp(el,'onClick',null,props.onClick,false,undefined,parentComponent);}}// vnode / directive hooks
var vnodeHooks;if(vnodeHooks=props&&props.onVnodeBeforeMount){invokeVNodeHook(vnodeHooks,parentComponent,vnode);}if(dirs){invokeDirectiveHook(vnode,null,parentComponent,'beforeMount');}if((vnodeHooks=props&&props.onVnodeMounted)||dirs){queueEffectWithSuspense(function(){vnodeHooks&&invokeVNodeHook(vnodeHooks,parentComponent,vnode);dirs&&invokeDirectiveHook(vnode,null,parentComponent,'mounted');},parentSuspense);}// children
if(shapeFlag&16/* ARRAY_CHILDREN */&&// skip if element has innerHTML / textContent
!(props&&(props.innerHTML||props.textContent))){var next=hydrateChildren(el.firstChild,vnode,el,parentComponent,parentSuspense,slotScopeIds,optimized);var _hasWarned=false;while(next){hasMismatch=true;if(!_hasWarned){warn$1("Hydration children mismatch in <".concat(vnode.type,">: ")+"server rendered element contains more child nodes than client vdom.");_hasWarned=true;}// The SSRed DOM contains more nodes than it should. Remove them.
var cur=next;next=next.nextSibling;remove(cur);}}else if(shapeFlag&8/* TEXT_CHILDREN */){if(el.textContent!==vnode.children){hasMismatch=true;warn$1("Hydration text content mismatch in <".concat(vnode.type,">:\n")+"- Client: ".concat(el.textContent,"\n")+"- Server: ".concat(vnode.children));el.textContent=vnode.children;}}}return el.nextSibling;};var hydrateChildren=function hydrateChildren(node,parentVNode,container,parentComponent,parentSuspense,slotScopeIds,optimized){optimized=optimized||!!parentVNode.dynamicChildren;var children=parentVNode.children;var l=children.length;var hasWarned=false;for(var i=0;i<l;i++){var vnode=optimized?children[i]:children[i]=normalizeVNode(children[i]);if(node){node=hydrateNode(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized);}else if(vnode.type===Text&&!vnode.children){continue;}else{hasMismatch=true;if(!hasWarned){warn$1("Hydration children mismatch in <".concat(container.tagName.toLowerCase(),">: ")+"server rendered element contains fewer child nodes than client vdom.");hasWarned=true;}// the SSRed DOM didn't contain enough nodes. Mount the missing ones.
patch(null,vnode,container,null,parentComponent,parentSuspense,isSVGContainer(container),slotScopeIds);}}return node;};var hydrateFragment=function hydrateFragment(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized){var fragmentSlotScopeIds=vnode.slotScopeIds;if(fragmentSlotScopeIds){slotScopeIds=slotScopeIds?slotScopeIds.concat(fragmentSlotScopeIds):fragmentSlotScopeIds;}var container=parentNode(node);var next=hydrateChildren(nextSibling(node),vnode,container,parentComponent,parentSuspense,slotScopeIds,optimized);if(next&&isComment(next)&&next.data===']'){return nextSibling(vnode.anchor=next);}else{// fragment didn't hydrate successfully, since we didn't get a end anchor
// back. This should have led to node/children mismatch warnings.
hasMismatch=true;// since the anchor is missing, we need to create one and insert it
insert(vnode.anchor=createComment("]"),container,next);return next;}};var handleMismatch=function handleMismatch(node,vnode,parentComponent,parentSuspense,slotScopeIds,isFragment){hasMismatch=true;warn$1("Hydration node mismatch:\n- Client vnode:",vnode.type,"\n- Server rendered DOM:",node,node.nodeType===3/* TEXT */?"(text)":isComment(node)&&node.data==='['?"(start of fragment)":"");vnode.el=null;if(isFragment){// remove excessive fragment nodes
var end=locateClosingAsyncAnchor(node);while(true){var _next2=nextSibling(node);if(_next2&&_next2!==end){remove(_next2);}else{break;}}}var next=nextSibling(node);var container=parentNode(node);remove(node);patch(null,vnode,container,next,parentComponent,parentSuspense,isSVGContainer(container),slotScopeIds);return next;};var locateClosingAsyncAnchor=function locateClosingAsyncAnchor(node){var match=0;while(node){node=nextSibling(node);if(node&&isComment(node)){if(node.data==='[')match++;if(node.data===']'){if(match===0){return nextSibling(node);}else{match--;}}}}return node;};return[hydrate,hydrateNode];}/* eslint-disable no-restricted-globals */var supported;var perf;function startMeasure(instance,type){if(instance.appContext.config.performance&&isSupported()){perf.mark("vue-".concat(type,"-").concat(instance.uid));}{devtoolsPerfStart(instance,type,supported?perf.now():Date.now());}}function endMeasure(instance,type){if(instance.appContext.config.performance&&isSupported()){var startTag="vue-".concat(type,"-").concat(instance.uid);var endTag=startTag+":end";perf.mark(endTag);perf.measure("<".concat(formatComponentName(instance,instance.type),"> ").concat(type),startTag,endTag);perf.clearMarks(startTag);perf.clearMarks(endTag);}{devtoolsPerfEnd(instance,type,supported?perf.now():Date.now());}}function isSupported(){if(supported!==undefined){return supported;}if(typeof window!=='undefined'&&window.performance){supported=true;perf=window.performance;}else{supported=false;}return supported;}var queuePostRenderEffect=queueEffectWithSuspense;/**
 * The createRenderer function accepts two generic arguments:
 * HostNode and HostElement, corresponding to Node and Element types in the
 * host environment. For example, for runtime-dom, HostNode would be the DOM
 * `Node` interface and HostElement would be the DOM `Element` interface.
 *
 * Custom renderers can pass in the platform specific types like this:
 *
 * ``` js
 * const { render, createApp } = createRenderer<Node, Element>({
 *   patchProp,
 *   ...nodeOps
 * })
 * ```
 */function createRenderer(options){return baseCreateRenderer(options);}// Separate API for creating hydration-enabled renderer.
// Hydration logic is only used when calling this function, making it
// tree-shakable.
function createHydrationRenderer(options){return baseCreateRenderer(options,createHydrationFunctions);}// implementation
function baseCreateRenderer(options,createHydrationFns){var target=getGlobalThis();target.__VUE__=true;{setDevtoolsHook(target.__VUE_DEVTOOLS_GLOBAL_HOOK__,target);}var hostInsert=options.insert,hostRemove=options.remove,hostPatchProp=options.patchProp,hostCreateElement=options.createElement,hostCreateText=options.createText,hostCreateComment=options.createComment,hostSetText=options.setText,hostSetElementText=options.setElementText,hostParentNode=options.parentNode,hostNextSibling=options.nextSibling,_options$setScopeId=options.setScopeId,hostSetScopeId=_options$setScopeId===void 0?NOOP:_options$setScopeId,hostCloneNode=options.cloneNode,hostInsertStaticContent=options.insertStaticContent;// Note: functions inside this closure should use `const xxx = () => {}`
// style in order to prevent being inlined by minifiers.
var patch=function patch(n1,n2,container){var anchor=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;var parentComponent=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;var parentSuspense=arguments.length>5&&arguments[5]!==undefined?arguments[5]:null;var isSVG=arguments.length>6&&arguments[6]!==undefined?arguments[6]:false;var slotScopeIds=arguments.length>7&&arguments[7]!==undefined?arguments[7]:null;var optimized=arguments.length>8&&arguments[8]!==undefined?arguments[8]:isHmrUpdating?false:!!n2.dynamicChildren;if(n1===n2){return;}// patching & not same type, unmount old tree
if(n1&&!isSameVNodeType(n1,n2)){anchor=getNextHostNode(n1);unmount(n1,parentComponent,parentSuspense,true);n1=null;}if(n2.patchFlag===-2/* BAIL */){optimized=false;n2.dynamicChildren=null;}var type=n2.type,ref=n2.ref,shapeFlag=n2.shapeFlag;switch(type){case Text:processText(n1,n2,container,anchor);break;case Comment:processCommentNode(n1,n2,container,anchor);break;case Static:if(n1==null){mountStaticNode(n2,container,anchor,isSVG);}else{patchStaticNode(n1,n2,container,isSVG);}break;case Fragment:processFragment(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);break;default:if(shapeFlag&1/* ELEMENT */){processElement(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}else if(shapeFlag&6/* COMPONENT */){processComponent(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}else if(shapeFlag&64/* TELEPORT */){type.process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,internals);}else if(shapeFlag&128/* SUSPENSE */){type.process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,internals);}else{warn$1('Invalid VNode type:',type,"(".concat(_typeof(type),")"));}}// set ref
if(ref!=null&&parentComponent){setRef(ref,n1&&n1.ref,parentSuspense,n2||n1,!n2);}};var processText=function processText(n1,n2,container,anchor){if(n1==null){hostInsert(n2.el=hostCreateText(n2.children),container,anchor);}else{var el=n2.el=n1.el;if(n2.children!==n1.children){hostSetText(el,n2.children);}}};var processCommentNode=function processCommentNode(n1,n2,container,anchor){if(n1==null){hostInsert(n2.el=hostCreateComment(n2.children||''),container,anchor);}else{// there's no support for dynamic comments
n2.el=n1.el;}};var mountStaticNode=function mountStaticNode(n2,container,anchor,isSVG){var _hostInsertStaticCont=hostInsertStaticContent(n2.children,container,anchor,isSVG,n2.el,n2.anchor);var _hostInsertStaticCont2=_slicedToArray(_hostInsertStaticCont,2);n2.el=_hostInsertStaticCont2[0];n2.anchor=_hostInsertStaticCont2[1];};/**
     * Dev / HMR only
     */var patchStaticNode=function patchStaticNode(n1,n2,container,isSVG){// static nodes are only patched during dev for HMR
if(n2.children!==n1.children){var anchor=hostNextSibling(n1.anchor);// remove existing
removeStaticNode(n1);var _hostInsertStaticCont3=hostInsertStaticContent(n2.children,container,anchor,isSVG);var _hostInsertStaticCont4=_slicedToArray(_hostInsertStaticCont3,2);n2.el=_hostInsertStaticCont4[0];n2.anchor=_hostInsertStaticCont4[1];}else{n2.el=n1.el;n2.anchor=n1.anchor;}};var moveStaticNode=function moveStaticNode(_ref19,container,nextSibling){var el=_ref19.el,anchor=_ref19.anchor;var next;while(el&&el!==anchor){next=hostNextSibling(el);hostInsert(el,container,nextSibling);el=next;}hostInsert(anchor,container,nextSibling);};var removeStaticNode=function removeStaticNode(_ref20){var el=_ref20.el,anchor=_ref20.anchor;var next;while(el&&el!==anchor){next=hostNextSibling(el);hostRemove(el);el=next;}hostRemove(anchor);};var processElement=function processElement(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized){isSVG=isSVG||n2.type==='svg';if(n1==null){mountElement(n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}else{patchElement(n1,n2,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}};var mountElement=function mountElement(vnode,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized){var el;var vnodeHook;var type=vnode.type,props=vnode.props,shapeFlag=vnode.shapeFlag,transition=vnode.transition,patchFlag=vnode.patchFlag,dirs=vnode.dirs;{el=vnode.el=hostCreateElement(vnode.type,isSVG,props&&props.is,props);// mount children first, since some props may rely on child content
// being already rendered, e.g. `<select value>`
if(shapeFlag&8/* TEXT_CHILDREN */){hostSetElementText(el,vnode.children);}else if(shapeFlag&16/* ARRAY_CHILDREN */){mountChildren(vnode.children,el,null,parentComponent,parentSuspense,isSVG&&type!=='foreignObject',slotScopeIds,optimized);}if(dirs){invokeDirectiveHook(vnode,null,parentComponent,'created');}// props
if(props){for(var key in props){if(key!=='value'&&!isReservedProp(key)){hostPatchProp(el,key,null,props[key],isSVG,vnode.children,parentComponent,parentSuspense,unmountChildren);}}/**
                 * Special case for setting value on DOM elements:
                 * - it can be order-sensitive (e.g. should be set *after* min/max, #2325, #4024)
                 * - it needs to be forced (#1471)
                 * #2353 proposes adding another renderer option to configure this, but
                 * the properties affects are so finite it is worth special casing it
                 * here to reduce the complexity. (Special casing it also should not
                 * affect non-DOM renderers)
                 */if('value'in props){hostPatchProp(el,'value',null,props.value);}if(vnodeHook=props.onVnodeBeforeMount){invokeVNodeHook(vnodeHook,parentComponent,vnode);}}// scopeId
setScopeId(el,vnode,vnode.scopeId,slotScopeIds,parentComponent);}{Object.defineProperty(el,'__vnode',{value:vnode,enumerable:false});Object.defineProperty(el,'__vueParentComponent',{value:parentComponent,enumerable:false});}if(dirs){invokeDirectiveHook(vnode,null,parentComponent,'beforeMount');}// #1583 For inside suspense + suspense not resolved case, enter hook should call when suspense resolved
// #1689 For inside suspense + suspense resolved case, just call it
var needCallTransitionHooks=(!parentSuspense||parentSuspense&&!parentSuspense.pendingBranch)&&transition&&!transition.persisted;if(needCallTransitionHooks){transition.beforeEnter(el);}hostInsert(el,container,anchor);if((vnodeHook=props&&props.onVnodeMounted)||needCallTransitionHooks||dirs){queuePostRenderEffect(function(){vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,vnode);needCallTransitionHooks&&transition.enter(el);dirs&&invokeDirectiveHook(vnode,null,parentComponent,'mounted');},parentSuspense);}};var setScopeId=function setScopeId(el,vnode,scopeId,slotScopeIds,parentComponent){if(scopeId){hostSetScopeId(el,scopeId);}if(slotScopeIds){for(var i=0;i<slotScopeIds.length;i++){hostSetScopeId(el,slotScopeIds[i]);}}if(parentComponent){var subTree=parentComponent.subTree;if(subTree.patchFlag>0&&subTree.patchFlag&2048/* DEV_ROOT_FRAGMENT */){subTree=filterSingleRoot(subTree.children)||subTree;}if(vnode===subTree){var parentVNode=parentComponent.vnode;setScopeId(el,parentVNode,parentVNode.scopeId,parentVNode.slotScopeIds,parentComponent.parent);}}};var mountChildren=function mountChildren(children,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized){var start=arguments.length>8&&arguments[8]!==undefined?arguments[8]:0;for(var i=start;i<children.length;i++){var child=children[i]=optimized?cloneIfMounted(children[i]):normalizeVNode(children[i]);patch(null,child,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}};var patchElement=function patchElement(n1,n2,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized){var el=n2.el=n1.el;var patchFlag=n2.patchFlag,dynamicChildren=n2.dynamicChildren,dirs=n2.dirs;// #1426 take the old vnode's patch flag into account since user may clone a
// compiler-generated vnode, which de-opts to FULL_PROPS
patchFlag|=n1.patchFlag&16/* FULL_PROPS */;var oldProps=n1.props||EMPTY_OBJ;var newProps=n2.props||EMPTY_OBJ;var vnodeHook;// disable recurse in beforeUpdate hooks
parentComponent&&toggleRecurse(parentComponent,false);if(vnodeHook=newProps.onVnodeBeforeUpdate){invokeVNodeHook(vnodeHook,parentComponent,n2,n1);}if(dirs){invokeDirectiveHook(n2,n1,parentComponent,'beforeUpdate');}parentComponent&&toggleRecurse(parentComponent,true);if(isHmrUpdating){// HMR updated, force full diff
patchFlag=0;optimized=false;dynamicChildren=null;}var areChildrenSVG=isSVG&&n2.type!=='foreignObject';if(dynamicChildren){patchBlockChildren(n1.dynamicChildren,dynamicChildren,el,parentComponent,parentSuspense,areChildrenSVG,slotScopeIds);if(parentComponent&&parentComponent.type.__hmrId){traverseStaticChildren(n1,n2);}}else if(!optimized){// full diff
patchChildren(n1,n2,el,null,parentComponent,parentSuspense,areChildrenSVG,slotScopeIds,false);}if(patchFlag>0){// the presence of a patchFlag means this element's render code was
// generated by the compiler and can take the fast path.
// in this path old node and new node are guaranteed to have the same shape
// (i.e. at the exact same position in the source template)
if(patchFlag&16/* FULL_PROPS */){// element props contain dynamic keys, full diff needed
patchProps(el,n2,oldProps,newProps,parentComponent,parentSuspense,isSVG);}else{// class
// this flag is matched when the element has dynamic class bindings.
if(patchFlag&2/* CLASS */){if(oldProps.class!==newProps.class){hostPatchProp(el,'class',null,newProps.class,isSVG);}}// style
// this flag is matched when the element has dynamic style bindings
if(patchFlag&4/* STYLE */){hostPatchProp(el,'style',oldProps.style,newProps.style,isSVG);}// props
// This flag is matched when the element has dynamic prop/attr bindings
// other than class and style. The keys of dynamic prop/attrs are saved for
// faster iteration.
// Note dynamic keys like :[foo]="bar" will cause this optimization to
// bail out and go through a full diff because we need to unset the old key
if(patchFlag&8/* PROPS */){// if the flag is present then dynamicProps must be non-null
var propsToUpdate=n2.dynamicProps;for(var i=0;i<propsToUpdate.length;i++){var key=propsToUpdate[i];var prev=oldProps[key];var next=newProps[key];// #1471 force patch value
if(next!==prev||key==='value'){hostPatchProp(el,key,prev,next,isSVG,n1.children,parentComponent,parentSuspense,unmountChildren);}}}}// text
// This flag is matched when the element has only dynamic text children.
if(patchFlag&1/* TEXT */){if(n1.children!==n2.children){hostSetElementText(el,n2.children);}}}else if(!optimized&&dynamicChildren==null){// unoptimized, full diff
patchProps(el,n2,oldProps,newProps,parentComponent,parentSuspense,isSVG);}if((vnodeHook=newProps.onVnodeUpdated)||dirs){queuePostRenderEffect(function(){vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,n2,n1);dirs&&invokeDirectiveHook(n2,n1,parentComponent,'updated');},parentSuspense);}};// The fast path for blocks.
var patchBlockChildren=function patchBlockChildren(oldChildren,newChildren,fallbackContainer,parentComponent,parentSuspense,isSVG,slotScopeIds){for(var i=0;i<newChildren.length;i++){var oldVNode=oldChildren[i];var newVNode=newChildren[i];// Determine the container (parent element) for the patch.
var container=// oldVNode may be an errored async setup() component inside Suspense
// which will not have a mounted element
oldVNode.el&&(// - In the case of a Fragment, we need to provide the actual parent
// of the Fragment itself so it can move its children.
oldVNode.type===Fragment||// - In the case of different nodes, there is going to be a replacement
// which also requires the correct parent container
!isSameVNodeType(oldVNode,newVNode)||// - In the case of a component, it could contain anything.
oldVNode.shapeFlag&(6/* COMPONENT */|64/* TELEPORT */))?hostParentNode(oldVNode.el):// In other cases, the parent container is not actually used so we
// just pass the block element here to avoid a DOM parentNode call.
fallbackContainer;patch(oldVNode,newVNode,container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,true);}};var patchProps=function patchProps(el,vnode,oldProps,newProps,parentComponent,parentSuspense,isSVG){if(oldProps!==newProps){for(var key in newProps){// empty string is not valid prop
if(isReservedProp(key))continue;var next=newProps[key];var prev=oldProps[key];// defer patching value
if(next!==prev&&key!=='value'){hostPatchProp(el,key,prev,next,isSVG,vnode.children,parentComponent,parentSuspense,unmountChildren);}}if(oldProps!==EMPTY_OBJ){for(var _key18 in oldProps){if(!isReservedProp(_key18)&&!(_key18 in newProps)){hostPatchProp(el,_key18,oldProps[_key18],null,isSVG,vnode.children,parentComponent,parentSuspense,unmountChildren);}}}if('value'in newProps){hostPatchProp(el,'value',oldProps.value,newProps.value);}}};var processFragment=function processFragment(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized){var fragmentStartAnchor=n2.el=n1?n1.el:hostCreateText('');var fragmentEndAnchor=n2.anchor=n1?n1.anchor:hostCreateText('');var patchFlag=n2.patchFlag,dynamicChildren=n2.dynamicChildren,fragmentSlotScopeIds=n2.slotScopeIds;if(isHmrUpdating){// HMR updated, force full diff
patchFlag=0;optimized=false;dynamicChildren=null;}// check if this is a slot fragment with :slotted scope ids
if(fragmentSlotScopeIds){slotScopeIds=slotScopeIds?slotScopeIds.concat(fragmentSlotScopeIds):fragmentSlotScopeIds;}if(n1==null){hostInsert(fragmentStartAnchor,container,anchor);hostInsert(fragmentEndAnchor,container,anchor);// a fragment can only have array children
// since they are either generated by the compiler, or implicitly created
// from arrays.
mountChildren(n2.children,container,fragmentEndAnchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}else{if(patchFlag>0&&patchFlag&64/* STABLE_FRAGMENT */&&dynamicChildren&&// #2715 the previous fragment could've been a BAILed one as a result
// of renderSlot() with no valid children
n1.dynamicChildren){// a stable fragment (template root or <template v-for>) doesn't need to
// patch children order, but it may contain dynamicChildren.
patchBlockChildren(n1.dynamicChildren,dynamicChildren,container,parentComponent,parentSuspense,isSVG,slotScopeIds);if(parentComponent&&parentComponent.type.__hmrId){traverseStaticChildren(n1,n2);}else if(// #2080 if the stable fragment has a key, it's a <template v-for> that may
//  get moved around. Make sure all root level vnodes inherit el.
// #2134 or if it's a component root, it may also get moved around
// as the component is being moved.
n2.key!=null||parentComponent&&n2===parentComponent.subTree){traverseStaticChildren(n1,n2,true/* shallow */);}}else{// keyed / unkeyed, or manual fragments.
// for keyed & unkeyed, since they are compiler generated from v-for,
// each child is guaranteed to be a block so the fragment will never
// have dynamicChildren.
patchChildren(n1,n2,container,fragmentEndAnchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}}};var processComponent=function processComponent(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized){n2.slotScopeIds=slotScopeIds;if(n1==null){if(n2.shapeFlag&512/* COMPONENT_KEPT_ALIVE */){parentComponent.ctx.activate(n2,container,anchor,isSVG,optimized);}else{mountComponent(n2,container,anchor,parentComponent,parentSuspense,isSVG,optimized);}}else{updateComponent(n1,n2,optimized);}};var mountComponent=function mountComponent(initialVNode,container,anchor,parentComponent,parentSuspense,isSVG,optimized){var instance=initialVNode.component=createComponentInstance(initialVNode,parentComponent,parentSuspense);if(instance.type.__hmrId){registerHMR(instance);}{pushWarningContext(initialVNode);startMeasure(instance,"mount");}// inject renderer internals for keepAlive
if(isKeepAlive(initialVNode)){instance.ctx.renderer=internals;}// resolve props and slots for setup context
{{startMeasure(instance,"init");}setupComponent(instance);{endMeasure(instance,"init");}}// setup() is async. This component relies on async logic to be resolved
// before proceeding
if(instance.asyncDep){parentSuspense&&parentSuspense.registerDep(instance,setupRenderEffect);// Give it a placeholder if this is not hydration
// TODO handle self-defined fallback
if(!initialVNode.el){var placeholder=instance.subTree=createVNode(Comment);processCommentNode(null,placeholder,container,anchor);}return;}setupRenderEffect(instance,initialVNode,container,anchor,parentSuspense,isSVG,optimized);{popWarningContext();endMeasure(instance,"mount");}};var updateComponent=function updateComponent(n1,n2,optimized){var instance=n2.component=n1.component;if(shouldUpdateComponent(n1,n2,optimized)){if(instance.asyncDep&&!instance.asyncResolved){// async & still pending - just update props and slots
// since the component's reactive effect for render isn't set-up yet
{pushWarningContext(n2);}updateComponentPreRender(instance,n2,optimized);{popWarningContext();}return;}else{// normal update
instance.next=n2;// in case the child component is also queued, remove it to avoid
// double updating the same child component in the same flush.
invalidateJob(instance.update);// instance.update is the reactive effect.
instance.update();}}else{// no update needed. just copy over properties
n2.component=n1.component;n2.el=n1.el;instance.vnode=n2;}};var setupRenderEffect=function setupRenderEffect(instance,initialVNode,container,anchor,parentSuspense,isSVG,optimized){var componentUpdateFn=function componentUpdateFn(){if(!instance.isMounted){var vnodeHook;var _initialVNode=initialVNode,el=_initialVNode.el,props=_initialVNode.props;var bm=instance.bm,m=instance.m,parent=instance.parent;var isAsyncWrapperVNode=isAsyncWrapper(initialVNode);toggleRecurse(instance,false);// beforeMount hook
if(bm){invokeArrayFns(bm);}// onVnodeBeforeMount
if(!isAsyncWrapperVNode&&(vnodeHook=props&&props.onVnodeBeforeMount)){invokeVNodeHook(vnodeHook,parent,initialVNode);}toggleRecurse(instance,true);if(el&&hydrateNode){// vnode has adopted host node - perform hydration instead of mount.
var hydrateSubTree=function hydrateSubTree(){{startMeasure(instance,"render");}instance.subTree=renderComponentRoot(instance);{endMeasure(instance,"render");}{startMeasure(instance,"hydrate");}hydrateNode(el,instance.subTree,instance,parentSuspense,null);{endMeasure(instance,"hydrate");}};if(isAsyncWrapperVNode){initialVNode.type.__asyncLoader().then(// note: we are moving the render call into an async callback,
// which means it won't track dependencies - but it's ok because
// a server-rendered async wrapper is already in resolved state
// and it will never need to change.
function(){return!instance.isUnmounted&&hydrateSubTree();});}else{hydrateSubTree();}}else{{startMeasure(instance,"render");}var subTree=instance.subTree=renderComponentRoot(instance);{endMeasure(instance,"render");}{startMeasure(instance,"patch");}patch(null,subTree,container,anchor,instance,parentSuspense,isSVG);{endMeasure(instance,"patch");}initialVNode.el=subTree.el;}// mounted hook
if(m){queuePostRenderEffect(m,parentSuspense);}// onVnodeMounted
if(!isAsyncWrapperVNode&&(vnodeHook=props&&props.onVnodeMounted)){var scopedInitialVNode=initialVNode;queuePostRenderEffect(function(){return invokeVNodeHook(vnodeHook,parent,scopedInitialVNode);},parentSuspense);}// activated hook for keep-alive roots.
// #1742 activated hook must be accessed after first render
// since the hook may be injected by a child keep-alive
if(initialVNode.shapeFlag&256/* COMPONENT_SHOULD_KEEP_ALIVE */){instance.a&&queuePostRenderEffect(instance.a,parentSuspense);}instance.isMounted=true;{devtoolsComponentAdded(instance);}// #2458: deference mount-only object parameters to prevent memleaks
initialVNode=container=anchor=null;}else{// updateComponent
// This is triggered by mutation of component's own state (next: null)
// OR parent calling processComponent (next: VNode)
var next=instance.next,bu=instance.bu,u=instance.u,_parent=instance.parent,vnode=instance.vnode;var originNext=next;var _vnodeHook;{pushWarningContext(next||instance.vnode);}// Disallow component effect recursion during pre-lifecycle hooks.
toggleRecurse(instance,false);if(next){next.el=vnode.el;updateComponentPreRender(instance,next,optimized);}else{next=vnode;}// beforeUpdate hook
if(bu){invokeArrayFns(bu);}// onVnodeBeforeUpdate
if(_vnodeHook=next.props&&next.props.onVnodeBeforeUpdate){invokeVNodeHook(_vnodeHook,_parent,next,vnode);}toggleRecurse(instance,true);// render
{startMeasure(instance,"render");}var nextTree=renderComponentRoot(instance);{endMeasure(instance,"render");}var prevTree=instance.subTree;instance.subTree=nextTree;{startMeasure(instance,"patch");}patch(prevTree,nextTree,// parent may have changed if it's in a teleport
hostParentNode(prevTree.el),// anchor may have changed if it's in a fragment
getNextHostNode(prevTree),instance,parentSuspense,isSVG);{endMeasure(instance,"patch");}next.el=nextTree.el;if(originNext===null){// self-triggered update. In case of HOC, update parent component
// vnode el. HOC is indicated by parent instance's subTree pointing
// to child component's vnode
updateHOCHostEl(instance,nextTree.el);}// updated hook
if(u){queuePostRenderEffect(u,parentSuspense);}// onVnodeUpdated
if(_vnodeHook=next.props&&next.props.onVnodeUpdated){queuePostRenderEffect(function(){return invokeVNodeHook(_vnodeHook,_parent,next,vnode);},parentSuspense);}{devtoolsComponentUpdated(instance);}{popWarningContext();}}};// create reactive effect for rendering
var effect=instance.effect=new ReactiveEffect(componentUpdateFn,function(){return queueJob(instance.update);},instance.scope// track it in component's effect scope
);var update=instance.update=effect.run.bind(effect);update.id=instance.uid;// allowRecurse
// #1801, #2043 component render effects should allow recursive updates
toggleRecurse(instance,true);{effect.onTrack=instance.rtc?function(e){return invokeArrayFns(instance.rtc,e);}:void 0;effect.onTrigger=instance.rtg?function(e){return invokeArrayFns(instance.rtg,e);}:void 0;// @ts-ignore (for scheduler)
update.ownerInstance=instance;}update();};var updateComponentPreRender=function updateComponentPreRender(instance,nextVNode,optimized){nextVNode.component=instance;var prevProps=instance.vnode.props;instance.vnode=nextVNode;instance.next=null;updateProps(instance,nextVNode.props,prevProps,optimized);updateSlots(instance,nextVNode.children,optimized);pauseTracking();// props update may have triggered pre-flush watchers.
// flush them before the render update.
flushPreFlushCbs(undefined,instance.update);resetTracking();};var patchChildren=function patchChildren(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds){var optimized=arguments.length>8&&arguments[8]!==undefined?arguments[8]:false;var c1=n1&&n1.children;var prevShapeFlag=n1?n1.shapeFlag:0;var c2=n2.children;var patchFlag=n2.patchFlag,shapeFlag=n2.shapeFlag;// fast path
if(patchFlag>0){if(patchFlag&128/* KEYED_FRAGMENT */){// this could be either fully-keyed or mixed (some keyed some not)
// presence of patchFlag means children are guaranteed to be arrays
patchKeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);return;}else if(patchFlag&256/* UNKEYED_FRAGMENT */){// unkeyed
patchUnkeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);return;}}// children has 3 possibilities: text, array or no children.
if(shapeFlag&8/* TEXT_CHILDREN */){// text children fast path
if(prevShapeFlag&16/* ARRAY_CHILDREN */){unmountChildren(c1,parentComponent,parentSuspense);}if(c2!==c1){hostSetElementText(container,c2);}}else{if(prevShapeFlag&16/* ARRAY_CHILDREN */){// prev children was array
if(shapeFlag&16/* ARRAY_CHILDREN */){// two arrays, cannot assume anything, do full diff
patchKeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}else{// no new children, just unmount old
unmountChildren(c1,parentComponent,parentSuspense,true);}}else{// prev children was text OR null
// new children is array OR null
if(prevShapeFlag&8/* TEXT_CHILDREN */){hostSetElementText(container,'');}// mount new if array
if(shapeFlag&16/* ARRAY_CHILDREN */){mountChildren(c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}}}};var patchUnkeyedChildren=function patchUnkeyedChildren(c1,c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized){c1=c1||EMPTY_ARR;c2=c2||EMPTY_ARR;var oldLength=c1.length;var newLength=c2.length;var commonLength=Math.min(oldLength,newLength);var i;for(i=0;i<commonLength;i++){var nextChild=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);patch(c1[i],nextChild,container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}if(oldLength>newLength){// remove old
unmountChildren(c1,parentComponent,parentSuspense,true,false,commonLength);}else{// mount new
mountChildren(c2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,commonLength);}};// can be all-keyed or mixed
var patchKeyedChildren=function patchKeyedChildren(c1,c2,container,parentAnchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized){var i=0;var l2=c2.length;var e1=c1.length-1;// prev ending index
var e2=l2-1;// next ending index
// 1. sync from start
// (a b) c
// (a b) d e
while(i<=e1&&i<=e2){var n1=c1[i];var n2=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);if(isSameVNodeType(n1,n2)){patch(n1,n2,container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}else{break;}i++;}// 2. sync from end
// a (b c)
// d e (b c)
while(i<=e1&&i<=e2){var _n2=c1[e1];var _n3=c2[e2]=optimized?cloneIfMounted(c2[e2]):normalizeVNode(c2[e2]);if(isSameVNodeType(_n2,_n3)){patch(_n2,_n3,container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}else{break;}e1--;e2--;}// 3. common sequence + mount
// (a b)
// (a b) c
// i = 2, e1 = 1, e2 = 2
// (a b)
// c (a b)
// i = 0, e1 = -1, e2 = 0
if(i>e1){if(i<=e2){var nextPos=e2+1;var anchor=nextPos<l2?c2[nextPos].el:parentAnchor;while(i<=e2){patch(null,c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]),container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);i++;}}}// 4. common sequence + unmount
// (a b) c
// (a b)
// i = 2, e1 = 2, e2 = 1
// a (b c)
// (b c)
// i = 0, e1 = 0, e2 = -1
else if(i>e2){while(i<=e1){unmount(c1[i],parentComponent,parentSuspense,true);i++;}}// 5. unknown sequence
// [i ... e1 + 1]: a b [c d e] f g
// [i ... e2 + 1]: a b [e d c h] f g
// i = 2, e1 = 4, e2 = 5
else{var s1=i;// prev starting index
var s2=i;// next starting index
// 5.1 build key:index map for newChildren
var keyToNewIndexMap=new Map();for(i=s2;i<=e2;i++){var nextChild=c2[i]=optimized?cloneIfMounted(c2[i]):normalizeVNode(c2[i]);if(nextChild.key!=null){if(keyToNewIndexMap.has(nextChild.key)){warn$1("Duplicate keys found during update:",JSON.stringify(nextChild.key),"Make sure keys are unique.");}keyToNewIndexMap.set(nextChild.key,i);}}// 5.2 loop through old children left to be patched and try to patch
// matching nodes & remove nodes that are no longer present
var j;var patched=0;var toBePatched=e2-s2+1;var moved=false;// used to track whether any node has moved
var maxNewIndexSoFar=0;// works as Map<newIndex, oldIndex>
// Note that oldIndex is offset by +1
// and oldIndex = 0 is a special value indicating the new node has
// no corresponding old node.
// used for determining longest stable subsequence
var newIndexToOldIndexMap=new Array(toBePatched);for(i=0;i<toBePatched;i++){newIndexToOldIndexMap[i]=0;}for(i=s1;i<=e1;i++){var prevChild=c1[i];if(patched>=toBePatched){// all new children have been patched so this can only be a removal
unmount(prevChild,parentComponent,parentSuspense,true);continue;}var newIndex=void 0;if(prevChild.key!=null){newIndex=keyToNewIndexMap.get(prevChild.key);}else{// key-less node, try to locate a key-less node of the same type
for(j=s2;j<=e2;j++){if(newIndexToOldIndexMap[j-s2]===0&&isSameVNodeType(prevChild,c2[j])){newIndex=j;break;}}}if(newIndex===undefined){unmount(prevChild,parentComponent,parentSuspense,true);}else{newIndexToOldIndexMap[newIndex-s2]=i+1;if(newIndex>=maxNewIndexSoFar){maxNewIndexSoFar=newIndex;}else{moved=true;}patch(prevChild,c2[newIndex],container,null,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);patched++;}}// 5.3 move and mount
// generate longest stable subsequence only when nodes have moved
var increasingNewIndexSequence=moved?getSequence(newIndexToOldIndexMap):EMPTY_ARR;j=increasingNewIndexSequence.length-1;// looping backwards so that we can use last patched node as anchor
for(i=toBePatched-1;i>=0;i--){var nextIndex=s2+i;var _nextChild=c2[nextIndex];var _anchor2=nextIndex+1<l2?c2[nextIndex+1].el:parentAnchor;if(newIndexToOldIndexMap[i]===0){// mount new
patch(null,_nextChild,container,_anchor2,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}else if(moved){// move if:
// There is no stable subsequence (e.g. a reverse)
// OR current node is not among the stable sequence
if(j<0||i!==increasingNewIndexSequence[j]){move(_nextChild,container,_anchor2,2/* REORDER */);}else{j--;}}}}};var move=function move(vnode,container,anchor,moveType){var parentSuspense=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;var el=vnode.el,type=vnode.type,transition=vnode.transition,children=vnode.children,shapeFlag=vnode.shapeFlag;if(shapeFlag&6/* COMPONENT */){move(vnode.component.subTree,container,anchor,moveType);return;}if(shapeFlag&128/* SUSPENSE */){vnode.suspense.move(container,anchor,moveType);return;}if(shapeFlag&64/* TELEPORT */){type.move(vnode,container,anchor,internals);return;}if(type===Fragment){hostInsert(el,container,anchor);for(var i=0;i<children.length;i++){move(children[i],container,anchor,moveType);}hostInsert(vnode.anchor,container,anchor);return;}if(type===Static){moveStaticNode(vnode,container,anchor);return;}// single nodes
var needTransition=moveType!==2/* REORDER */&&shapeFlag&1/* ELEMENT */&&transition;if(needTransition){if(moveType===0/* ENTER */){transition.beforeEnter(el);hostInsert(el,container,anchor);queuePostRenderEffect(function(){return transition.enter(el);},parentSuspense);}else{var leave=transition.leave,delayLeave=transition.delayLeave,afterLeave=transition.afterLeave;var _remove=function _remove(){return hostInsert(el,container,anchor);};var performLeave=function performLeave(){leave(el,function(){_remove();afterLeave&&afterLeave();});};if(delayLeave){delayLeave(el,_remove,performLeave);}else{performLeave();}}}else{hostInsert(el,container,anchor);}};var unmount=function unmount(vnode,parentComponent,parentSuspense){var doRemove=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var optimized=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;var type=vnode.type,props=vnode.props,ref=vnode.ref,children=vnode.children,dynamicChildren=vnode.dynamicChildren,shapeFlag=vnode.shapeFlag,patchFlag=vnode.patchFlag,dirs=vnode.dirs;// unset ref
if(ref!=null){setRef(ref,null,parentSuspense,vnode,true);}if(shapeFlag&256/* COMPONENT_SHOULD_KEEP_ALIVE */){parentComponent.ctx.deactivate(vnode);return;}var shouldInvokeDirs=shapeFlag&1/* ELEMENT */&&dirs;var shouldInvokeVnodeHook=!isAsyncWrapper(vnode);var vnodeHook;if(shouldInvokeVnodeHook&&(vnodeHook=props&&props.onVnodeBeforeUnmount)){invokeVNodeHook(vnodeHook,parentComponent,vnode);}if(shapeFlag&6/* COMPONENT */){unmountComponent(vnode.component,parentSuspense,doRemove);}else{if(shapeFlag&128/* SUSPENSE */){vnode.suspense.unmount(parentSuspense,doRemove);return;}if(shouldInvokeDirs){invokeDirectiveHook(vnode,null,parentComponent,'beforeUnmount');}if(shapeFlag&64/* TELEPORT */){vnode.type.remove(vnode,parentComponent,parentSuspense,optimized,internals,doRemove);}else if(dynamicChildren&&(// #1153: fast path should not be taken for non-stable (v-for) fragments
type!==Fragment||patchFlag>0&&patchFlag&64/* STABLE_FRAGMENT */)){// fast path for block nodes: only need to unmount dynamic children.
unmountChildren(dynamicChildren,parentComponent,parentSuspense,false,true);}else if(type===Fragment&&patchFlag&(128/* KEYED_FRAGMENT */|256/* UNKEYED_FRAGMENT */)||!optimized&&shapeFlag&16/* ARRAY_CHILDREN */){unmountChildren(children,parentComponent,parentSuspense);}if(doRemove){remove(vnode);}}if(shouldInvokeVnodeHook&&(vnodeHook=props&&props.onVnodeUnmounted)||shouldInvokeDirs){queuePostRenderEffect(function(){vnodeHook&&invokeVNodeHook(vnodeHook,parentComponent,vnode);shouldInvokeDirs&&invokeDirectiveHook(vnode,null,parentComponent,'unmounted');},parentSuspense);}};var remove=function remove(vnode){var type=vnode.type,el=vnode.el,anchor=vnode.anchor,transition=vnode.transition;if(type===Fragment){removeFragment(el,anchor);return;}if(type===Static){removeStaticNode(vnode);return;}var performRemove=function performRemove(){hostRemove(el);if(transition&&!transition.persisted&&transition.afterLeave){transition.afterLeave();}};if(vnode.shapeFlag&1/* ELEMENT */&&transition&&!transition.persisted){var leave=transition.leave,delayLeave=transition.delayLeave;var performLeave=function performLeave(){return leave(el,performRemove);};if(delayLeave){delayLeave(vnode.el,performRemove,performLeave);}else{performLeave();}}else{performRemove();}};var removeFragment=function removeFragment(cur,end){// For fragments, directly remove all contained DOM nodes.
// (fragment child nodes cannot have transition)
var next;while(cur!==end){next=hostNextSibling(cur);hostRemove(cur);cur=next;}hostRemove(end);};var unmountComponent=function unmountComponent(instance,parentSuspense,doRemove){if(instance.type.__hmrId){unregisterHMR(instance);}var bum=instance.bum,scope=instance.scope,update=instance.update,subTree=instance.subTree,um=instance.um;// beforeUnmount hook
if(bum){invokeArrayFns(bum);}// stop effects in component scope
scope.stop();// update may be null if a component is unmounted before its async
// setup has resolved.
if(update){// so that scheduler will no longer invoke it
update.active=false;unmount(subTree,instance,parentSuspense,doRemove);}// unmounted hook
if(um){queuePostRenderEffect(um,parentSuspense);}queuePostRenderEffect(function(){instance.isUnmounted=true;},parentSuspense);// A component with async dep inside a pending suspense is unmounted before
// its async dep resolves. This should remove the dep from the suspense, and
// cause the suspense to resolve immediately if that was the last dep.
if(parentSuspense&&parentSuspense.pendingBranch&&!parentSuspense.isUnmounted&&instance.asyncDep&&!instance.asyncResolved&&instance.suspenseId===parentSuspense.pendingId){parentSuspense.deps--;if(parentSuspense.deps===0){parentSuspense.resolve();}}{devtoolsComponentRemoved(instance);}};var unmountChildren=function unmountChildren(children,parentComponent,parentSuspense){var doRemove=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var optimized=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;var start=arguments.length>5&&arguments[5]!==undefined?arguments[5]:0;for(var i=start;i<children.length;i++){unmount(children[i],parentComponent,parentSuspense,doRemove,optimized);}};var getNextHostNode=function getNextHostNode(vnode){if(vnode.shapeFlag&6/* COMPONENT */){return getNextHostNode(vnode.component.subTree);}if(vnode.shapeFlag&128/* SUSPENSE */){return vnode.suspense.next();}return hostNextSibling(vnode.anchor||vnode.el);};var render=function render(vnode,container,isSVG){if(vnode==null){if(container._vnode){unmount(container._vnode,null,null,true);}}else{patch(container._vnode||null,vnode,container,null,null,null,isSVG);}flushPostFlushCbs();container._vnode=vnode;};var internals={p:patch,um:unmount,m:move,r:remove,mt:mountComponent,mc:mountChildren,pc:patchChildren,pbc:patchBlockChildren,n:getNextHostNode,o:options};var hydrate;var hydrateNode;if(createHydrationFns){var _createHydrationFns=createHydrationFns(internals);var _createHydrationFns2=_slicedToArray(_createHydrationFns,2);hydrate=_createHydrationFns2[0];hydrateNode=_createHydrationFns2[1];}return{render:render,hydrate:hydrate,createApp:createAppAPI(render,hydrate)};}function toggleRecurse(_ref21,allowed){var effect=_ref21.effect,update=_ref21.update;effect.allowRecurse=update.allowRecurse=allowed;}/**
 * #1156
 * When a component is HMR-enabled, we need to make sure that all static nodes
 * inside a block also inherit the DOM element from the previous tree so that
 * HMR updates (which are full updates) can retrieve the element for patching.
 *
 * #2080
 * Inside keyed `template` fragment static children, if a fragment is moved,
 * the children will always be moved. Therefore, in order to ensure correct move
 * position, el should be inherited from previous nodes.
 */function traverseStaticChildren(n1,n2){var shallow=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var ch1=n1.children;var ch2=n2.children;if(isArray(ch1)&&isArray(ch2)){for(var i=0;i<ch1.length;i++){// this is only called in the optimized path so array children are
// guaranteed to be vnodes
var c1=ch1[i];var c2=ch2[i];if(c2.shapeFlag&1/* ELEMENT */&&!c2.dynamicChildren){if(c2.patchFlag<=0||c2.patchFlag===32/* HYDRATE_EVENTS */){c2=ch2[i]=cloneIfMounted(ch2[i]);c2.el=c1.el;}if(!shallow)traverseStaticChildren(c1,c2);}// also inherit for comment nodes, but not placeholders (e.g. v-if which
// would have received .el during block patch)
if(c2.type===Comment&&!c2.el){c2.el=c1.el;}}}}// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function getSequence(arr){var p=arr.slice();var result=[0];var i,j,u,v,c;var len=arr.length;for(i=0;i<len;i++){var arrI=arr[i];if(arrI!==0){j=result[result.length-1];if(arr[j]<arrI){p[i]=j;result.push(i);continue;}u=0;v=result.length-1;while(u<v){c=u+v>>1;if(arr[result[c]]<arrI){u=c+1;}else{v=c;}}if(arrI<arr[result[u]]){if(u>0){p[i]=result[u-1];}result[u]=i;}}}u=result.length;v=result[u-1];while(u-->0){result[u]=v;v=p[v];}return result;}var isTeleport=function isTeleport(type){return type.__isTeleport;};var isTeleportDisabled=function isTeleportDisabled(props){return props&&(props.disabled||props.disabled==='');};var isTargetSVG=function isTargetSVG(target){return typeof SVGElement!=='undefined'&&target instanceof SVGElement;};var resolveTarget=function resolveTarget(props,select){var targetSelector=props&&props.to;if(isString(targetSelector)){if(!select){warn$1("Current renderer does not support string target for Teleports. "+"(missing querySelector renderer option)");return null;}else{var target=select(targetSelector);if(!target){warn$1("Failed to locate Teleport target with selector \"".concat(targetSelector,"\". ")+"Note the target element must exist before the component is mounted - "+"i.e. the target cannot be rendered by the component itself, and "+"ideally should be outside of the entire Vue component tree.");}return target;}}else{if(!targetSelector&&!isTeleportDisabled(props)){warn$1("Invalid Teleport target: ".concat(targetSelector));}return targetSelector;}};var TeleportImpl={__isTeleport:true,process:function process(n1,n2,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized,internals){var mountChildren=internals.mc,patchChildren=internals.pc,patchBlockChildren=internals.pbc,_internals$o=internals.o,insert=_internals$o.insert,querySelector=_internals$o.querySelector,createText=_internals$o.createText,createComment=_internals$o.createComment;var disabled=isTeleportDisabled(n2.props);var shapeFlag=n2.shapeFlag,children=n2.children,dynamicChildren=n2.dynamicChildren;// #3302
// HMR updated, force full diff
if(isHmrUpdating){optimized=false;dynamicChildren=null;}if(n1==null){// insert anchors in the main view
var placeholder=n2.el=createComment('teleport start');var mainAnchor=n2.anchor=createComment('teleport end');insert(placeholder,container,anchor);insert(mainAnchor,container,anchor);var target=n2.target=resolveTarget(n2.props,querySelector);var targetAnchor=n2.targetAnchor=createText('');if(target){insert(targetAnchor,target);// #2652 we could be teleporting from a non-SVG tree into an SVG tree
isSVG=isSVG||isTargetSVG(target);}else if(!disabled){warn$1('Invalid Teleport target on mount:',target,"(".concat(_typeof(target),")"));}var mount=function mount(container,anchor){// Teleport *always* has Array children. This is enforced in both the
// compiler and vnode children normalization.
if(shapeFlag&16/* ARRAY_CHILDREN */){mountChildren(children,container,anchor,parentComponent,parentSuspense,isSVG,slotScopeIds,optimized);}};if(disabled){mount(container,mainAnchor);}else if(target){mount(target,targetAnchor);}}else{// update content
n2.el=n1.el;var _mainAnchor=n2.anchor=n1.anchor;var _target=n2.target=n1.target;var _targetAnchor=n2.targetAnchor=n1.targetAnchor;var wasDisabled=isTeleportDisabled(n1.props);var currentContainer=wasDisabled?container:_target;var currentAnchor=wasDisabled?_mainAnchor:_targetAnchor;isSVG=isSVG||isTargetSVG(_target);if(dynamicChildren){// fast path when the teleport happens to be a block root
patchBlockChildren(n1.dynamicChildren,dynamicChildren,currentContainer,parentComponent,parentSuspense,isSVG,slotScopeIds);// even in block tree mode we need to make sure all root-level nodes
// in the teleport inherit previous DOM references so that they can
// be moved in future patches.
traverseStaticChildren(n1,n2,true);}else if(!optimized){patchChildren(n1,n2,currentContainer,currentAnchor,parentComponent,parentSuspense,isSVG,slotScopeIds,false);}if(disabled){if(!wasDisabled){// enabled -> disabled
// move into main container
moveTeleport(n2,container,_mainAnchor,internals,1/* TOGGLE */);}}else{// target changed
if((n2.props&&n2.props.to)!==(n1.props&&n1.props.to)){var nextTarget=n2.target=resolveTarget(n2.props,querySelector);if(nextTarget){moveTeleport(n2,nextTarget,null,internals,0/* TARGET_CHANGE */);}else{warn$1('Invalid Teleport target on update:',_target,"(".concat(_typeof(_target),")"));}}else if(wasDisabled){// disabled -> enabled
// move into teleport target
moveTeleport(n2,_target,_targetAnchor,internals,1/* TOGGLE */);}}}},remove:function remove(vnode,parentComponent,parentSuspense,optimized,_ref22,doRemove){var unmount=_ref22.um,hostRemove=_ref22.o.remove;var shapeFlag=vnode.shapeFlag,children=vnode.children,anchor=vnode.anchor,targetAnchor=vnode.targetAnchor,target=vnode.target,props=vnode.props;if(target){hostRemove(targetAnchor);}// an unmounted teleport should always remove its children if not disabled
if(doRemove||!isTeleportDisabled(props)){hostRemove(anchor);if(shapeFlag&16/* ARRAY_CHILDREN */){for(var i=0;i<children.length;i++){var child=children[i];unmount(child,parentComponent,parentSuspense,true,!!child.dynamicChildren);}}}},move:moveTeleport,hydrate:hydrateTeleport};function moveTeleport(vnode,container,parentAnchor,_ref23)/* REORDER */{var insert=_ref23.o.insert,move=_ref23.m;var moveType=arguments.length>4&&arguments[4]!==undefined?arguments[4]:2;// move target anchor if this is a target change.
if(moveType===0/* TARGET_CHANGE */){insert(vnode.targetAnchor,container,parentAnchor);}var el=vnode.el,anchor=vnode.anchor,shapeFlag=vnode.shapeFlag,children=vnode.children,props=vnode.props;var isReorder=moveType===2/* REORDER */;// move main view anchor if this is a re-order.
if(isReorder){insert(el,container,parentAnchor);}// if this is a re-order and teleport is enabled (content is in target)
// do not move children. So the opposite is: only move children if this
// is not a reorder, or the teleport is disabled
if(!isReorder||isTeleportDisabled(props)){// Teleport has either Array children or no children.
if(shapeFlag&16/* ARRAY_CHILDREN */){for(var i=0;i<children.length;i++){move(children[i],container,parentAnchor,2/* REORDER */);}}}// move main view anchor if this is a re-order.
if(isReorder){insert(anchor,container,parentAnchor);}}function hydrateTeleport(node,vnode,parentComponent,parentSuspense,slotScopeIds,optimized,_ref24,hydrateChildren){var _ref24$o=_ref24.o,nextSibling=_ref24$o.nextSibling,parentNode=_ref24$o.parentNode,querySelector=_ref24$o.querySelector;var target=vnode.target=resolveTarget(vnode.props,querySelector);if(target){// if multiple teleports rendered to the same target element, we need to
// pick up from where the last teleport finished instead of the first node
var targetNode=target._lpa||target.firstChild;if(vnode.shapeFlag&16/* ARRAY_CHILDREN */){if(isTeleportDisabled(vnode.props)){vnode.anchor=hydrateChildren(nextSibling(node),vnode,parentNode(node),parentComponent,parentSuspense,slotScopeIds,optimized);vnode.targetAnchor=targetNode;}else{vnode.anchor=nextSibling(node);vnode.targetAnchor=hydrateChildren(targetNode,vnode,target,parentComponent,parentSuspense,slotScopeIds,optimized);}target._lpa=vnode.targetAnchor&&nextSibling(vnode.targetAnchor);}}return vnode.anchor&&nextSibling(vnode.anchor);}// Force-casted public typing for h and TSX props inference
var Teleport=TeleportImpl;var COMPONENTS='components';var DIRECTIVES='directives';/**
 * @private
 */function resolveComponent(name,maybeSelfReference){return resolveAsset(COMPONENTS,name,true,maybeSelfReference)||name;}var NULL_DYNAMIC_COMPONENT=Symbol();/**
 * @private
 */function resolveDynamicComponent(component){if(isString(component)){return resolveAsset(COMPONENTS,component,false)||component;}else{// invalid types will fallthrough to createVNode and raise warning
return component||NULL_DYNAMIC_COMPONENT;}}/**
 * @private
 */function resolveDirective(name){return resolveAsset(DIRECTIVES,name);}// implementation
function resolveAsset(type,name){var warnMissing=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;var maybeSelfReference=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var instance=currentRenderingInstance||currentInstance;if(instance){var Component=instance.type;// explicit self name has highest priority
if(type===COMPONENTS){var selfName=getComponentName(Component);if(selfName&&(selfName===name||selfName===camelize(name)||selfName===capitalize(camelize(name)))){return Component;}}var res=// local registration
// check instance[type] first which is resolved for options API
resolve(instance[type]||Component[type],name)||// global registration
resolve(instance.appContext[type],name);if(!res&&maybeSelfReference){// fallback to implicit self-reference
return Component;}if(warnMissing&&!res){var extra=type===COMPONENTS?"\nIf this is a native custom element, make sure to exclude it from "+"component resolution via compilerOptions.isCustomElement.":"";warn$1("Failed to resolve ".concat(type.slice(0,-1),": ").concat(name).concat(extra));}return res;}else{warn$1("resolve".concat(capitalize(type.slice(0,-1))," ")+"can only be used in render() or setup().");}}function resolve(registry,name){return registry&&(registry[name]||registry[camelize(name)]||registry[capitalize(camelize(name))]);}var Fragment=Symbol('Fragment');var Text=Symbol('Text');var Comment=Symbol('Comment');var Static=Symbol('Static');// Since v-if and v-for are the two possible ways node structure can dynamically
// change, once we consider v-if branches and each v-for fragment a block, we
// can divide a template into nested blocks, and within each block the node
// structure would be stable. This allows us to skip most children diffing
// and only worry about the dynamic nodes (indicated by patch flags).
var blockStack=[];var currentBlock=null;/**
 * Open a block.
 * This must be called before `createBlock`. It cannot be part of `createBlock`
 * because the children of the block are evaluated before `createBlock` itself
 * is called. The generated code typically looks like this:
 *
 * ```js
 * function render() {
 *   return (openBlock(),createBlock('div', null, [...]))
 * }
 * ```
 * disableTracking is true when creating a v-for fragment block, since a v-for
 * fragment always diffs its children.
 *
 * @private
 */function openBlock(){var disableTracking=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;blockStack.push(currentBlock=disableTracking?null:[]);}function closeBlock(){blockStack.pop();currentBlock=blockStack[blockStack.length-1]||null;}// Whether we should be tracking dynamic child nodes inside a block.
// Only tracks when this value is > 0
// We are not using a simple boolean because this value may need to be
// incremented/decremented by nested usage of v-once (see below)
var isBlockTreeEnabled=1;/**
 * Block tracking sometimes needs to be disabled, for example during the
 * creation of a tree that needs to be cached by v-once. The compiler generates
 * code like this:
 *
 * ``` js
 * _cache[1] || (
 *   setBlockTracking(-1),
 *   _cache[1] = createVNode(...),
 *   setBlockTracking(1),
 *   _cache[1]
 * )
 * ```
 *
 * @private
 */function setBlockTracking(value){isBlockTreeEnabled+=value;}function setupBlock(vnode){// save current block children on the block vnode
vnode.dynamicChildren=isBlockTreeEnabled>0?currentBlock||EMPTY_ARR:null;// close block
closeBlock();// a block is always going to be patched, so track it as a child of its
// parent block
if(isBlockTreeEnabled>0&&currentBlock){currentBlock.push(vnode);}return vnode;}/**
 * @private
 */function createElementBlock(type,props,children,patchFlag,dynamicProps,shapeFlag){return setupBlock(createBaseVNode(type,props,children,patchFlag,dynamicProps,shapeFlag,true/* isBlock */));}/**
 * Create a block root vnode. Takes the same exact arguments as `createVNode`.
 * A block root keeps track of dynamic nodes within the block in the
 * `dynamicChildren` array.
 *
 * @private
 */function createBlock(type,props,children,patchFlag,dynamicProps){return setupBlock(createVNode(type,props,children,patchFlag,dynamicProps,true/* isBlock: prevent a block from tracking itself */));}function isVNode(value){return value?value.__v_isVNode===true:false;}function isSameVNodeType(n1,n2){if(n2.shapeFlag&6/* COMPONENT */&&hmrDirtyComponents.has(n2.type)){// HMR only: if the component has been hot-updated, force a reload.
return false;}return n1.type===n2.type&&n1.key===n2.key;}var vnodeArgsTransformer;/**
 * Internal API for registering an arguments transform for createVNode
 * used for creating stubs in the test-utils
 * It is *internal* but needs to be exposed for test-utils to pick up proper
 * typings
 */function transformVNodeArgs(transformer){vnodeArgsTransformer=transformer;}var createVNodeWithArgsTransform=function createVNodeWithArgsTransform(){for(var _len10=arguments.length,args=new Array(_len10),_key19=0;_key19<_len10;_key19++){args[_key19]=arguments[_key19];}return _createVNode.apply(void 0,_toConsumableArray(vnodeArgsTransformer?vnodeArgsTransformer(args,currentRenderingInstance):args));};var InternalObjectKey="__vInternal";var normalizeKey=function normalizeKey(_ref25){var key=_ref25.key;return key!=null?key:null;};var normalizeRef=function normalizeRef(_ref26){var ref=_ref26.ref,ref_key=_ref26.ref_key,ref_for=_ref26.ref_for;return ref!=null?isString(ref)||isRef(ref)||isFunction(ref)?{i:currentRenderingInstance,r:ref,k:ref_key,f:!!ref_for}:ref:null;};function createBaseVNode(type){var props=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var children=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;var patchFlag=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;var dynamicProps=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;var shapeFlag=arguments.length>5&&arguments[5]!==undefined?arguments[5]:type===Fragment?0:1;var isBlockNode=arguments.length>6&&arguments[6]!==undefined?arguments[6]:false;var needFullChildrenNormalization=arguments.length>7&&arguments[7]!==undefined?arguments[7]:false;var vnode={__v_isVNode:true,__v_skip:true,type:type,props:props,key:props&&normalizeKey(props),ref:props&&normalizeRef(props),scopeId:currentScopeId,slotScopeIds:null,children:children,component:null,suspense:null,ssContent:null,ssFallback:null,dirs:null,transition:null,el:null,anchor:null,target:null,targetAnchor:null,staticCount:0,shapeFlag:shapeFlag,patchFlag:patchFlag,dynamicProps:dynamicProps,dynamicChildren:null,appContext:null};if(needFullChildrenNormalization){normalizeChildren(vnode,children);// normalize suspense children
if(shapeFlag&128/* SUSPENSE */){type.normalize(vnode);}}else if(children){// compiled element vnode - if children is passed, only possible types are
// string or Array.
vnode.shapeFlag|=isString(children)?8/* TEXT_CHILDREN */:16/* ARRAY_CHILDREN */;}// validate key
if(vnode.key!==vnode.key){warn$1("VNode created with invalid key (NaN). VNode type:",vnode.type);}// track vnode for block tree
if(isBlockTreeEnabled>0&&// avoid a block node from tracking itself
!isBlockNode&&// has current parent block
currentBlock&&(// presence of a patch flag indicates this node needs patching on updates.
// component nodes also should always be patched, because even if the
// component doesn't need to update, it needs to persist the instance on to
// the next vnode so that it can be properly unmounted later.
vnode.patchFlag>0||shapeFlag&6/* COMPONENT */)&&// the EVENTS flag is only for hydration and if it is the only flag, the
// vnode should not be considered dynamic due to handler caching.
vnode.patchFlag!==32/* HYDRATE_EVENTS */){currentBlock.push(vnode);}return vnode;}var createVNode=createVNodeWithArgsTransform;function _createVNode(type){var props=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;var children=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;var patchFlag=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;var dynamicProps=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;var isBlockNode=arguments.length>5&&arguments[5]!==undefined?arguments[5]:false;if(!type||type===NULL_DYNAMIC_COMPONENT){if(!type){warn$1("Invalid vnode type when creating vnode: ".concat(type,"."));}type=Comment;}if(isVNode(type)){// createVNode receiving an existing vnode. This happens in cases like
// <component :is="vnode"/>
// #2078 make sure to merge refs during the clone instead of overwriting it
var cloned=cloneVNode(type,props,true/* mergeRef: true */);if(children){normalizeChildren(cloned,children);}return cloned;}// class component normalization.
if(isClassComponent(type)){type=type.__vccOpts;}// class & style normalization.
if(props){// for reactive or proxy objects, we need to clone it to enable mutation.
props=guardReactiveProps(props);var _props2=props,klass=_props2.class,style=_props2.style;if(klass&&!isString(klass)){props.class=normalizeClass(klass);}if(isObject(style)){// reactive state objects need to be cloned since they are likely to be
// mutated
if(isProxy(style)&&!isArray(style)){style=extend({},style);}props.style=normalizeStyle(style);}}// encode the vnode type information into a bitmap
var shapeFlag=isString(type)?1/* ELEMENT */:isSuspense(type)?128/* SUSPENSE */:isTeleport(type)?64/* TELEPORT */:isObject(type)?4/* STATEFUL_COMPONENT */:isFunction(type)?2/* FUNCTIONAL_COMPONENT */:0;if(shapeFlag&4/* STATEFUL_COMPONENT */&&isProxy(type)){type=toRaw(type);warn$1("Vue received a Component which was made a reactive object. This can "+"lead to unnecessary performance overhead, and should be avoided by "+"marking the component with `markRaw` or using `shallowRef` "+"instead of `ref`.","\nComponent that was made reactive: ",type);}return createBaseVNode(type,props,children,patchFlag,dynamicProps,shapeFlag,isBlockNode,true);}function guardReactiveProps(props){if(!props)return null;return isProxy(props)||InternalObjectKey in props?extend({},props):props;}function cloneVNode(vnode,extraProps){var mergeRef=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;// This is intentionally NOT using spread or extend to avoid the runtime
// key enumeration cost.
var props=vnode.props,ref=vnode.ref,patchFlag=vnode.patchFlag,children=vnode.children;var mergedProps=extraProps?mergeProps(props||{},extraProps):props;var cloned={__v_isVNode:true,__v_skip:true,type:vnode.type,props:mergedProps,key:mergedProps&&normalizeKey(mergedProps),ref:extraProps&&extraProps.ref?// #2078 in the case of <component :is="vnode" ref="extra"/>
// if the vnode itself already has a ref, cloneVNode will need to merge
// the refs so the single vnode can be set on multiple refs
mergeRef&&ref?isArray(ref)?ref.concat(normalizeRef(extraProps)):[ref,normalizeRef(extraProps)]:normalizeRef(extraProps):ref,scopeId:vnode.scopeId,slotScopeIds:vnode.slotScopeIds,children:patchFlag===-1/* HOISTED */&&isArray(children)?children.map(deepCloneVNode):children,target:vnode.target,targetAnchor:vnode.targetAnchor,staticCount:vnode.staticCount,shapeFlag:vnode.shapeFlag,// if the vnode is cloned with extra props, we can no longer assume its
// existing patch flag to be reliable and need to add the FULL_PROPS flag.
// note: preserve flag for fragments since they use the flag for children
// fast paths only.
patchFlag:extraProps&&vnode.type!==Fragment?patchFlag===-1// hoisted node
?16/* FULL_PROPS */:patchFlag|16/* FULL_PROPS */:patchFlag,dynamicProps:vnode.dynamicProps,dynamicChildren:vnode.dynamicChildren,appContext:vnode.appContext,dirs:vnode.dirs,transition:vnode.transition,// These should technically only be non-null on mounted VNodes. However,
// they *should* be copied for kept-alive vnodes. So we just always copy
// them since them being non-null during a mount doesn't affect the logic as
// they will simply be overwritten.
component:vnode.component,suspense:vnode.suspense,ssContent:vnode.ssContent&&cloneVNode(vnode.ssContent),ssFallback:vnode.ssFallback&&cloneVNode(vnode.ssFallback),el:vnode.el,anchor:vnode.anchor};return cloned;}/**
 * Dev only, for HMR of hoisted vnodes reused in v-for
 * https://github.com/vitejs/vite/issues/2022
 */function deepCloneVNode(vnode){var cloned=cloneVNode(vnode);if(isArray(vnode.children)){cloned.children=vnode.children.map(deepCloneVNode);}return cloned;}/**
 * @private
 */function createTextVNode(){var text=arguments.length>0&&arguments[0]!==undefined?arguments[0]:' ';var flag=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;return createVNode(Text,null,text,flag);}/**
 * @private
 */function createStaticVNode(content,numberOfNodes){// A static vnode can contain multiple stringified elements, and the number
// of elements is necessary for hydration.
var vnode=createVNode(Static,null,content);vnode.staticCount=numberOfNodes;return vnode;}/**
 * @private
 */function createCommentVNode(){var text=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'';var asBlock=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return asBlock?(openBlock(),createBlock(Comment,null,text)):createVNode(Comment,null,text);}function normalizeVNode(child){if(child==null||typeof child==='boolean'){// empty placeholder
return createVNode(Comment);}else if(isArray(child)){// fragment
return createVNode(Fragment,null,// #3666, avoid reference pollution when reusing vnode
child.slice());}else if(_typeof(child)==='object'){// already vnode, this should be the most common since compiled templates
// always produce all-vnode children arrays
return cloneIfMounted(child);}else{// strings and numbers
return createVNode(Text,null,String(child));}}// optimized normalization for template-compiled render fns
function cloneIfMounted(child){return child.el===null||child.memo?child:cloneVNode(child);}function normalizeChildren(vnode,children){var type=0;var shapeFlag=vnode.shapeFlag;if(children==null){children=null;}else if(isArray(children)){type=16/* ARRAY_CHILDREN */;}else if(_typeof(children)==='object'){if(shapeFlag&(1/* ELEMENT */|64/* TELEPORT */)){// Normalize slot to plain children for plain element and Teleport
var slot=children.default;if(slot){// _c marker is added by withCtx() indicating this is a compiled slot
slot._c&&(slot._d=false);normalizeChildren(vnode,slot());slot._c&&(slot._d=true);}return;}else{type=32/* SLOTS_CHILDREN */;var slotFlag=children._;if(!slotFlag&&!(InternalObjectKey in children)){children._ctx=currentRenderingInstance;}else if(slotFlag===3/* FORWARDED */&&currentRenderingInstance){// a child component receives forwarded slots from the parent.
// its slot type is determined by its parent's slot type.
if(currentRenderingInstance.slots._===1/* STABLE */){children._=1/* STABLE */;}else{children._=2/* DYNAMIC */;vnode.patchFlag|=1024/* DYNAMIC_SLOTS */;}}}}else if(isFunction(children)){children={default:children,_ctx:currentRenderingInstance};type=32/* SLOTS_CHILDREN */;}else{children=String(children);// force teleport children to array so it can be moved around
if(shapeFlag&64/* TELEPORT */){type=16/* ARRAY_CHILDREN */;children=[createTextVNode(children)];}else{type=8/* TEXT_CHILDREN */;}}vnode.children=children;vnode.shapeFlag|=type;}function mergeProps(){var ret={};for(var i=0;i<arguments.length;i++){var toMerge=i<0||arguments.length<=i?undefined:arguments[i];for(var key in toMerge){if(key==='class'){if(ret.class!==toMerge.class){ret.class=normalizeClass([ret.class,toMerge.class]);}}else if(key==='style'){ret.style=normalizeStyle([ret.style,toMerge.style]);}else if(isOn(key)){var existing=ret[key];var incoming=toMerge[key];if(incoming&&existing!==incoming&&!(isArray(existing)&&existing.includes(incoming))){ret[key]=existing?[].concat(existing,incoming):incoming;}}else if(key!==''){ret[key]=toMerge[key];}}}return ret;}function invokeVNodeHook(hook,instance,vnode){var prevVNode=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;callWithAsyncErrorHandling(hook,instance,7/* VNODE_HOOK */,[vnode,prevVNode]);}/**
 * Actual implementation
 */function renderList(source,renderItem,cache,index){var ret;var cached=cache&&cache[index];if(isArray(source)||isString(source)){ret=new Array(source.length);for(var i=0,l=source.length;i<l;i++){ret[i]=renderItem(source[i],i,undefined,cached&&cached[i]);}}else if(typeof source==='number'){if(!Number.isInteger(source)){warn$1("The v-for range expect an integer value but got ".concat(source,"."));return[];}ret=new Array(source);for(var _i3=0;_i3<source;_i3++){ret[_i3]=renderItem(_i3+1,_i3,undefined,cached&&cached[_i3]);}}else if(isObject(source)){if(source[Symbol.iterator]){ret=Array.from(source,function(item,i){return renderItem(item,i,undefined,cached&&cached[i]);});}else{var keys=Object.keys(source);ret=new Array(keys.length);for(var _i4=0,_l=keys.length;_i4<_l;_i4++){var key=keys[_i4];ret[_i4]=renderItem(source[key],key,_i4,cached&&cached[_i4]);}}}else{ret=[];}if(cache){cache[index]=ret;}return ret;}/**
 * Compiler runtime helper for creating dynamic slots object
 * @private
 */function createSlots(slots,dynamicSlots){for(var i=0;i<dynamicSlots.length;i++){var slot=dynamicSlots[i];// array of dynamic slot generated by <template v-for="..." #[...]>
if(isArray(slot)){for(var j=0;j<slot.length;j++){slots[slot[j].name]=slot[j].fn;}}else if(slot){// conditional single slot generated by <template v-if="..." #foo>
slots[slot.name]=slot.fn;}}return slots;}/**
 * Compiler runtime helper for rendering `<slot/>`
 * @private
 */function renderSlot(slots,name){var props=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var// this is not a user-facing function, so the fallback is always generated by
// the compiler and guaranteed to be a function returning an array
fallback=arguments.length>3?arguments[3]:undefined;var noSlotted=arguments.length>4?arguments[4]:undefined;if(currentRenderingInstance.isCE){return createVNode('slot',name==='default'?null:{name:name},fallback&&fallback());}var slot=slots[name];if(slot&&slot.length>1){warn$1("SSR-optimized slot function detected in a non-SSR-optimized render "+"function. You need to mark this component with $dynamic-slots in the "+"parent template.");slot=function slot(){return[];};}// a compiled slot disables block tracking by default to avoid manual
// invocation interfering with template-based block tracking, but in
// `renderSlot` we can be sure that it's template-based so we can force
// enable it.
if(slot&&slot._c){slot._d=false;}openBlock();var validSlotContent=slot&&ensureValidVNode(slot(props));var rendered=createBlock(Fragment,{key:props.key||"_".concat(name)},validSlotContent||(fallback?fallback():[]),validSlotContent&&slots._===1/* STABLE */?64/* STABLE_FRAGMENT */:-2/* BAIL */);if(!noSlotted&&rendered.scopeId){rendered.slotScopeIds=[rendered.scopeId+'-s'];}if(slot&&slot._c){slot._d=true;}return rendered;}function ensureValidVNode(vnodes){return vnodes.some(function(child){if(!isVNode(child))return true;if(child.type===Comment)return false;if(child.type===Fragment&&!ensureValidVNode(child.children))return false;return true;})?vnodes:null;}/**
 * For prefixing keys in v-on="obj" with "on"
 * @private
 */function toHandlers(obj){var ret={};if(!isObject(obj)){warn$1("v-on with no argument expects an object value.");return ret;}for(var key in obj){ret[toHandlerKey(key)]=obj[key];}return ret;}/**
 * #2437 In Vue 3, functional components do not have a public instance proxy but
 * they exist in the internal parent chain. For code that relies on traversing
 * public $parent chains, skip functional ones and go to the parent instead.
 */var getPublicInstance=function getPublicInstance(i){if(!i)return null;if(isStatefulComponent(i))return getExposeProxy(i)||i.proxy;return getPublicInstance(i.parent);};var publicPropertiesMap=extend(Object.create(null),{$:function $(i){return i;},$el:function $el(i){return i.vnode.el;},$data:function $data(i){return i.data;},$props:function $props(i){return shallowReadonly(i.props);},$attrs:function $attrs(i){return shallowReadonly(i.attrs);},$slots:function $slots(i){return shallowReadonly(i.slots);},$refs:function $refs(i){return shallowReadonly(i.refs);},$parent:function $parent(i){return getPublicInstance(i.parent);},$root:function $root(i){return getPublicInstance(i.root);},$emit:function $emit(i){return i.emit;},$options:function $options(i){return resolveMergedOptions(i);},$forceUpdate:function $forceUpdate(i){return function(){return queueJob(i.update);};},$nextTick:function $nextTick(i){return nextTick.bind(i.proxy);},$watch:function $watch(i){return instanceWatch.bind(i);}});var PublicInstanceProxyHandlers={get:function get(_ref27,key){var instance=_ref27._;var ctx=instance.ctx,setupState=instance.setupState,data=instance.data,props=instance.props,accessCache=instance.accessCache,type=instance.type,appContext=instance.appContext;// for internal formatters to know that this is a Vue instance
if(key==='__isVue'){return true;}// prioritize <script setup> bindings during dev.
// this allows even properties that start with _ or $ to be used - so that
// it aligns with the production behavior where the render fn is inlined and
// indeed has access to all declared variables.
if(setupState!==EMPTY_OBJ&&setupState.__isScriptSetup&&hasOwn(setupState,key)){return setupState[key];}// data / props / ctx
// This getter gets called for every property access on the render context
// during render and is a major hotspot. The most expensive part of this
// is the multiple hasOwn() calls. It's much faster to do a simple property
// access on a plain object, so we use an accessCache object (with null
// prototype) to memoize what access type a key corresponds to.
var normalizedProps;if(key[0]!=='$'){var n=accessCache[key];if(n!==undefined){switch(n){case 1/* SETUP */:return setupState[key];case 2/* DATA */:return data[key];case 4/* CONTEXT */:return ctx[key];case 3/* PROPS */:return props[key];// default: just fallthrough
}}else if(setupState!==EMPTY_OBJ&&hasOwn(setupState,key)){accessCache[key]=1/* SETUP */;return setupState[key];}else if(data!==EMPTY_OBJ&&hasOwn(data,key)){accessCache[key]=2/* DATA */;return data[key];}else if(// only cache other properties when instance has declared (thus stable)
// props
(normalizedProps=instance.propsOptions[0])&&hasOwn(normalizedProps,key)){accessCache[key]=3/* PROPS */;return props[key];}else if(ctx!==EMPTY_OBJ&&hasOwn(ctx,key)){accessCache[key]=4/* CONTEXT */;return ctx[key];}else if(shouldCacheAccess){accessCache[key]=0/* OTHER */;}}var publicGetter=publicPropertiesMap[key];var cssModule,globalProperties;// public $xxx properties
if(publicGetter){if(key==='$attrs'){track(instance,"get"/* GET */,key);markAttrsAccessed();}return publicGetter(instance);}else if(// css module (injected by vue-loader)
(cssModule=type.__cssModules)&&(cssModule=cssModule[key])){return cssModule;}else if(ctx!==EMPTY_OBJ&&hasOwn(ctx,key)){// user may set custom properties to `this` that start with `$`
accessCache[key]=4/* CONTEXT */;return ctx[key];}else if(// global properties
globalProperties=appContext.config.globalProperties,hasOwn(globalProperties,key)){{return globalProperties[key];}}else if(currentRenderingInstance&&(!isString(key)||// #1091 avoid internal isRef/isVNode checks on component instance leading
// to infinite warning loop
key.indexOf('__v')!==0)){if(data!==EMPTY_OBJ&&(key[0]==='$'||key[0]==='_')&&hasOwn(data,key)){warn$1("Property ".concat(JSON.stringify(key)," must be accessed via $data because it starts with a reserved ")+"character (\"$\" or \"_\") and is not proxied on the render context.");}else if(instance===currentRenderingInstance){warn$1("Property ".concat(JSON.stringify(key)," was accessed during render ")+"but is not defined on instance.");}}},set:function set(_ref28,key,value){var instance=_ref28._;var data=instance.data,setupState=instance.setupState,ctx=instance.ctx;if(setupState!==EMPTY_OBJ&&hasOwn(setupState,key)){setupState[key]=value;return true;}else if(data!==EMPTY_OBJ&&hasOwn(data,key)){data[key]=value;return true;}else if(hasOwn(instance.props,key)){warn$1("Attempting to mutate prop \"".concat(key,"\". Props are readonly."),instance);return false;}if(key[0]==='$'&&key.slice(1)in instance){warn$1("Attempting to mutate public property \"".concat(key,"\". ")+"Properties starting with $ are reserved and readonly.",instance);return false;}else{if(key in instance.appContext.config.globalProperties){Object.defineProperty(ctx,key,{enumerable:true,configurable:true,value:value});}else{ctx[key]=value;}}return true;},has:function has(_ref29,key){var _ref29$_=_ref29._,data=_ref29$_.data,setupState=_ref29$_.setupState,accessCache=_ref29$_.accessCache,ctx=_ref29$_.ctx,appContext=_ref29$_.appContext,propsOptions=_ref29$_.propsOptions;var normalizedProps;return!!accessCache[key]||data!==EMPTY_OBJ&&hasOwn(data,key)||setupState!==EMPTY_OBJ&&hasOwn(setupState,key)||(normalizedProps=propsOptions[0])&&hasOwn(normalizedProps,key)||hasOwn(ctx,key)||hasOwn(publicPropertiesMap,key)||hasOwn(appContext.config.globalProperties,key);},defineProperty:function defineProperty(target,key,descriptor){if(descriptor.get!=null){this.set(target,key,descriptor.get(),null);}else if(descriptor.value!=null){this.set(target,key,descriptor.value,null);}return Reflect.defineProperty(target,key,descriptor);}};{PublicInstanceProxyHandlers.ownKeys=function(target){warn$1("Avoid app logic that relies on enumerating keys on a component instance. "+"The keys will be empty in production mode to avoid performance overhead.");return Reflect.ownKeys(target);};}var RuntimeCompiledPublicInstanceProxyHandlers=/*#__PURE__*/extend({},PublicInstanceProxyHandlers,{get:function get(target,key){// fast path for unscopables when using `with` block
if(key===Symbol.unscopables){return;}return PublicInstanceProxyHandlers.get(target,key,target);},has:function has(_,key){var has=key[0]!=='_'&&!isGloballyWhitelisted(key);if(!has&&PublicInstanceProxyHandlers.has(_,key)){warn$1("Property ".concat(JSON.stringify(key)," should not start with _ which is a reserved prefix for Vue internals."));}return has;}});// dev only
// In dev mode, the proxy target exposes the same properties as seen on `this`
// for easier console inspection. In prod mode it will be an empty object so
// these properties definitions can be skipped.
function createDevRenderContext(instance){var target={};// expose internal instance for proxy handlers
Object.defineProperty(target,"_",{configurable:true,enumerable:false,get:function get(){return instance;}});// expose public properties
Object.keys(publicPropertiesMap).forEach(function(key){Object.defineProperty(target,key,{configurable:true,enumerable:false,get:function get(){return publicPropertiesMap[key](instance);},// intercepted by the proxy so no need for implementation,
// but needed to prevent set errors
set:NOOP});});return target;}// dev only
function exposePropsOnRenderContext(instance){var ctx=instance.ctx,_instance$propsOption6=_slicedToArray(instance.propsOptions,1),propsOptions=_instance$propsOption6[0];if(propsOptions){Object.keys(propsOptions).forEach(function(key){Object.defineProperty(ctx,key,{enumerable:true,configurable:true,get:function get(){return instance.props[key];},set:NOOP});});}}// dev only
function exposeSetupStateOnRenderContext(instance){var ctx=instance.ctx,setupState=instance.setupState;Object.keys(toRaw(setupState)).forEach(function(key){if(!setupState.__isScriptSetup){if(key[0]==='$'||key[0]==='_'){warn$1("setup() return property ".concat(JSON.stringify(key)," should not start with \"$\" or \"_\" ")+"which are reserved prefixes for Vue internals.");return;}Object.defineProperty(ctx,key,{enumerable:true,configurable:true,get:function get(){return setupState[key];},set:NOOP});}});}var emptyAppContext=createAppContext();var uid$1=0;function createComponentInstance(vnode,parent,suspense){var type=vnode.type;// inherit parent app context - or - if root, adopt from root vnode
var appContext=(parent?parent.appContext:vnode.appContext)||emptyAppContext;var instance={uid:uid$1++,vnode:vnode,type:type,parent:parent,appContext:appContext,root:null,next:null,subTree:null,effect:null,update:null,scope:new EffectScope(true/* detached */),render:null,proxy:null,exposed:null,exposeProxy:null,withProxy:null,provides:parent?parent.provides:Object.create(appContext.provides),accessCache:null,renderCache:[],// local resovled assets
components:null,directives:null,// resolved props and emits options
propsOptions:normalizePropsOptions(type,appContext),emitsOptions:normalizeEmitsOptions(type,appContext),// emit
emit:null,emitted:null,// props default value
propsDefaults:EMPTY_OBJ,// inheritAttrs
inheritAttrs:type.inheritAttrs,// state
ctx:EMPTY_OBJ,data:EMPTY_OBJ,props:EMPTY_OBJ,attrs:EMPTY_OBJ,slots:EMPTY_OBJ,refs:EMPTY_OBJ,setupState:EMPTY_OBJ,setupContext:null,// suspense related
suspense:suspense,suspenseId:suspense?suspense.pendingId:0,asyncDep:null,asyncResolved:false,// lifecycle hooks
// not using enums here because it results in computed properties
isMounted:false,isUnmounted:false,isDeactivated:false,bc:null,c:null,bm:null,m:null,bu:null,u:null,um:null,bum:null,da:null,a:null,rtg:null,rtc:null,ec:null,sp:null};{instance.ctx=createDevRenderContext(instance);}instance.root=parent?parent.root:instance;instance.emit=emit$1.bind(null,instance);// apply custom element special handling
if(vnode.ce){vnode.ce(instance);}return instance;}var currentInstance=null;var getCurrentInstance=function getCurrentInstance(){return currentInstance||currentRenderingInstance;};var setCurrentInstance=function setCurrentInstance(instance){currentInstance=instance;instance.scope.on();};var unsetCurrentInstance=function unsetCurrentInstance(){currentInstance&&currentInstance.scope.off();currentInstance=null;};var isBuiltInTag=/*#__PURE__*/makeMap('slot,component');function validateComponentName(name,config){var appIsNativeTag=config.isNativeTag||NO;if(isBuiltInTag(name)||appIsNativeTag(name)){warn$1('Do not use built-in or reserved HTML elements as component id: '+name);}}function isStatefulComponent(instance){return instance.vnode.shapeFlag&4/* STATEFUL_COMPONENT */;}var isInSSRComponentSetup=false;function setupComponent(instance){var isSSR=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;isInSSRComponentSetup=isSSR;var _instance$vnode=instance.vnode,props=_instance$vnode.props,children=_instance$vnode.children;var isStateful=isStatefulComponent(instance);initProps(instance,props,isStateful,isSSR);initSlots(instance,children);var setupResult=isStateful?setupStatefulComponent(instance,isSSR):undefined;isInSSRComponentSetup=false;return setupResult;}function setupStatefulComponent(instance,isSSR){var Component=instance.type;{if(Component.name){validateComponentName(Component.name,instance.appContext.config);}if(Component.components){var names=Object.keys(Component.components);for(var i=0;i<names.length;i++){validateComponentName(names[i],instance.appContext.config);}}if(Component.directives){var _names=Object.keys(Component.directives);for(var _i5=0;_i5<_names.length;_i5++){validateDirectiveName(_names[_i5]);}}if(Component.compilerOptions&&isRuntimeOnly()){warn$1("\"compilerOptions\" is only supported when using a build of Vue that "+"includes the runtime compiler. Since you are using a runtime-only "+"build, the options should be passed via your build tool config instead.");}}// 0. create render proxy property access cache
instance.accessCache=Object.create(null);// 1. create public instance / render proxy
// also mark it raw so it's never observed
instance.proxy=markRaw(new Proxy(instance.ctx,PublicInstanceProxyHandlers));{exposePropsOnRenderContext(instance);}// 2. call setup()
var setup=Component.setup;if(setup){var setupContext=instance.setupContext=setup.length>1?createSetupContext(instance):null;setCurrentInstance(instance);pauseTracking();var setupResult=callWithErrorHandling(setup,instance,0/* SETUP_FUNCTION */,[shallowReadonly(instance.props),setupContext]);resetTracking();unsetCurrentInstance();if(isPromise(setupResult)){setupResult.then(unsetCurrentInstance,unsetCurrentInstance);if(isSSR){// return the promise so server-renderer can wait on it
return setupResult.then(function(resolvedResult){handleSetupResult(instance,resolvedResult,isSSR);}).catch(function(e){handleError(e,instance,0/* SETUP_FUNCTION */);});}else{// async setup returned Promise.
// bail here and wait for re-entry.
instance.asyncDep=setupResult;}}else{handleSetupResult(instance,setupResult,isSSR);}}else{finishComponentSetup(instance,isSSR);}}function handleSetupResult(instance,setupResult,isSSR){if(isFunction(setupResult)){// setup returned an inline render function
{instance.render=setupResult;}}else if(isObject(setupResult)){if(isVNode(setupResult)){warn$1("setup() should not return VNodes directly - "+"return a render function instead.");}// setup returned bindings.
// assuming a render function compiled from template is present.
{instance.devtoolsRawSetupState=setupResult;}instance.setupState=proxyRefs(setupResult);{exposeSetupStateOnRenderContext(instance);}}else if(setupResult!==undefined){warn$1("setup() should return an object. Received: ".concat(setupResult===null?'null':_typeof(setupResult)));}finishComponentSetup(instance,isSSR);}var compile;var installWithProxy;/**
 * For runtime-dom to register the compiler.
 * Note the exported method uses any to avoid d.ts relying on the compiler types.
 */function registerRuntimeCompiler(_compile){compile=_compile;installWithProxy=function installWithProxy(i){if(i.render._rc){i.withProxy=new Proxy(i.ctx,RuntimeCompiledPublicInstanceProxyHandlers);}};}// dev only
var isRuntimeOnly=function isRuntimeOnly(){return!compile;};function finishComponentSetup(instance,isSSR,skipOptions){var Component=instance.type;// template / render function normalization
// could be already set when returned from setup()
if(!instance.render){// only do on-the-fly compile if not in SSR - SSR on-the-fly compilation
// is done by server-renderer
if(!isSSR&&compile&&!Component.render){var template=Component.template;if(template){{startMeasure(instance,"compile");}var _instance$appContext$=instance.appContext.config,isCustomElement=_instance$appContext$.isCustomElement,compilerOptions=_instance$appContext$.compilerOptions;var delimiters=Component.delimiters,componentCompilerOptions=Component.compilerOptions;var finalCompilerOptions=extend(extend({isCustomElement:isCustomElement,delimiters:delimiters},compilerOptions),componentCompilerOptions);Component.render=compile(template,finalCompilerOptions);{endMeasure(instance,"compile");}}}instance.render=Component.render||NOOP;// for runtime-compiled render functions using `with` blocks, the render
// proxy used needs a different `has` handler which is more performant and
// also only allows a whitelist of globals to fallthrough.
if(installWithProxy){installWithProxy(instance);}}// support for 2.x options
{setCurrentInstance(instance);pauseTracking();applyOptions(instance);resetTracking();unsetCurrentInstance();}// warn missing template/render
// the runtime compilation of template in SSR is done by server-render
if(!Component.render&&instance.render===NOOP&&!isSSR){/* istanbul ignore if */if(!compile&&Component.template){warn$1("Component provided template option but "+"runtime compilation is not supported in this build of Vue."+" Use \"vue.esm-browser.js\" instead."/* should not happen */);}else{warn$1("Component is missing template or render function.");}}}function createAttrsProxy(instance){return new Proxy(instance.attrs,{get:function get(target,key){markAttrsAccessed();track(instance,"get"/* GET */,'$attrs');return target[key];},set:function set(){warn$1("setupContext.attrs is readonly.");return false;},deleteProperty:function deleteProperty(){warn$1("setupContext.attrs is readonly.");return false;}});}function createSetupContext(instance){var expose=function expose(exposed){if(instance.exposed){warn$1("expose() should be called only once per setup().");}instance.exposed=exposed||{};};var attrs;{// We use getters in dev in case libs like test-utils overwrite instance
// properties (overwrites should not be done in prod)
return Object.freeze({get attrs(){return attrs||(attrs=createAttrsProxy(instance));},get slots(){return shallowReadonly(instance.slots);},get emit(){return function(event){for(var _len11=arguments.length,args=new Array(_len11>1?_len11-1:0),_key20=1;_key20<_len11;_key20++){args[_key20-1]=arguments[_key20];}return instance.emit.apply(instance,[event].concat(args));};},expose:expose});}}function getExposeProxy(instance){if(instance.exposed){return instance.exposeProxy||(instance.exposeProxy=new Proxy(proxyRefs(markRaw(instance.exposed)),{get:function get(target,key){if(key in target){return target[key];}else if(key in publicPropertiesMap){return publicPropertiesMap[key](instance);}}}));}}var classifyRE=/(?:^|[-_])(\w)/g;var classify=function classify(str){return str.replace(classifyRE,function(c){return c.toUpperCase();}).replace(/[-_]/g,'');};function getComponentName(Component){return isFunction(Component)?Component.displayName||Component.name:Component.name;}/* istanbul ignore next */function formatComponentName(instance,Component){var isRoot=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var name=getComponentName(Component);if(!name&&Component.__file){var match=Component.__file.match(/([^/\\]+)\.\w+$/);if(match){name=match[1];}}if(!name&&instance&&instance.parent){// try to infer the name based on reverse resolution
var inferFromRegistry=function inferFromRegistry(registry){for(var key in registry){if(registry[key]===Component){return key;}}};name=inferFromRegistry(instance.components||instance.parent.type.components)||inferFromRegistry(instance.appContext.components);}return name?classify(name):isRoot?"App":"Anonymous";}function isClassComponent(value){return isFunction(value)&&'__vccOpts'in value;}var computed$1=function computed$1(getterOrOptions,debugOptions){// @ts-ignore
return computed(getterOrOptions,debugOptions,isInSSRComponentSetup);};// dev only
var warnRuntimeUsage=function warnRuntimeUsage(method){return warn$1("".concat(method,"() is a compiler-hint helper that is only usable inside ")+"<script setup> of a single file component. Its arguments should be "+"compiled away and passing it at runtime has no effect.");};// implementation
function defineProps(){{warnRuntimeUsage("defineProps");}return null;}// implementation
function defineEmits(){{warnRuntimeUsage("defineEmits");}return null;}/**
 * Vue `<script setup>` compiler macro for declaring a component's exposed
 * instance properties when it is accessed by a parent component via template
 * refs.
 *
 * `<script setup>` components are closed by default - i.e. variables inside
 * the `<script setup>` scope is not exposed to parent unless explicitly exposed
 * via `defineExpose`.
 *
 * This is only usable inside `<script setup>`, is compiled away in the
 * output and should **not** be actually called at runtime.
 */function defineExpose(exposed){{warnRuntimeUsage("defineExpose");}}/**
 * Vue `<script setup>` compiler macro for providing props default values when
 * using type-based `defineProps` declaration.
 *
 * Example usage:
 * ```ts
 * withDefaults(defineProps<{
 *   size?: number
 *   labels?: string[]
 * }>(), {
 *   size: 3,
 *   labels: () => ['default label']
 * })
 * ```
 *
 * This is only usable inside `<script setup>`, is compiled away in the output
 * and should **not** be actually called at runtime.
 */function withDefaults(props,defaults){{warnRuntimeUsage("withDefaults");}return null;}function useSlots(){return getContext().slots;}function useAttrs(){return getContext().attrs;}function getContext(){var i=getCurrentInstance();if(!i){warn$1("useContext() called without active instance.");}return i.setupContext||(i.setupContext=createSetupContext(i));}/**
 * Runtime helper for merging default declarations. Imported by compiled code
 * only.
 * @internal
 */function mergeDefaults(raw,defaults){var props=isArray(raw)?raw.reduce(function(normalized,p){return normalized[p]={},normalized;},{}):raw;for(var key in defaults){var opt=props[key];if(opt){if(isArray(opt)||isFunction(opt)){props[key]={type:opt,default:defaults[key]};}else{opt.default=defaults[key];}}else if(opt===null){props[key]={default:defaults[key]};}else{warn$1("props default key \"".concat(key,"\" has no corresponding declaration."));}}return props;}/**
 * Used to create a proxy for the rest element when destructuring props with
 * defineProps().
 * @internal
 */function createPropsRestProxy(props,excludedKeys){var ret={};var _loop4=function _loop4(key){if(!excludedKeys.includes(key)){Object.defineProperty(ret,key,{enumerable:true,get:function get(){return props[key];}});}};for(var key in props){_loop4(key);}return ret;}/**
 * `<script setup>` helper for persisting the current instance context over
 * async/await flows.
 *
 * `@vue/compiler-sfc` converts the following:
 *
 * ```ts
 * const x = await foo()
 * ```
 *
 * into:
 *
 * ```ts
 * let __temp, __restore
 * const x = (([__temp, __restore] = withAsyncContext(() => foo())),__temp=await __temp,__restore(),__temp)
 * ```
 * @internal
 */function withAsyncContext(getAwaitable){var ctx=getCurrentInstance();if(!ctx){warn$1("withAsyncContext called without active current instance. "+"This is likely a bug.");}var awaitable=getAwaitable();unsetCurrentInstance();if(isPromise(awaitable)){awaitable=awaitable.catch(function(e){setCurrentInstance(ctx);throw e;});}return[awaitable,function(){return setCurrentInstance(ctx);}];}// Actual implementation
function h(type,propsOrChildren,children){var l=arguments.length;if(l===2){if(isObject(propsOrChildren)&&!isArray(propsOrChildren)){// single vnode without props
if(isVNode(propsOrChildren)){return createVNode(type,null,[propsOrChildren]);}// props without children
return createVNode(type,propsOrChildren);}else{// omit props
return createVNode(type,null,propsOrChildren);}}else{if(l>3){children=Array.prototype.slice.call(arguments,2);}else if(l===3&&isVNode(children)){children=[children];}return createVNode(type,propsOrChildren,children);}}var ssrContextKey=Symbol("ssrContext");var useSSRContext=function useSSRContext(){{var ctx=inject(ssrContextKey);if(!ctx){warn$1("Server rendering context not provided. Make sure to only call "+"useSSRContext() conditionally in the server build.");}return ctx;}};function initCustomFormatter(){/* eslint-disable no-restricted-globals */if(typeof window==='undefined'){return;}var vueStyle={style:'color:#3ba776'};var numberStyle={style:'color:#0b1bc9'};var stringStyle={style:'color:#b62e24'};var keywordStyle={style:'color:#9d288c'};// custom formatter for Chrome
// https://www.mattzeunert.com/2016/02/19/custom-chrome-devtools-object-formatters.html
var formatter={header:function header(obj){// TODO also format ComponentPublicInstance & ctx.slots/attrs in setup
if(!isObject(obj)){return null;}if(obj.__isVue){return['div',vueStyle,"VueInstance"];}else if(isRef(obj)){return['div',{},['span',vueStyle,genRefFlag(obj)],'<',formatValue(obj.value),">"];}else if(isReactive(obj)){return['div',{},['span',vueStyle,isShallow(obj)?'ShallowReactive':'Reactive'],'<',formatValue(obj),">".concat(isReadonly(obj)?" (readonly)":"")];}else if(isReadonly(obj)){return['div',{},['span',vueStyle,isShallow(obj)?'ShallowReadonly':'Readonly'],'<',formatValue(obj),'>'];}return null;},hasBody:function hasBody(obj){return obj&&obj.__isVue;},body:function body(obj){if(obj&&obj.__isVue){return['div',{}].concat(_toConsumableArray(formatInstance(obj.$)));}}};function formatInstance(instance){var blocks=[];if(instance.type.props&&instance.props){blocks.push(createInstanceBlock('props',toRaw(instance.props)));}if(instance.setupState!==EMPTY_OBJ){blocks.push(createInstanceBlock('setup',instance.setupState));}if(instance.data!==EMPTY_OBJ){blocks.push(createInstanceBlock('data',toRaw(instance.data)));}var computed=extractKeys(instance,'computed');if(computed){blocks.push(createInstanceBlock('computed',computed));}var injected=extractKeys(instance,'inject');if(injected){blocks.push(createInstanceBlock('injected',injected));}blocks.push(['div',{},['span',{style:keywordStyle.style+';opacity:0.66'},'$ (internal): '],['object',{object:instance}]]);return blocks;}function createInstanceBlock(type,target){target=extend({},target);if(!Object.keys(target).length){return['span',{}];}return['div',{style:'line-height:1.25em;margin-bottom:0.6em'},['div',{style:'color:#476582'},type],['div',{style:'padding-left:1.25em'}].concat(_toConsumableArray(Object.keys(target).map(function(key){return['div',{},['span',keywordStyle,key+': '],formatValue(target[key],false)];})))];}function formatValue(v){var asRaw=arguments.length>1&&arguments[1]!==undefined?arguments[1]:true;if(typeof v==='number'){return['span',numberStyle,v];}else if(typeof v==='string'){return['span',stringStyle,JSON.stringify(v)];}else if(typeof v==='boolean'){return['span',keywordStyle,v];}else if(isObject(v)){return['object',{object:asRaw?toRaw(v):v}];}else{return['span',stringStyle,String(v)];}}function extractKeys(instance,type){var Comp=instance.type;if(isFunction(Comp)){return;}var extracted={};for(var key in instance.ctx){if(isKeyOfType(Comp,key,type)){extracted[key]=instance.ctx[key];}}return extracted;}function isKeyOfType(Comp,key,type){var opts=Comp[type];if(isArray(opts)&&opts.includes(key)||isObject(opts)&&key in opts){return true;}if(Comp.extends&&isKeyOfType(Comp.extends,key,type)){return true;}if(Comp.mixins&&Comp.mixins.some(function(m){return isKeyOfType(m,key,type);})){return true;}}function genRefFlag(v){if(isShallow(v)){return"ShallowRef";}if(v.effect){return"ComputedRef";}return"Ref";}if(window.devtoolsFormatters){window.devtoolsFormatters.push(formatter);}else{window.devtoolsFormatters=[formatter];}}function withMemo(memo,render,cache,index){var cached=cache[index];if(cached&&isMemoSame(cached,memo)){return cached;}var ret=render();// shallow clone
ret.memo=memo.slice();return cache[index]=ret;}function isMemoSame(cached,memo){var prev=cached.memo;if(prev.length!=memo.length){return false;}for(var i=0;i<prev.length;i++){if(prev[i]!==memo[i]){return false;}}// make sure to let parent block track it when returning cached
if(isBlockTreeEnabled>0&&currentBlock){currentBlock.push(cached);}return true;}// Core API ------------------------------------------------------------------
var version="3.2.31";/**
 * SSR utils for \@vue/server-renderer. Only exposed in cjs builds.
 * @internal
 */var ssrUtils=null;/**
 * @internal only exposed in compat builds
 */var resolveFilter=null;/**
 * @internal only exposed in compat builds.
 */var compatUtils=null;var svgNS='http://www.w3.org/2000/svg';var doc=typeof document!=='undefined'?document:null;var templateContainer=doc&&doc.createElement('template');var nodeOps={insert:function insert(child,parent,anchor){parent.insertBefore(child,anchor||null);},remove:function remove(child){var parent=child.parentNode;if(parent){parent.removeChild(child);}},createElement:function createElement(tag,isSVG,is,props){var el=isSVG?doc.createElementNS(svgNS,tag):doc.createElement(tag,is?{is:is}:undefined);if(tag==='select'&&props&&props.multiple!=null){el.setAttribute('multiple',props.multiple);}return el;},createText:function createText(text){return doc.createTextNode(text);},createComment:function createComment(text){return doc.createComment(text);},setText:function setText(node,text){node.nodeValue=text;},setElementText:function setElementText(el,text){el.textContent=text;},parentNode:function parentNode(node){return node.parentNode;},nextSibling:function nextSibling(node){return node.nextSibling;},querySelector:function querySelector(selector){return doc.querySelector(selector);},setScopeId:function setScopeId(el,id){el.setAttribute(id,'');},cloneNode:function cloneNode(el){var cloned=el.cloneNode(true);// #3072
// - in `patchDOMProp`, we store the actual value in the `el._value` property.
// - normally, elements using `:value` bindings will not be hoisted, but if
//   the bound value is a constant, e.g. `:value="true"` - they do get
//   hoisted.
// - in production, hoisted nodes are cloned when subsequent inserts, but
//   cloneNode() does not copy the custom property we attached.
// - This may need to account for other custom DOM properties we attach to
//   elements in addition to `_value` in the future.
if("_value"in el){cloned._value=el._value;}return cloned;},// __UNSAFE__
// Reason: innerHTML.
// Static content here can only come from compiled templates.
// As long as the user only uses trusted templates, this is safe.
insertStaticContent:function insertStaticContent(content,parent,anchor,isSVG,start,end){// <parent> before | first ... last | anchor </parent>
var before=anchor?anchor.previousSibling:parent.lastChild;// #5308 can only take cached path if:
// - has a single root node
// - nextSibling info is still available
if(start&&(start===end||start.nextSibling)){// cached
while(true){parent.insertBefore(start.cloneNode(true),anchor);if(start===end||!(start=start.nextSibling))break;}}else{// fresh insert
templateContainer.innerHTML=isSVG?"<svg>".concat(content,"</svg>"):content;var template=templateContainer.content;if(isSVG){// remove outer svg wrapper
var wrapper=template.firstChild;while(wrapper.firstChild){template.appendChild(wrapper.firstChild);}template.removeChild(wrapper);}parent.insertBefore(template,anchor);}return[// first
before?before.nextSibling:parent.firstChild,// last
anchor?anchor.previousSibling:parent.lastChild];}};// compiler should normalize class + :class bindings on the same element
// into a single binding ['staticClass', dynamic]
function patchClass(el,value,isSVG){// directly setting className should be faster than setAttribute in theory
// if this is an element during a transition, take the temporary transition
// classes into account.
var transitionClasses=el._vtc;if(transitionClasses){value=(value?[value].concat(_toConsumableArray(transitionClasses)):_toConsumableArray(transitionClasses)).join(' ');}if(value==null){el.removeAttribute('class');}else if(isSVG){el.setAttribute('class',value);}else{el.className=value;}}function patchStyle(el,prev,next){var style=el.style;var isCssString=isString(next);if(next&&!isCssString){for(var key in next){setStyle(style,key,next[key]);}if(prev&&!isString(prev)){for(var _key21 in prev){if(next[_key21]==null){setStyle(style,_key21,'');}}}}else{var currentDisplay=style.display;if(isCssString){if(prev!==next){style.cssText=next;}}else if(prev){el.removeAttribute('style');}// indicates that the `display` of the element is controlled by `v-show`,
// so we always keep the current `display` value regardless of the `style`
// value, thus handing over control to `v-show`.
if('_vod'in el){style.display=currentDisplay;}}}var importantRE=/\s*!important$/;function setStyle(style,name,val){if(isArray(val)){val.forEach(function(v){return setStyle(style,name,v);});}else{if(name.startsWith('--')){// custom property definition
style.setProperty(name,val);}else{var prefixed=autoPrefix(style,name);if(importantRE.test(val)){// !important
style.setProperty(hyphenate(prefixed),val.replace(importantRE,''),'important');}else{style[prefixed]=val;}}}}var prefixes=['Webkit','Moz','ms'];var prefixCache={};function autoPrefix(style,rawName){var cached=prefixCache[rawName];if(cached){return cached;}var name=camelize(rawName);if(name!=='filter'&&name in style){return prefixCache[rawName]=name;}name=capitalize(name);for(var i=0;i<prefixes.length;i++){var prefixed=prefixes[i]+name;if(prefixed in style){return prefixCache[rawName]=prefixed;}}return rawName;}var xlinkNS='http://www.w3.org/1999/xlink';function patchAttr(el,key,value,isSVG,instance){if(isSVG&&key.startsWith('xlink:')){if(value==null){el.removeAttributeNS(xlinkNS,key.slice(6,key.length));}else{el.setAttributeNS(xlinkNS,key,value);}}else{// note we are only checking boolean attributes that don't have a
// corresponding dom prop of the same name here.
var _isBoolean=isSpecialBooleanAttr(key);if(value==null||_isBoolean&&!includeBooleanAttr(value)){el.removeAttribute(key);}else{el.setAttribute(key,_isBoolean?'':value);}}}// __UNSAFE__
// functions. The user is responsible for using them with only trusted content.
function patchDOMProp(el,key,value,// the following args are passed only due to potential innerHTML/textContent
// overriding existing VNodes, in which case the old tree must be properly
// unmounted.
prevChildren,parentComponent,parentSuspense,unmountChildren){if(key==='innerHTML'||key==='textContent'){if(prevChildren){unmountChildren(prevChildren,parentComponent,parentSuspense);}el[key]=value==null?'':value;return;}if(key==='value'&&el.tagName!=='PROGRESS'&&// custom elements may use _value internally
!el.tagName.includes('-')){// store value as _value as well since
// non-string values will be stringified.
el._value=value;var newValue=value==null?'':value;if(el.value!==newValue||// #4956: always set for OPTION elements because its value falls back to
// textContent if no value attribute is present. And setting .value for
// OPTION has no side effect
el.tagName==='OPTION'){el.value=newValue;}if(value==null){el.removeAttribute(key);}return;}if(value===''||value==null){var type=_typeof(el[key]);if(type==='boolean'){// e.g. <select multiple> compiles to { multiple: '' }
el[key]=includeBooleanAttr(value);return;}else if(value==null&&type==='string'){// e.g. <div :id="null">
el[key]='';el.removeAttribute(key);return;}else if(type==='number'){// e.g. <img :width="null">
// the value of some IDL attr must be greater than 0, e.g. input.size = 0 -> error
try{el[key]=0;}catch(_a){}el.removeAttribute(key);return;}}// some properties perform value validation and throw
try{el[key]=value;}catch(e){{warn$1("Failed setting prop \"".concat(key,"\" on <").concat(el.tagName.toLowerCase(),">: ")+"value ".concat(value," is invalid."),e);}}}// Async edge case fix requires storing an event listener's attach timestamp.
var _getNow=Date.now;var skipTimestampCheck=false;if(typeof window!=='undefined'){// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
if(_getNow()>document.createEvent('Event').timeStamp){// if the low-res timestamp which is bigger than the event timestamp
// (which is evaluated AFTER) it means the event is using a hi-res timestamp,
// and we need to use the hi-res version for event listeners as well.
_getNow=function _getNow(){return performance.now();};}// #3485: Firefox <= 53 has incorrect Event.timeStamp implementation
// and does not fire microtasks in between event propagation, so safe to exclude.
var ffMatch=navigator.userAgent.match(/firefox\/(\d+)/i);skipTimestampCheck=!!(ffMatch&&Number(ffMatch[1])<=53);}// To avoid the overhead of repeatedly calling performance.now(), we cache
// and use the same timestamp for all event listeners attached in the same tick.
var cachedNow=0;var p=Promise.resolve();var reset=function reset(){cachedNow=0;};var getNow=function getNow(){return cachedNow||(p.then(reset),cachedNow=_getNow());};function addEventListener(el,event,handler,options){el.addEventListener(event,handler,options);}function removeEventListener(el,event,handler,options){el.removeEventListener(event,handler,options);}function patchEvent(el,rawName,prevValue,nextValue){var instance=arguments.length>4&&arguments[4]!==undefined?arguments[4]:null;// vei = vue event invokers
var invokers=el._vei||(el._vei={});var existingInvoker=invokers[rawName];if(nextValue&&existingInvoker){// patch
existingInvoker.value=nextValue;}else{var _parseName=parseName(rawName),_parseName2=_slicedToArray(_parseName,2),name=_parseName2[0],options=_parseName2[1];if(nextValue){// add
var invoker=invokers[rawName]=createInvoker(nextValue,instance);addEventListener(el,name,invoker,options);}else if(existingInvoker){// remove
removeEventListener(el,name,existingInvoker,options);invokers[rawName]=undefined;}}}var optionsModifierRE=/(?:Once|Passive|Capture)$/;function parseName(name){var options;if(optionsModifierRE.test(name)){options={};var m;while(m=name.match(optionsModifierRE)){name=name.slice(0,name.length-m[0].length);options[m[0].toLowerCase()]=true;}}return[hyphenate(name.slice(2)),options];}function createInvoker(initialValue,instance){var invoker=function invoker(e){// async edge case #6566: inner click event triggers patch, event handler
// attached to outer element during patch, and triggered again. This
// happens because browsers fire microtask ticks between event propagation.
// the solution is simple: we save the timestamp when a handler is attached,
// and the handler would only fire if the event passed to it was fired
// AFTER it was attached.
var timeStamp=e.timeStamp||_getNow();if(skipTimestampCheck||timeStamp>=invoker.attached-1){callWithAsyncErrorHandling(patchStopImmediatePropagation(e,invoker.value),instance,5/* NATIVE_EVENT_HANDLER */,[e]);}};invoker.value=initialValue;invoker.attached=getNow();return invoker;}function patchStopImmediatePropagation(e,value){if(isArray(value)){var originalStop=e.stopImmediatePropagation;e.stopImmediatePropagation=function(){originalStop.call(e);e._stopped=true;};return value.map(function(fn){return function(e){return!e._stopped&&fn&&fn(e);};});}else{return value;}}var nativeOnRE=/^on[a-z]/;var patchProp=function patchProp(el,key,prevValue,nextValue){var isSVG=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;var prevChildren=arguments.length>5?arguments[5]:undefined;var parentComponent=arguments.length>6?arguments[6]:undefined;var parentSuspense=arguments.length>7?arguments[7]:undefined;var unmountChildren=arguments.length>8?arguments[8]:undefined;if(key==='class'){patchClass(el,nextValue,isSVG);}else if(key==='style'){patchStyle(el,prevValue,nextValue);}else if(isOn(key)){// ignore v-model listeners
if(!isModelListener(key)){patchEvent(el,key,prevValue,nextValue,parentComponent);}}else if(key[0]==='.'?(key=key.slice(1),true):key[0]==='^'?(key=key.slice(1),false):shouldSetAsProp(el,key,nextValue,isSVG)){patchDOMProp(el,key,nextValue,prevChildren,parentComponent,parentSuspense,unmountChildren);}else{// special case for <input v-model type="checkbox"> with
// :true-value & :false-value
// store value as dom properties since non-string values will be
// stringified.
if(key==='true-value'){el._trueValue=nextValue;}else if(key==='false-value'){el._falseValue=nextValue;}patchAttr(el,key,nextValue,isSVG);}};function shouldSetAsProp(el,key,value,isSVG){if(isSVG){// most keys must be set as attribute on svg elements to work
// ...except innerHTML & textContent
if(key==='innerHTML'||key==='textContent'){return true;}// or native onclick with function values
if(key in el&&nativeOnRE.test(key)&&isFunction(value)){return true;}return false;}// spellcheck and draggable are numerated attrs, however their
// corresponding DOM properties are actually booleans - this leads to
// setting it with a string "false" value leading it to be coerced to
// `true`, so we need to always treat them as attributes.
// Note that `contentEditable` doesn't have this problem: its DOM
// property is also enumerated string values.
if(key==='spellcheck'||key==='draggable'){return false;}// #1787, #2840 form property on form elements is readonly and must be set as
// attribute.
if(key==='form'){return false;}// #1526 <input list> must be set as attribute
if(key==='list'&&el.tagName==='INPUT'){return false;}// #2766 <textarea type> must be set as attribute
if(key==='type'&&el.tagName==='TEXTAREA'){return false;}// native onclick with string value, must be set as attribute
if(nativeOnRE.test(key)&&isString(value)){return false;}return key in el;}function defineCustomElement(options,hydate){var Comp=defineComponent(options);var VueCustomElement=/*#__PURE__*/function(_VueElement){_inherits(VueCustomElement,_VueElement);var _super=_createSuper(VueCustomElement);function VueCustomElement(initialProps){_classCallCheck(this,VueCustomElement);return _super.call(this,Comp,initialProps,hydate);}return VueCustomElement;}(VueElement);VueCustomElement.def=Comp;return VueCustomElement;}var defineSSRCustomElement=function defineSSRCustomElement(options){// @ts-ignore
return defineCustomElement(options,hydrate);};var BaseClass=typeof HTMLElement!=='undefined'?HTMLElement:/*#__PURE__*/function(){function _class(){_classCallCheck(this,_class);}return _class;}();var VueElement=/*#__PURE__*/function(_BaseClass){_inherits(VueElement,_BaseClass);var _super2=_createSuper(VueElement);function VueElement(_def){var _this3;var _props=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var hydrate=arguments.length>2?arguments[2]:undefined;_classCallCheck(this,VueElement);_this3=_super2.call(this);_this3._def=_def;_this3._props=_props;/**
         * @internal
         */_this3._instance=null;_this3._connected=false;_this3._resolved=false;_this3._numberProps=null;if(_this3.shadowRoot&&hydrate){hydrate(_this3._createVNode(),_this3.shadowRoot);}else{if(_this3.shadowRoot){warn$1("Custom element has pre-rendered declarative shadow root but is not "+"defined as hydratable. Use `defineSSRCustomElement`.");}_this3.attachShadow({mode:'open'});}return _this3;}_createClass(VueElement,[{key:"connectedCallback",value:function connectedCallback(){this._connected=true;if(!this._instance){this._resolveDef();}}},{key:"disconnectedCallback",value:function disconnectedCallback(){var _this4=this;this._connected=false;nextTick(function(){if(!_this4._connected){render(null,_this4.shadowRoot);_this4._instance=null;}});}/**
     * resolve inner component definition (handle possible async component)
     */},{key:"_resolveDef",value:function _resolveDef(){var _this5=this;if(this._resolved){return;}this._resolved=true;// set initial attrs
for(var i=0;i<this.attributes.length;i++){this._setAttr(this.attributes[i].name);}// watch future attr changes
new MutationObserver(function(mutations){var _iterator5=_createForOfIteratorHelper(mutations),_step5;try{for(_iterator5.s();!(_step5=_iterator5.n()).done;){var m=_step5.value;_this5._setAttr(m.attributeName);}}catch(err){_iterator5.e(err);}finally{_iterator5.f();}}).observe(this,{attributes:true});var resolve=function resolve(def){var props=def.props,styles=def.styles;var hasOptions=!isArray(props);var rawKeys=props?hasOptions?Object.keys(props):props:[];// cast Number-type props set before resolve
var numberProps;if(hasOptions){for(var key in _this5._props){var opt=props[key];if(opt===Number||opt&&opt.type===Number){_this5._props[key]=toNumber(_this5._props[key]);(numberProps||(numberProps=Object.create(null)))[key]=true;}}}_this5._numberProps=numberProps;// check if there are props set pre-upgrade or connect
for(var _i6=0,_Object$keys=Object.keys(_this5);_i6<_Object$keys.length;_i6++){var _key22=_Object$keys[_i6];if(_key22[0]!=='_'){_this5._setProp(_key22,_this5[_key22],true,false);}}// defining getter/setters on prototype
var _iterator6=_createForOfIteratorHelper(rawKeys.map(camelize)),_step6;try{var _loop5=function _loop5(){var key=_step6.value;Object.defineProperty(_this5,key,{get:function get(){return this._getProp(key);},set:function set(val){this._setProp(key,val);}});};for(_iterator6.s();!(_step6=_iterator6.n()).done;){_loop5();}// apply CSS
}catch(err){_iterator6.e(err);}finally{_iterator6.f();}_this5._applyStyles(styles);// initial render
_this5._update();};var asyncDef=this._def.__asyncLoader;if(asyncDef){asyncDef().then(resolve);}else{resolve(this._def);}}},{key:"_setAttr",value:function _setAttr(key){var value=this.getAttribute(key);if(this._numberProps&&this._numberProps[key]){value=toNumber(value);}this._setProp(camelize(key),value,false);}/**
     * @internal
     */},{key:"_getProp",value:function _getProp(key){return this._props[key];}/**
     * @internal
     */},{key:"_setProp",value:function _setProp(key,val){var shouldReflect=arguments.length>2&&arguments[2]!==undefined?arguments[2]:true;var shouldUpdate=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;if(val!==this._props[key]){this._props[key]=val;if(shouldUpdate&&this._instance){this._update();}// reflect
if(shouldReflect){if(val===true){this.setAttribute(hyphenate(key),'');}else if(typeof val==='string'||typeof val==='number'){this.setAttribute(hyphenate(key),val+'');}else if(!val){this.removeAttribute(hyphenate(key));}}}}},{key:"_update",value:function _update(){render(this._createVNode(),this.shadowRoot);}},{key:"_createVNode",value:function _createVNode(){var _this6=this;var vnode=createVNode(this._def,extend({},this._props));if(!this._instance){vnode.ce=function(instance){_this6._instance=instance;instance.isCE=true;// HMR
{instance.ceReload=function(newStyles){// always reset styles
if(_this6._styles){_this6._styles.forEach(function(s){return _this6.shadowRoot.removeChild(s);});_this6._styles.length=0;}_this6._applyStyles(newStyles);// if this is an async component, ceReload is called from the inner
// component so no need to reload the async wrapper
if(!_this6._def.__asyncLoader){// reload
_this6._instance=null;_this6._update();}};}// intercept emit
instance.emit=function(event){for(var _len12=arguments.length,args=new Array(_len12>1?_len12-1:0),_key23=1;_key23<_len12;_key23++){args[_key23-1]=arguments[_key23];}_this6.dispatchEvent(new CustomEvent(event,{detail:args}));};// locate nearest Vue custom element parent for provide/inject
var parent=_this6;while(parent=parent&&(parent.parentNode||parent.host)){if(parent instanceof VueElement){instance.parent=parent._instance;break;}}};}return vnode;}},{key:"_applyStyles",value:function _applyStyles(styles){var _this7=this;if(styles){styles.forEach(function(css){var s=document.createElement('style');s.textContent=css;_this7.shadowRoot.appendChild(s);// record for HMR
{(_this7._styles||(_this7._styles=[])).push(s);}});}}}]);return VueElement;}(BaseClass);function useCssModule(){var name=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'$style';/* istanbul ignore else */{var instance=getCurrentInstance();if(!instance){warn$1("useCssModule must be called inside setup()");return EMPTY_OBJ;}var modules=instance.type.__cssModules;if(!modules){warn$1("Current instance does not have CSS modules injected.");return EMPTY_OBJ;}var mod=modules[name];if(!mod){warn$1("Current instance does not have CSS module named \"".concat(name,"\"."));return EMPTY_OBJ;}return mod;}}/**
 * Runtime helper for SFC's CSS variable injection feature.
 * @private
 */function useCssVars(getter){var instance=getCurrentInstance();/* istanbul ignore next */if(!instance){warn$1("useCssVars is called without current active component instance.");return;}var setVars=function setVars(){return setVarsOnVNode(instance.subTree,getter(instance.proxy));};watchPostEffect(setVars);onMounted(function(){var ob=new MutationObserver(setVars);ob.observe(instance.subTree.el.parentNode,{childList:true});onUnmounted(function(){return ob.disconnect();});});}function setVarsOnVNode(vnode,vars){if(vnode.shapeFlag&128/* SUSPENSE */){var suspense=vnode.suspense;vnode=suspense.activeBranch;if(suspense.pendingBranch&&!suspense.isHydrating){suspense.effects.push(function(){setVarsOnVNode(suspense.activeBranch,vars);});}}// drill down HOCs until it's a non-component vnode
while(vnode.component){vnode=vnode.component.subTree;}if(vnode.shapeFlag&1/* ELEMENT */&&vnode.el){setVarsOnNode(vnode.el,vars);}else if(vnode.type===Fragment){vnode.children.forEach(function(c){return setVarsOnVNode(c,vars);});}else if(vnode.type===Static){var _vnode=vnode,el=_vnode.el,anchor=_vnode.anchor;while(el){setVarsOnNode(el,vars);if(el===anchor)break;el=el.nextSibling;}}}function setVarsOnNode(el,vars){if(el.nodeType===1){var style=el.style;for(var key in vars){style.setProperty("--".concat(key),vars[key]);}}}var TRANSITION='transition';var ANIMATION='animation';// DOM Transition is a higher-order-component based on the platform-agnostic
// base Transition component, with DOM-specific logic.
var Transition=function Transition(props,_ref30){var slots=_ref30.slots;return h(BaseTransition,resolveTransitionProps(props),slots);};Transition.displayName='Transition';var DOMTransitionPropsValidators={name:String,type:String,css:{type:Boolean,default:true},duration:[String,Number,Object],enterFromClass:String,enterActiveClass:String,enterToClass:String,appearFromClass:String,appearActiveClass:String,appearToClass:String,leaveFromClass:String,leaveActiveClass:String,leaveToClass:String};var TransitionPropsValidators=Transition.props=/*#__PURE__*/extend({},BaseTransition.props,DOMTransitionPropsValidators);/**
 * #3227 Incoming hooks may be merged into arrays when wrapping Transition
 * with custom HOCs.
 */var callHook$1=function callHook$1(hook){var args=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];if(isArray(hook)){hook.forEach(function(h){return h.apply(void 0,_toConsumableArray(args));});}else if(hook){hook.apply(void 0,_toConsumableArray(args));}};/**
 * Check if a hook expects a callback (2nd arg), which means the user
 * intends to explicitly control the end of the transition.
 */var hasExplicitCallback=function hasExplicitCallback(hook){return hook?isArray(hook)?hook.some(function(h){return h.length>1;}):hook.length>1:false;};function resolveTransitionProps(rawProps){var baseProps={};for(var key in rawProps){if(!(key in DOMTransitionPropsValidators)){baseProps[key]=rawProps[key];}}if(rawProps.css===false){return baseProps;}var _rawProps$name=rawProps.name,name=_rawProps$name===void 0?'v':_rawProps$name,type=rawProps.type,duration=rawProps.duration,_rawProps$enterFromCl=rawProps.enterFromClass,enterFromClass=_rawProps$enterFromCl===void 0?"".concat(name,"-enter-from"):_rawProps$enterFromCl,_rawProps$enterActive=rawProps.enterActiveClass,enterActiveClass=_rawProps$enterActive===void 0?"".concat(name,"-enter-active"):_rawProps$enterActive,_rawProps$enterToClas=rawProps.enterToClass,enterToClass=_rawProps$enterToClas===void 0?"".concat(name,"-enter-to"):_rawProps$enterToClas,_rawProps$appearFromC=rawProps.appearFromClass,appearFromClass=_rawProps$appearFromC===void 0?enterFromClass:_rawProps$appearFromC,_rawProps$appearActiv=rawProps.appearActiveClass,appearActiveClass=_rawProps$appearActiv===void 0?enterActiveClass:_rawProps$appearActiv,_rawProps$appearToCla=rawProps.appearToClass,appearToClass=_rawProps$appearToCla===void 0?enterToClass:_rawProps$appearToCla,_rawProps$leaveFromCl=rawProps.leaveFromClass,leaveFromClass=_rawProps$leaveFromCl===void 0?"".concat(name,"-leave-from"):_rawProps$leaveFromCl,_rawProps$leaveActive=rawProps.leaveActiveClass,leaveActiveClass=_rawProps$leaveActive===void 0?"".concat(name,"-leave-active"):_rawProps$leaveActive,_rawProps$leaveToClas=rawProps.leaveToClass,leaveToClass=_rawProps$leaveToClas===void 0?"".concat(name,"-leave-to"):_rawProps$leaveToClas;var durations=normalizeDuration(duration);var enterDuration=durations&&durations[0];var leaveDuration=durations&&durations[1];var _onBeforeEnter=baseProps.onBeforeEnter,onEnter=baseProps.onEnter,_onEnterCancelled=baseProps.onEnterCancelled,_onLeave=baseProps.onLeave,_onLeaveCancelled=baseProps.onLeaveCancelled,_baseProps$onBeforeAp=baseProps.onBeforeAppear,_onBeforeAppear=_baseProps$onBeforeAp===void 0?_onBeforeEnter:_baseProps$onBeforeAp,_baseProps$onAppear=baseProps.onAppear,onAppear=_baseProps$onAppear===void 0?onEnter:_baseProps$onAppear,_baseProps$onAppearCa=baseProps.onAppearCancelled,_onAppearCancelled=_baseProps$onAppearCa===void 0?_onEnterCancelled:_baseProps$onAppearCa;var finishEnter=function finishEnter(el,isAppear,done){removeTransitionClass(el,isAppear?appearToClass:enterToClass);removeTransitionClass(el,isAppear?appearActiveClass:enterActiveClass);done&&done();};var finishLeave=function finishLeave(el,done){removeTransitionClass(el,leaveToClass);removeTransitionClass(el,leaveActiveClass);done&&done();};var makeEnterHook=function makeEnterHook(isAppear){return function(el,done){var hook=isAppear?onAppear:onEnter;var resolve=function resolve(){return finishEnter(el,isAppear,done);};callHook$1(hook,[el,resolve]);nextFrame(function(){removeTransitionClass(el,isAppear?appearFromClass:enterFromClass);addTransitionClass(el,isAppear?appearToClass:enterToClass);if(!hasExplicitCallback(hook)){whenTransitionEnds(el,type,enterDuration,resolve);}});};};return extend(baseProps,{onBeforeEnter:function onBeforeEnter(el){callHook$1(_onBeforeEnter,[el]);addTransitionClass(el,enterFromClass);addTransitionClass(el,enterActiveClass);},onBeforeAppear:function onBeforeAppear(el){callHook$1(_onBeforeAppear,[el]);addTransitionClass(el,appearFromClass);addTransitionClass(el,appearActiveClass);},onEnter:makeEnterHook(false),onAppear:makeEnterHook(true),onLeave:function onLeave(el,done){var resolve=function resolve(){return finishLeave(el,done);};addTransitionClass(el,leaveFromClass);// force reflow so *-leave-from classes immediately take effect (#2593)
forceReflow();addTransitionClass(el,leaveActiveClass);nextFrame(function(){removeTransitionClass(el,leaveFromClass);addTransitionClass(el,leaveToClass);if(!hasExplicitCallback(_onLeave)){whenTransitionEnds(el,type,leaveDuration,resolve);}});callHook$1(_onLeave,[el,resolve]);},onEnterCancelled:function onEnterCancelled(el){finishEnter(el,false);callHook$1(_onEnterCancelled,[el]);},onAppearCancelled:function onAppearCancelled(el){finishEnter(el,true);callHook$1(_onAppearCancelled,[el]);},onLeaveCancelled:function onLeaveCancelled(el){finishLeave(el);callHook$1(_onLeaveCancelled,[el]);}});}function normalizeDuration(duration){if(duration==null){return null;}else if(isObject(duration)){return[NumberOf(duration.enter),NumberOf(duration.leave)];}else{var n=NumberOf(duration);return[n,n];}}function NumberOf(val){var res=toNumber(val);validateDuration(res);return res;}function validateDuration(val){if(typeof val!=='number'){warn$1("<transition> explicit duration is not a valid number - "+"got ".concat(JSON.stringify(val),"."));}else if(isNaN(val)){warn$1("<transition> explicit duration is NaN - "+'the duration expression might be incorrect.');}}function addTransitionClass(el,cls){cls.split(/\s+/).forEach(function(c){return c&&el.classList.add(c);});(el._vtc||(el._vtc=new Set())).add(cls);}function removeTransitionClass(el,cls){cls.split(/\s+/).forEach(function(c){return c&&el.classList.remove(c);});var _vtc=el._vtc;if(_vtc){_vtc.delete(cls);if(!_vtc.size){el._vtc=undefined;}}}function nextFrame(cb){requestAnimationFrame(function(){requestAnimationFrame(cb);});}var endId=0;function whenTransitionEnds(el,expectedType,explicitTimeout,resolve){var id=el._endId=++endId;var resolveIfNotStale=function resolveIfNotStale(){if(id===el._endId){resolve();}};if(explicitTimeout){return setTimeout(resolveIfNotStale,explicitTimeout);}var _getTransitionInfo=getTransitionInfo(el,expectedType),type=_getTransitionInfo.type,timeout=_getTransitionInfo.timeout,propCount=_getTransitionInfo.propCount;if(!type){return resolve();}var endEvent=type+'end';var ended=0;var end=function end(){el.removeEventListener(endEvent,onEnd);resolveIfNotStale();};var onEnd=function onEnd(e){if(e.target===el&&++ended>=propCount){end();}};setTimeout(function(){if(ended<propCount){end();}},timeout+1);el.addEventListener(endEvent,onEnd);}function getTransitionInfo(el,expectedType){var styles=window.getComputedStyle(el);// JSDOM may return undefined for transition properties
var getStyleProperties=function getStyleProperties(key){return(styles[key]||'').split(', ');};var transitionDelays=getStyleProperties(TRANSITION+'Delay');var transitionDurations=getStyleProperties(TRANSITION+'Duration');var transitionTimeout=getTimeout(transitionDelays,transitionDurations);var animationDelays=getStyleProperties(ANIMATION+'Delay');var animationDurations=getStyleProperties(ANIMATION+'Duration');var animationTimeout=getTimeout(animationDelays,animationDurations);var type=null;var timeout=0;var propCount=0;/* istanbul ignore if */if(expectedType===TRANSITION){if(transitionTimeout>0){type=TRANSITION;timeout=transitionTimeout;propCount=transitionDurations.length;}}else if(expectedType===ANIMATION){if(animationTimeout>0){type=ANIMATION;timeout=animationTimeout;propCount=animationDurations.length;}}else{timeout=Math.max(transitionTimeout,animationTimeout);type=timeout>0?transitionTimeout>animationTimeout?TRANSITION:ANIMATION:null;propCount=type?type===TRANSITION?transitionDurations.length:animationDurations.length:0;}var hasTransform=type===TRANSITION&&/\b(transform|all)(,|$)/.test(styles[TRANSITION+'Property']);return{type:type,timeout:timeout,propCount:propCount,hasTransform:hasTransform};}function getTimeout(delays,durations){while(delays.length<durations.length){delays=delays.concat(delays);}return Math.max.apply(Math,_toConsumableArray(durations.map(function(d,i){return toMs(d)+toMs(delays[i]);})));}// Old versions of Chromium (below 61.0.3163.100) formats floating pointer
// numbers in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down
// (i.e. acting as a floor function) causing unexpected behaviors
function toMs(s){return Number(s.slice(0,-1).replace(',','.'))*1000;}// synchronously force layout to put elements into a certain state
function forceReflow(){return document.body.offsetHeight;}var positionMap=new WeakMap();var newPositionMap=new WeakMap();var TransitionGroupImpl={name:'TransitionGroup',props:/*#__PURE__*/extend({},TransitionPropsValidators,{tag:String,moveClass:String}),setup:function setup(props,_ref31){var slots=_ref31.slots;var instance=getCurrentInstance();var state=useTransitionState();var prevChildren;var children;onUpdated(function(){// children is guaranteed to exist after initial render
if(!prevChildren.length){return;}var moveClass=props.moveClass||"".concat(props.name||'v',"-move");if(!hasCSSTransform(prevChildren[0].el,instance.vnode.el,moveClass)){return;}// we divide the work into three loops to avoid mixing DOM reads and writes
// in each iteration - which helps prevent layout thrashing.
prevChildren.forEach(callPendingCbs);prevChildren.forEach(recordPosition);var movedChildren=prevChildren.filter(applyTranslation);// force reflow to put everything in position
forceReflow();movedChildren.forEach(function(c){var el=c.el;var style=el.style;addTransitionClass(el,moveClass);style.transform=style.webkitTransform=style.transitionDuration='';var cb=el._moveCb=function(e){if(e&&e.target!==el){return;}if(!e||/transform$/.test(e.propertyName)){el.removeEventListener('transitionend',cb);el._moveCb=null;removeTransitionClass(el,moveClass);}};el.addEventListener('transitionend',cb);});});return function(){var rawProps=toRaw(props);var cssTransitionProps=resolveTransitionProps(rawProps);var tag=rawProps.tag||Fragment;prevChildren=children;children=slots.default?getTransitionRawChildren(slots.default()):[];for(var i=0;i<children.length;i++){var child=children[i];if(child.key!=null){setTransitionHooks(child,resolveTransitionHooks(child,cssTransitionProps,state,instance));}else{warn$1("<TransitionGroup> children must be keyed.");}}if(prevChildren){for(var _i7=0;_i7<prevChildren.length;_i7++){var _child=prevChildren[_i7];setTransitionHooks(_child,resolveTransitionHooks(_child,cssTransitionProps,state,instance));positionMap.set(_child,_child.el.getBoundingClientRect());}}return createVNode(tag,null,children);};}};var TransitionGroup=TransitionGroupImpl;function callPendingCbs(c){var el=c.el;if(el._moveCb){el._moveCb();}if(el._enterCb){el._enterCb();}}function recordPosition(c){newPositionMap.set(c,c.el.getBoundingClientRect());}function applyTranslation(c){var oldPos=positionMap.get(c);var newPos=newPositionMap.get(c);var dx=oldPos.left-newPos.left;var dy=oldPos.top-newPos.top;if(dx||dy){var s=c.el.style;s.transform=s.webkitTransform="translate(".concat(dx,"px,").concat(dy,"px)");s.transitionDuration='0s';return c;}}function hasCSSTransform(el,root,moveClass){// Detect whether an element with the move class applied has
// CSS transitions. Since the element may be inside an entering
// transition at this very moment, we make a clone of it and remove
// all other transition classes applied to ensure only the move class
// is applied.
var clone=el.cloneNode();if(el._vtc){el._vtc.forEach(function(cls){cls.split(/\s+/).forEach(function(c){return c&&clone.classList.remove(c);});});}moveClass.split(/\s+/).forEach(function(c){return c&&clone.classList.add(c);});clone.style.display='none';var container=root.nodeType===1?root:root.parentNode;container.appendChild(clone);var _getTransitionInfo2=getTransitionInfo(clone),hasTransform=_getTransitionInfo2.hasTransform;container.removeChild(clone);return hasTransform;}var getModelAssigner=function getModelAssigner(vnode){var fn=vnode.props['onUpdate:modelValue'];return isArray(fn)?function(value){return invokeArrayFns(fn,value);}:fn;};function onCompositionStart(e){e.target.composing=true;}function onCompositionEnd(e){var target=e.target;if(target.composing){target.composing=false;trigger$1(target,'input');}}function trigger$1(el,type){var e=document.createEvent('HTMLEvents');e.initEvent(type,true,true);el.dispatchEvent(e);}// We are exporting the v-model runtime directly as vnode hooks so that it can
// be tree-shaken in case v-model is never used.
var vModelText={created:function created(el,_ref32,vnode){var _ref32$modifiers=_ref32.modifiers,lazy=_ref32$modifiers.lazy,trim=_ref32$modifiers.trim,number=_ref32$modifiers.number;el._assign=getModelAssigner(vnode);var castToNumber=number||vnode.props&&vnode.props.type==='number';addEventListener(el,lazy?'change':'input',function(e){if(e.target.composing)return;var domValue=el.value;if(trim){domValue=domValue.trim();}else if(castToNumber){domValue=toNumber(domValue);}el._assign(domValue);});if(trim){addEventListener(el,'change',function(){el.value=el.value.trim();});}if(!lazy){addEventListener(el,'compositionstart',onCompositionStart);addEventListener(el,'compositionend',onCompositionEnd);// Safari < 10.2 & UIWebView doesn't fire compositionend when
// switching focus before confirming composition choice
// this also fixes the issue where some browsers e.g. iOS Chrome
// fires "change" instead of "input" on autocomplete.
addEventListener(el,'change',onCompositionEnd);}},// set value on mounted so it's after min/max for type="range"
mounted:function mounted(el,_ref33){var value=_ref33.value;el.value=value==null?'':value;},beforeUpdate:function beforeUpdate(el,_ref34,vnode){var value=_ref34.value,_ref34$modifiers=_ref34.modifiers,lazy=_ref34$modifiers.lazy,trim=_ref34$modifiers.trim,number=_ref34$modifiers.number;el._assign=getModelAssigner(vnode);// avoid clearing unresolved text. #2302
if(el.composing)return;if(document.activeElement===el){if(lazy){return;}if(trim&&el.value.trim()===value){return;}if((number||el.type==='number')&&toNumber(el.value)===value){return;}}var newValue=value==null?'':value;if(el.value!==newValue){el.value=newValue;}}};var vModelCheckbox={// #4096 array checkboxes need to be deep traversed
deep:true,created:function created(el,_,vnode){el._assign=getModelAssigner(vnode);addEventListener(el,'change',function(){var modelValue=el._modelValue;var elementValue=getValue(el);var checked=el.checked;var assign=el._assign;if(isArray(modelValue)){var index=looseIndexOf(modelValue,elementValue);var found=index!==-1;if(checked&&!found){assign(modelValue.concat(elementValue));}else if(!checked&&found){var filtered=_toConsumableArray(modelValue);filtered.splice(index,1);assign(filtered);}}else if(isSet(modelValue)){var cloned=new Set(modelValue);if(checked){cloned.add(elementValue);}else{cloned.delete(elementValue);}assign(cloned);}else{assign(getCheckboxValue(el,checked));}});},// set initial checked on mount to wait for true-value/false-value
mounted:setChecked,beforeUpdate:function beforeUpdate(el,binding,vnode){el._assign=getModelAssigner(vnode);setChecked(el,binding,vnode);}};function setChecked(el,_ref35,vnode){var value=_ref35.value,oldValue=_ref35.oldValue;el._modelValue=value;if(isArray(value)){el.checked=looseIndexOf(value,vnode.props.value)>-1;}else if(isSet(value)){el.checked=value.has(vnode.props.value);}else if(value!==oldValue){el.checked=looseEqual(value,getCheckboxValue(el,true));}}var vModelRadio={created:function created(el,_ref36,vnode){var value=_ref36.value;el.checked=looseEqual(value,vnode.props.value);el._assign=getModelAssigner(vnode);addEventListener(el,'change',function(){el._assign(getValue(el));});},beforeUpdate:function beforeUpdate(el,_ref37,vnode){var value=_ref37.value,oldValue=_ref37.oldValue;el._assign=getModelAssigner(vnode);if(value!==oldValue){el.checked=looseEqual(value,vnode.props.value);}}};var vModelSelect={// <select multiple> value need to be deep traversed
deep:true,created:function created(el,_ref38,vnode){var value=_ref38.value,number=_ref38.modifiers.number;var isSetModel=isSet(value);addEventListener(el,'change',function(){var selectedVal=Array.prototype.filter.call(el.options,function(o){return o.selected;}).map(function(o){return number?toNumber(getValue(o)):getValue(o);});el._assign(el.multiple?isSetModel?new Set(selectedVal):selectedVal:selectedVal[0]);});el._assign=getModelAssigner(vnode);},// set value in mounted & updated because <select> relies on its children
// <option>s.
mounted:function mounted(el,_ref39){var value=_ref39.value;setSelected(el,value);},beforeUpdate:function beforeUpdate(el,_binding,vnode){el._assign=getModelAssigner(vnode);},updated:function updated(el,_ref40){var value=_ref40.value;setSelected(el,value);}};function setSelected(el,value){var isMultiple=el.multiple;if(isMultiple&&!isArray(value)&&!isSet(value)){warn$1("<select multiple v-model> expects an Array or Set value for its binding, "+"but got ".concat(Object.prototype.toString.call(value).slice(8,-1),"."));return;}for(var i=0,l=el.options.length;i<l;i++){var option=el.options[i];var optionValue=getValue(option);if(isMultiple){if(isArray(value)){option.selected=looseIndexOf(value,optionValue)>-1;}else{option.selected=value.has(optionValue);}}else{if(looseEqual(getValue(option),value)){if(el.selectedIndex!==i)el.selectedIndex=i;return;}}}if(!isMultiple&&el.selectedIndex!==-1){el.selectedIndex=-1;}}// retrieve raw value set via :value bindings
function getValue(el){return'_value'in el?el._value:el.value;}// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings
function getCheckboxValue(el,checked){var key=checked?'_trueValue':'_falseValue';return key in el?el[key]:checked;}var vModelDynamic={created:function created(el,binding,vnode){callModelHook(el,binding,vnode,null,'created');},mounted:function mounted(el,binding,vnode){callModelHook(el,binding,vnode,null,'mounted');},beforeUpdate:function beforeUpdate(el,binding,vnode,prevVNode){callModelHook(el,binding,vnode,prevVNode,'beforeUpdate');},updated:function updated(el,binding,vnode,prevVNode){callModelHook(el,binding,vnode,prevVNode,'updated');}};function callModelHook(el,binding,vnode,prevVNode,hook){var modelToUse;switch(el.tagName){case'SELECT':modelToUse=vModelSelect;break;case'TEXTAREA':modelToUse=vModelText;break;default:switch(vnode.props&&vnode.props.type){case'checkbox':modelToUse=vModelCheckbox;break;case'radio':modelToUse=vModelRadio;break;default:modelToUse=vModelText;}}var fn=modelToUse[hook];fn&&fn(el,binding,vnode,prevVNode);}var systemModifiers=['ctrl','shift','alt','meta'];var modifierGuards={stop:function stop(e){return e.stopPropagation();},prevent:function prevent(e){return e.preventDefault();},self:function self(e){return e.target!==e.currentTarget;},ctrl:function ctrl(e){return!e.ctrlKey;},shift:function shift(e){return!e.shiftKey;},alt:function alt(e){return!e.altKey;},meta:function meta(e){return!e.metaKey;},left:function left(e){return'button'in e&&e.button!==0;},middle:function middle(e){return'button'in e&&e.button!==1;},right:function right(e){return'button'in e&&e.button!==2;},exact:function exact(e,modifiers){return systemModifiers.some(function(m){return e["".concat(m,"Key")]&&!modifiers.includes(m);});}};/**
 * @private
 */var withModifiers=function withModifiers(fn,modifiers){return function(event){for(var i=0;i<modifiers.length;i++){var guard=modifierGuards[modifiers[i]];if(guard&&guard(event,modifiers))return;}for(var _len13=arguments.length,args=new Array(_len13>1?_len13-1:0),_key24=1;_key24<_len13;_key24++){args[_key24-1]=arguments[_key24];}return fn.apply(void 0,[event].concat(args));};};// Kept for 2.x compat.
// Note: IE11 compat for `spacebar` and `del` is removed for now.
var keyNames={esc:'escape',space:' ',up:'arrow-up',left:'arrow-left',right:'arrow-right',down:'arrow-down',delete:'backspace'};/**
 * @private
 */var withKeys=function withKeys(fn,modifiers){return function(event){if(!('key'in event)){return;}var eventKey=hyphenate(event.key);if(modifiers.some(function(k){return k===eventKey||keyNames[k]===eventKey;})){return fn(event);}};};var vShow={beforeMount:function beforeMount(el,_ref41,_ref42){var value=_ref41.value;var transition=_ref42.transition;el._vod=el.style.display==='none'?'':el.style.display;if(transition&&value){transition.beforeEnter(el);}else{setDisplay(el,value);}},mounted:function mounted(el,_ref43,_ref44){var value=_ref43.value;var transition=_ref44.transition;if(transition&&value){transition.enter(el);}},updated:function updated(el,_ref45,_ref46){var value=_ref45.value,oldValue=_ref45.oldValue;var transition=_ref46.transition;if(!value===!oldValue)return;if(transition){if(value){transition.beforeEnter(el);setDisplay(el,true);transition.enter(el);}else{transition.leave(el,function(){setDisplay(el,false);});}}else{setDisplay(el,value);}},beforeUnmount:function beforeUnmount(el,_ref47){var value=_ref47.value;setDisplay(el,value);}};function setDisplay(el,value){el.style.display=value?el._vod:'none';}var rendererOptions=extend({patchProp:patchProp},nodeOps);// lazy create the renderer - this makes core renderer logic tree-shakable
// in case the user only imports reactivity utilities from Vue.
var renderer;var enabledHydration=false;function ensureRenderer(){return renderer||(renderer=createRenderer(rendererOptions));}function ensureHydrationRenderer(){renderer=enabledHydration?renderer:createHydrationRenderer(rendererOptions);enabledHydration=true;return renderer;}// use explicit type casts here to avoid import() calls in rolled-up d.ts
var render=function render(){var _ensureRenderer;(_ensureRenderer=ensureRenderer()).render.apply(_ensureRenderer,arguments);};var hydrate=function hydrate(){var _ensureHydrationRende;(_ensureHydrationRende=ensureHydrationRenderer()).hydrate.apply(_ensureHydrationRende,arguments);};var createApp=function createApp(){var _ensureRenderer2;var app=(_ensureRenderer2=ensureRenderer()).createApp.apply(_ensureRenderer2,arguments);{injectNativeTagCheck(app);injectCompilerOptionsCheck(app);}var mount=app.mount;app.mount=function(containerOrSelector){var container=normalizeContainer(containerOrSelector);if(!container)return;var component=app._component;if(!isFunction(component)&&!component.render&&!component.template){// __UNSAFE__
// Reason: potential execution of JS expressions in in-DOM template.
// The user must make sure the in-DOM template is trusted. If it's
// rendered by the server, the template should not contain any user data.
component.template=container.innerHTML;}// clear content before mounting
container.innerHTML='';var proxy=mount(container,false,container instanceof SVGElement);if(container instanceof Element){container.removeAttribute('v-cloak');container.setAttribute('data-v-app','');}return proxy;};return app;};var createSSRApp=function createSSRApp(){var _ensureHydrationRende2;var app=(_ensureHydrationRende2=ensureHydrationRenderer()).createApp.apply(_ensureHydrationRende2,arguments);{injectNativeTagCheck(app);injectCompilerOptionsCheck(app);}var mount=app.mount;app.mount=function(containerOrSelector){var container=normalizeContainer(containerOrSelector);if(container){return mount(container,true,container instanceof SVGElement);}};return app;};function injectNativeTagCheck(app){// Inject `isNativeTag`
// this is used for component name validation (dev only)
Object.defineProperty(app.config,'isNativeTag',{value:function value(tag){return isHTMLTag(tag)||isSVGTag(tag);},writable:false});}// dev only
function injectCompilerOptionsCheck(app){if(isRuntimeOnly()){var isCustomElement=app.config.isCustomElement;Object.defineProperty(app.config,'isCustomElement',{get:function get(){return isCustomElement;},set:function set(){warn$1("The `isCustomElement` config option is deprecated. Use "+"`compilerOptions.isCustomElement` instead.");}});var compilerOptions=app.config.compilerOptions;var msg="The `compilerOptions` config option is only respected when using "+"a build of Vue.js that includes the runtime compiler (aka \"full build\"). "+"Since you are using the runtime-only build, `compilerOptions` "+"must be passed to `@vue/compiler-dom` in the build setup instead.\n"+"- For vue-loader: pass it via vue-loader's `compilerOptions` loader option.\n"+"- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n"+"- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom";Object.defineProperty(app.config,'compilerOptions',{get:function get(){warn$1(msg);return compilerOptions;},set:function set(){warn$1(msg);}});}}function normalizeContainer(container){if(isString(container)){var res=document.querySelector(container);if(!res){warn$1("Failed to mount app: mount target selector \"".concat(container,"\" returned null."));}return res;}if(window.ShadowRoot&&container instanceof window.ShadowRoot&&container.mode==='closed'){warn$1("mounting on a ShadowRoot with `{mode: \"closed\"}` may lead to unpredictable bugs");}return container;}/**
 * @internal
 */var initDirectivesForSSR=NOOP;var runtimeDom=/*#__PURE__*/Object.freeze({__proto__:null,render:render,hydrate:hydrate,createApp:createApp,createSSRApp:createSSRApp,initDirectivesForSSR:initDirectivesForSSR,defineCustomElement:defineCustomElement,defineSSRCustomElement:defineSSRCustomElement,VueElement:VueElement,useCssModule:useCssModule,useCssVars:useCssVars,Transition:Transition,TransitionGroup:TransitionGroup,vModelText:vModelText,vModelCheckbox:vModelCheckbox,vModelRadio:vModelRadio,vModelSelect:vModelSelect,vModelDynamic:vModelDynamic,withModifiers:withModifiers,withKeys:withKeys,vShow:vShow,reactive:reactive,ref:ref,readonly:readonly,unref:unref,proxyRefs:proxyRefs,isRef:isRef,toRef:toRef,toRefs:toRefs,isProxy:isProxy,isReactive:isReactive,isReadonly:isReadonly,isShallow:isShallow,customRef:customRef,triggerRef:triggerRef,shallowRef:shallowRef,shallowReactive:shallowReactive,shallowReadonly:shallowReadonly,markRaw:markRaw,toRaw:toRaw,effect:effect,stop:stop,ReactiveEffect:ReactiveEffect,effectScope:effectScope,EffectScope:EffectScope,getCurrentScope:getCurrentScope,onScopeDispose:onScopeDispose,computed:computed$1,watch:watch,watchEffect:watchEffect,watchPostEffect:watchPostEffect,watchSyncEffect:watchSyncEffect,onBeforeMount:onBeforeMount,onMounted:onMounted,onBeforeUpdate:onBeforeUpdate,onUpdated:onUpdated,onBeforeUnmount:onBeforeUnmount,onUnmounted:onUnmounted,onActivated:onActivated,onDeactivated:onDeactivated,onRenderTracked:onRenderTracked,onRenderTriggered:onRenderTriggered,onErrorCaptured:onErrorCaptured,onServerPrefetch:onServerPrefetch,provide:provide,inject:inject,nextTick:nextTick,defineComponent:defineComponent,defineAsyncComponent:defineAsyncComponent,useAttrs:useAttrs,useSlots:useSlots,defineProps:defineProps,defineEmits:defineEmits,defineExpose:defineExpose,withDefaults:withDefaults,mergeDefaults:mergeDefaults,createPropsRestProxy:createPropsRestProxy,withAsyncContext:withAsyncContext,getCurrentInstance:getCurrentInstance,h:h,createVNode:createVNode,cloneVNode:cloneVNode,mergeProps:mergeProps,isVNode:isVNode,Fragment:Fragment,Text:Text,Comment:Comment,Static:Static,Teleport:Teleport,Suspense:Suspense,KeepAlive:KeepAlive,BaseTransition:BaseTransition,withDirectives:withDirectives,useSSRContext:useSSRContext,ssrContextKey:ssrContextKey,createRenderer:createRenderer,createHydrationRenderer:createHydrationRenderer,queuePostFlushCb:queuePostFlushCb,warn:warn$1,handleError:handleError,callWithErrorHandling:callWithErrorHandling,callWithAsyncErrorHandling:callWithAsyncErrorHandling,resolveComponent:resolveComponent,resolveDirective:resolveDirective,resolveDynamicComponent:resolveDynamicComponent,registerRuntimeCompiler:registerRuntimeCompiler,isRuntimeOnly:isRuntimeOnly,useTransitionState:useTransitionState,resolveTransitionHooks:resolveTransitionHooks,setTransitionHooks:setTransitionHooks,getTransitionRawChildren:getTransitionRawChildren,initCustomFormatter:initCustomFormatter,get devtools(){return devtools;},setDevtoolsHook:setDevtoolsHook,withCtx:withCtx,pushScopeId:pushScopeId,popScopeId:popScopeId,withScopeId:withScopeId,renderList:renderList,toHandlers:toHandlers,renderSlot:renderSlot,createSlots:createSlots,withMemo:withMemo,isMemoSame:isMemoSame,openBlock:openBlock,createBlock:createBlock,setBlockTracking:setBlockTracking,createTextVNode:createTextVNode,createCommentVNode:createCommentVNode,createStaticVNode:createStaticVNode,createElementVNode:createBaseVNode,createElementBlock:createElementBlock,guardReactiveProps:guardReactiveProps,toDisplayString:toDisplayString,camelize:camelize,capitalize:capitalize,toHandlerKey:toHandlerKey,normalizeProps:normalizeProps,normalizeClass:normalizeClass,normalizeStyle:normalizeStyle,transformVNodeArgs:transformVNodeArgs,version:version,ssrUtils:ssrUtils,resolveFilter:resolveFilter,compatUtils:compatUtils});function initDev(){{{console.info("You are running a development build of Vue.\n"+"Make sure to use the production build (*.prod.js) when deploying for production.");}initCustomFormatter();}}function defaultOnError(error){throw error;}function defaultOnWarn(msg){console.warn("[Vue warn] ".concat(msg.message));}function createCompilerError(code,loc,messages,additionalMessage){var msg=(messages||errorMessages)[code]+(additionalMessage||"");var error=new SyntaxError(String(msg));error.code=code;error.loc=loc;return error;}var errorMessages=(_errorMessages={},_defineProperty(_errorMessages,0/* ABRUPT_CLOSING_OF_EMPTY_COMMENT */,'Illegal comment.'),_defineProperty(_errorMessages,1/* CDATA_IN_HTML_CONTENT */,'CDATA section is allowed only in XML context.'),_defineProperty(_errorMessages,2/* DUPLICATE_ATTRIBUTE */,'Duplicate attribute.'),_defineProperty(_errorMessages,3/* END_TAG_WITH_ATTRIBUTES */,'End tag cannot have attributes.'),_defineProperty(_errorMessages,4/* END_TAG_WITH_TRAILING_SOLIDUS */,"Illegal '/' in tags."),_defineProperty(_errorMessages,5/* EOF_BEFORE_TAG_NAME */,'Unexpected EOF in tag.'),_defineProperty(_errorMessages,6/* EOF_IN_CDATA */,'Unexpected EOF in CDATA section.'),_defineProperty(_errorMessages,7/* EOF_IN_COMMENT */,'Unexpected EOF in comment.'),_defineProperty(_errorMessages,8/* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */,'Unexpected EOF in script.'),_defineProperty(_errorMessages,9/* EOF_IN_TAG */,'Unexpected EOF in tag.'),_defineProperty(_errorMessages,10/* INCORRECTLY_CLOSED_COMMENT */,'Incorrectly closed comment.'),_defineProperty(_errorMessages,11/* INCORRECTLY_OPENED_COMMENT */,'Incorrectly opened comment.'),_defineProperty(_errorMessages,12/* INVALID_FIRST_CHARACTER_OF_TAG_NAME */,"Illegal tag name. Use '&lt;' to print '<'."),_defineProperty(_errorMessages,13/* MISSING_ATTRIBUTE_VALUE */,'Attribute value was expected.'),_defineProperty(_errorMessages,14/* MISSING_END_TAG_NAME */,'End tag name was expected.'),_defineProperty(_errorMessages,15/* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */,'Whitespace was expected.'),_defineProperty(_errorMessages,16/* NESTED_COMMENT */,"Unexpected '<!--' in comment."),_defineProperty(_errorMessages,17/* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */,'Attribute name cannot contain U+0022 ("), U+0027 (\'), and U+003C (<).'),_defineProperty(_errorMessages,18/* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */,'Unquoted attribute value cannot contain U+0022 ("), U+0027 (\'), U+003C (<), U+003D (=), and U+0060 (`).'),_defineProperty(_errorMessages,19/* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */,"Attribute name cannot start with '='."),_defineProperty(_errorMessages,21/* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */,"'<?' is allowed only in XML context."),_defineProperty(_errorMessages,20/* UNEXPECTED_NULL_CHARACTER */,"Unexpected null character."),_defineProperty(_errorMessages,22/* UNEXPECTED_SOLIDUS_IN_TAG */,"Illegal '/' in tags."),_defineProperty(_errorMessages,23/* X_INVALID_END_TAG */,'Invalid end tag.'),_defineProperty(_errorMessages,24/* X_MISSING_END_TAG */,'Element is missing end tag.'),_defineProperty(_errorMessages,25/* X_MISSING_INTERPOLATION_END */,'Interpolation end sign was not found.'),_defineProperty(_errorMessages,27/* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */,'End bracket for dynamic directive argument was not found. '+'Note that dynamic directive argument cannot contain spaces.'),_defineProperty(_errorMessages,26/* X_MISSING_DIRECTIVE_NAME */,'Legal directive name was expected.'),_defineProperty(_errorMessages,28/* X_V_IF_NO_EXPRESSION */,"v-if/v-else-if is missing expression."),_defineProperty(_errorMessages,29/* X_V_IF_SAME_KEY */,"v-if/else branches must use unique keys."),_defineProperty(_errorMessages,30/* X_V_ELSE_NO_ADJACENT_IF */,"v-else/v-else-if has no adjacent v-if or v-else-if."),_defineProperty(_errorMessages,31/* X_V_FOR_NO_EXPRESSION */,"v-for is missing expression."),_defineProperty(_errorMessages,32/* X_V_FOR_MALFORMED_EXPRESSION */,"v-for has invalid expression."),_defineProperty(_errorMessages,33/* X_V_FOR_TEMPLATE_KEY_PLACEMENT */,"<template v-for> key should be placed on the <template> tag."),_defineProperty(_errorMessages,34/* X_V_BIND_NO_EXPRESSION */,"v-bind is missing expression."),_defineProperty(_errorMessages,35/* X_V_ON_NO_EXPRESSION */,"v-on is missing expression."),_defineProperty(_errorMessages,36/* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */,"Unexpected custom directive on <slot> outlet."),_defineProperty(_errorMessages,37/* X_V_SLOT_MIXED_SLOT_USAGE */,"Mixed v-slot usage on both the component and nested <template>."+"When there are multiple named slots, all slots should use <template> "+"syntax to avoid scope ambiguity."),_defineProperty(_errorMessages,38/* X_V_SLOT_DUPLICATE_SLOT_NAMES */,"Duplicate slot names found. "),_defineProperty(_errorMessages,39/* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */,"Extraneous children found when component already has explicitly named "+"default slot. These children will be ignored."),_defineProperty(_errorMessages,40/* X_V_SLOT_MISPLACED */,"v-slot can only be used on components or <template> tags."),_defineProperty(_errorMessages,41/* X_V_MODEL_NO_EXPRESSION */,"v-model is missing expression."),_defineProperty(_errorMessages,42/* X_V_MODEL_MALFORMED_EXPRESSION */,"v-model value must be a valid JavaScript member expression."),_defineProperty(_errorMessages,43/* X_V_MODEL_ON_SCOPE_VARIABLE */,"v-model cannot be used on v-for or v-slot scope variables because they are not writable."),_defineProperty(_errorMessages,44/* X_INVALID_EXPRESSION */,"Error parsing JavaScript expression: "),_defineProperty(_errorMessages,45/* X_KEEP_ALIVE_INVALID_CHILDREN */,"<KeepAlive> expects exactly one child component."),_defineProperty(_errorMessages,46/* X_PREFIX_ID_NOT_SUPPORTED */,"\"prefixIdentifiers\" option is not supported in this build of compiler."),_defineProperty(_errorMessages,47/* X_MODULE_MODE_NOT_SUPPORTED */,"ES module mode is not supported in this build of compiler."),_defineProperty(_errorMessages,48/* X_CACHE_HANDLER_NOT_SUPPORTED */,"\"cacheHandlers\" option is only supported when the \"prefixIdentifiers\" option is enabled."),_defineProperty(_errorMessages,49/* X_SCOPE_ID_NOT_SUPPORTED */,"\"scopeId\" option is only supported in module mode."),_defineProperty(_errorMessages,50/* __EXTEND_POINT__ */,""),_errorMessages);var FRAGMENT=Symbol("Fragment");var TELEPORT=Symbol("Teleport");var SUSPENSE=Symbol("Suspense");var KEEP_ALIVE=Symbol("KeepAlive");var BASE_TRANSITION=Symbol("BaseTransition");var OPEN_BLOCK=Symbol("openBlock");var CREATE_BLOCK=Symbol("createBlock");var CREATE_ELEMENT_BLOCK=Symbol("createElementBlock");var CREATE_VNODE=Symbol("createVNode");var CREATE_ELEMENT_VNODE=Symbol("createElementVNode");var CREATE_COMMENT=Symbol("createCommentVNode");var CREATE_TEXT=Symbol("createTextVNode");var CREATE_STATIC=Symbol("createStaticVNode");var RESOLVE_COMPONENT=Symbol("resolveComponent");var RESOLVE_DYNAMIC_COMPONENT=Symbol("resolveDynamicComponent");var RESOLVE_DIRECTIVE=Symbol("resolveDirective");var RESOLVE_FILTER=Symbol("resolveFilter");var WITH_DIRECTIVES=Symbol("withDirectives");var RENDER_LIST=Symbol("renderList");var RENDER_SLOT=Symbol("renderSlot");var CREATE_SLOTS=Symbol("createSlots");var TO_DISPLAY_STRING=Symbol("toDisplayString");var MERGE_PROPS=Symbol("mergeProps");var NORMALIZE_CLASS=Symbol("normalizeClass");var NORMALIZE_STYLE=Symbol("normalizeStyle");var NORMALIZE_PROPS=Symbol("normalizeProps");var GUARD_REACTIVE_PROPS=Symbol("guardReactiveProps");var TO_HANDLERS=Symbol("toHandlers");var CAMELIZE=Symbol("camelize");var CAPITALIZE=Symbol("capitalize");var TO_HANDLER_KEY=Symbol("toHandlerKey");var SET_BLOCK_TRACKING=Symbol("setBlockTracking");var PUSH_SCOPE_ID=Symbol("pushScopeId");var POP_SCOPE_ID=Symbol("popScopeId");var WITH_CTX=Symbol("withCtx");var UNREF=Symbol("unref");var IS_REF=Symbol("isRef");var WITH_MEMO=Symbol("withMemo");var IS_MEMO_SAME=Symbol("isMemoSame");// Name mapping for runtime helpers that need to be imported from 'vue' in
// generated code. Make sure these are correctly exported in the runtime!
// Using `any` here because TS doesn't allow symbols as index type.
var helperNameMap=(_helperNameMap={},_defineProperty(_helperNameMap,FRAGMENT,"Fragment"),_defineProperty(_helperNameMap,TELEPORT,"Teleport"),_defineProperty(_helperNameMap,SUSPENSE,"Suspense"),_defineProperty(_helperNameMap,KEEP_ALIVE,"KeepAlive"),_defineProperty(_helperNameMap,BASE_TRANSITION,"BaseTransition"),_defineProperty(_helperNameMap,OPEN_BLOCK,"openBlock"),_defineProperty(_helperNameMap,CREATE_BLOCK,"createBlock"),_defineProperty(_helperNameMap,CREATE_ELEMENT_BLOCK,"createElementBlock"),_defineProperty(_helperNameMap,CREATE_VNODE,"createVNode"),_defineProperty(_helperNameMap,CREATE_ELEMENT_VNODE,"createElementVNode"),_defineProperty(_helperNameMap,CREATE_COMMENT,"createCommentVNode"),_defineProperty(_helperNameMap,CREATE_TEXT,"createTextVNode"),_defineProperty(_helperNameMap,CREATE_STATIC,"createStaticVNode"),_defineProperty(_helperNameMap,RESOLVE_COMPONENT,"resolveComponent"),_defineProperty(_helperNameMap,RESOLVE_DYNAMIC_COMPONENT,"resolveDynamicComponent"),_defineProperty(_helperNameMap,RESOLVE_DIRECTIVE,"resolveDirective"),_defineProperty(_helperNameMap,RESOLVE_FILTER,"resolveFilter"),_defineProperty(_helperNameMap,WITH_DIRECTIVES,"withDirectives"),_defineProperty(_helperNameMap,RENDER_LIST,"renderList"),_defineProperty(_helperNameMap,RENDER_SLOT,"renderSlot"),_defineProperty(_helperNameMap,CREATE_SLOTS,"createSlots"),_defineProperty(_helperNameMap,TO_DISPLAY_STRING,"toDisplayString"),_defineProperty(_helperNameMap,MERGE_PROPS,"mergeProps"),_defineProperty(_helperNameMap,NORMALIZE_CLASS,"normalizeClass"),_defineProperty(_helperNameMap,NORMALIZE_STYLE,"normalizeStyle"),_defineProperty(_helperNameMap,NORMALIZE_PROPS,"normalizeProps"),_defineProperty(_helperNameMap,GUARD_REACTIVE_PROPS,"guardReactiveProps"),_defineProperty(_helperNameMap,TO_HANDLERS,"toHandlers"),_defineProperty(_helperNameMap,CAMELIZE,"camelize"),_defineProperty(_helperNameMap,CAPITALIZE,"capitalize"),_defineProperty(_helperNameMap,TO_HANDLER_KEY,"toHandlerKey"),_defineProperty(_helperNameMap,SET_BLOCK_TRACKING,"setBlockTracking"),_defineProperty(_helperNameMap,PUSH_SCOPE_ID,"pushScopeId"),_defineProperty(_helperNameMap,POP_SCOPE_ID,"popScopeId"),_defineProperty(_helperNameMap,WITH_CTX,"withCtx"),_defineProperty(_helperNameMap,UNREF,"unref"),_defineProperty(_helperNameMap,IS_REF,"isRef"),_defineProperty(_helperNameMap,WITH_MEMO,"withMemo"),_defineProperty(_helperNameMap,IS_MEMO_SAME,"isMemoSame"),_helperNameMap);function registerRuntimeHelpers(helpers){Object.getOwnPropertySymbols(helpers).forEach(function(s){helperNameMap[s]=helpers[s];});}// AST Utilities ---------------------------------------------------------------
// Some expressions, e.g. sequence and conditional expressions, are never
// associated with template nodes, so their source locations are just a stub.
// Container types like CompoundExpression also don't need a real location.
var locStub={source:'',start:{line:1,column:1,offset:0},end:{line:1,column:1,offset:0}};function createRoot(children){var loc=arguments.length>1&&arguments[1]!==undefined?arguments[1]:locStub;return{type:0/* ROOT */,children:children,helpers:[],components:[],directives:[],hoists:[],imports:[],cached:0,temps:0,codegenNode:undefined,loc:loc};}function createVNodeCall(context,tag,props,children,patchFlag,dynamicProps,directives){var isBlock=arguments.length>7&&arguments[7]!==undefined?arguments[7]:false;var disableTracking=arguments.length>8&&arguments[8]!==undefined?arguments[8]:false;var isComponent=arguments.length>9&&arguments[9]!==undefined?arguments[9]:false;var loc=arguments.length>10&&arguments[10]!==undefined?arguments[10]:locStub;if(context){if(isBlock){context.helper(OPEN_BLOCK);context.helper(getVNodeBlockHelper(context.inSSR,isComponent));}else{context.helper(getVNodeHelper(context.inSSR,isComponent));}if(directives){context.helper(WITH_DIRECTIVES);}}return{type:13/* VNODE_CALL */,tag:tag,props:props,children:children,patchFlag:patchFlag,dynamicProps:dynamicProps,directives:directives,isBlock:isBlock,disableTracking:disableTracking,isComponent:isComponent,loc:loc};}function createArrayExpression(elements){var loc=arguments.length>1&&arguments[1]!==undefined?arguments[1]:locStub;return{type:17/* JS_ARRAY_EXPRESSION */,loc:loc,elements:elements};}function createObjectExpression(properties){var loc=arguments.length>1&&arguments[1]!==undefined?arguments[1]:locStub;return{type:15/* JS_OBJECT_EXPRESSION */,loc:loc,properties:properties};}function createObjectProperty(key,value){return{type:16/* JS_PROPERTY */,loc:locStub,key:isString(key)?createSimpleExpression(key,true):key,value:value};}function createSimpleExpression(content)/* NOT_CONSTANT */{var isStatic=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var loc=arguments.length>2&&arguments[2]!==undefined?arguments[2]:locStub;var constType=arguments.length>3&&arguments[3]!==undefined?arguments[3]:0;return{type:4/* SIMPLE_EXPRESSION */,loc:loc,content:content,isStatic:isStatic,constType:isStatic?3/* CAN_STRINGIFY */:constType};}function createCompoundExpression(children){var loc=arguments.length>1&&arguments[1]!==undefined?arguments[1]:locStub;return{type:8/* COMPOUND_EXPRESSION */,loc:loc,children:children};}function createCallExpression(callee){var args=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var loc=arguments.length>2&&arguments[2]!==undefined?arguments[2]:locStub;return{type:14/* JS_CALL_EXPRESSION */,loc:loc,callee:callee,arguments:args};}function createFunctionExpression(params){var returns=arguments.length>1&&arguments[1]!==undefined?arguments[1]:undefined;var newline=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var isSlot=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var loc=arguments.length>4&&arguments[4]!==undefined?arguments[4]:locStub;return{type:18/* JS_FUNCTION_EXPRESSION */,params:params,returns:returns,newline:newline,isSlot:isSlot,loc:loc};}function createConditionalExpression(test,consequent,alternate){var newline=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;return{type:19/* JS_CONDITIONAL_EXPRESSION */,test:test,consequent:consequent,alternate:alternate,newline:newline,loc:locStub};}function createCacheExpression(index,value){var isVNode=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;return{type:20/* JS_CACHE_EXPRESSION */,index:index,value:value,isVNode:isVNode,loc:locStub};}function createBlockStatement(body){return{type:21/* JS_BLOCK_STATEMENT */,body:body,loc:locStub};}var isStaticExp=function isStaticExp(p){return p.type===4/* SIMPLE_EXPRESSION */&&p.isStatic;};var isBuiltInType=function isBuiltInType(tag,expected){return tag===expected||tag===hyphenate(expected);};function isCoreComponent(tag){if(isBuiltInType(tag,'Teleport')){return TELEPORT;}else if(isBuiltInType(tag,'Suspense')){return SUSPENSE;}else if(isBuiltInType(tag,'KeepAlive')){return KEEP_ALIVE;}else if(isBuiltInType(tag,'BaseTransition')){return BASE_TRANSITION;}}var nonIdentifierRE=/^\d|[^\$\w]/;var isSimpleIdentifier=function isSimpleIdentifier(name){return!nonIdentifierRE.test(name);};var validFirstIdentCharRE=/[A-Za-z_$\xA0-\uFFFF]/;var validIdentCharRE=/[\.\?\w$\xA0-\uFFFF]/;var whitespaceRE=/\s+[.[]\s*|\s*[.[]\s+/g;/**
 * Simple lexer to check if an expression is a member expression. This is
 * lax and only checks validity at the root level (i.e. does not validate exps
 * inside square brackets), but it's ok since these are only used on template
 * expressions and false positives are invalid expressions in the first place.
 */var isMemberExpressionBrowser=function isMemberExpressionBrowser(path){// remove whitespaces around . or [ first
path=path.trim().replace(whitespaceRE,function(s){return s.trim();});var state=0/* inMemberExp */;var stateStack=[];var currentOpenBracketCount=0;var currentOpenParensCount=0;var currentStringType=null;for(var i=0;i<path.length;i++){var char=path.charAt(i);switch(state){case 0/* inMemberExp */:if(char==='['){stateStack.push(state);state=1/* inBrackets */;currentOpenBracketCount++;}else if(char==='('){stateStack.push(state);state=2/* inParens */;currentOpenParensCount++;}else if(!(i===0?validFirstIdentCharRE:validIdentCharRE).test(char)){return false;}break;case 1/* inBrackets */:if(char==="'"||char==="\""||char==='`'){stateStack.push(state);state=3/* inString */;currentStringType=char;}else if(char==="["){currentOpenBracketCount++;}else if(char==="]"){if(! --currentOpenBracketCount){state=stateStack.pop();}}break;case 2/* inParens */:if(char==="'"||char==="\""||char==='`'){stateStack.push(state);state=3/* inString */;currentStringType=char;}else if(char==="("){currentOpenParensCount++;}else if(char===")"){// if the exp ends as a call then it should not be considered valid
if(i===path.length-1){return false;}if(! --currentOpenParensCount){state=stateStack.pop();}}break;case 3/* inString */:if(char===currentStringType){state=stateStack.pop();currentStringType=null;}break;}}return!currentOpenBracketCount&&!currentOpenParensCount;};var isMemberExpression=isMemberExpressionBrowser;function getInnerRange(loc,offset,length){var source=loc.source.slice(offset,offset+length);var newLoc={source:source,start:advancePositionWithClone(loc.start,loc.source,offset),end:loc.end};if(length!=null){newLoc.end=advancePositionWithClone(loc.start,loc.source,offset+length);}return newLoc;}function advancePositionWithClone(pos,source){var numberOfCharacters=arguments.length>2&&arguments[2]!==undefined?arguments[2]:source.length;return advancePositionWithMutation(extend({},pos),source,numberOfCharacters);}// advance by mutation without cloning (for performance reasons), since this
// gets called a lot in the parser
function advancePositionWithMutation(pos,source){var numberOfCharacters=arguments.length>2&&arguments[2]!==undefined?arguments[2]:source.length;var linesCount=0;var lastNewLinePos=-1;for(var i=0;i<numberOfCharacters;i++){if(source.charCodeAt(i)===10/* newline char code */){linesCount++;lastNewLinePos=i;}}pos.offset+=numberOfCharacters;pos.line+=linesCount;pos.column=lastNewLinePos===-1?pos.column+numberOfCharacters:numberOfCharacters-lastNewLinePos;return pos;}function assert(condition,msg){/* istanbul ignore if */if(!condition){throw new Error(msg||"unexpected compiler condition");}}function findDir(node,name){var allowEmpty=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;for(var i=0;i<node.props.length;i++){var _p=node.props[i];if(_p.type===7/* DIRECTIVE */&&(allowEmpty||_p.exp)&&(isString(name)?_p.name===name:name.test(_p.name))){return _p;}}}function findProp(node,name){var dynamicOnly=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var allowEmpty=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;for(var i=0;i<node.props.length;i++){var _p2=node.props[i];if(_p2.type===6/* ATTRIBUTE */){if(dynamicOnly)continue;if(_p2.name===name&&(_p2.value||allowEmpty)){return _p2;}}else if(_p2.name==='bind'&&(_p2.exp||allowEmpty)&&isStaticArgOf(_p2.arg,name)){return _p2;}}}function isStaticArgOf(arg,name){return!!(arg&&isStaticExp(arg)&&arg.content===name);}function hasDynamicKeyVBind(node){return node.props.some(function(p){return p.type===7/* DIRECTIVE */&&p.name==='bind'&&(!p.arg||// v-bind="obj"
p.arg.type!==4/* SIMPLE_EXPRESSION */||// v-bind:[_ctx.foo]
!p.arg.isStatic);}// v-bind:[foo]
);}function isText(node){return node.type===5/* INTERPOLATION */||node.type===2/* TEXT */;}function isVSlot(p){return p.type===7/* DIRECTIVE */&&p.name==='slot';}function isTemplateNode(node){return node.type===1/* ELEMENT */&&node.tagType===3/* TEMPLATE */;}function isSlotOutlet(node){return node.type===1/* ELEMENT */&&node.tagType===2/* SLOT */;}function getVNodeHelper(ssr,isComponent){return ssr||isComponent?CREATE_VNODE:CREATE_ELEMENT_VNODE;}function getVNodeBlockHelper(ssr,isComponent){return ssr||isComponent?CREATE_BLOCK:CREATE_ELEMENT_BLOCK;}var propsHelperSet=new Set([NORMALIZE_PROPS,GUARD_REACTIVE_PROPS]);function getUnnormalizedProps(props){var callPath=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];if(props&&!isString(props)&&props.type===14/* JS_CALL_EXPRESSION */){var callee=props.callee;if(!isString(callee)&&propsHelperSet.has(callee)){return getUnnormalizedProps(props.arguments[0],callPath.concat(props));}}return[props,callPath];}function injectProp(node,prop,context){var propsWithInjection;/**
     * 1. mergeProps(...)
     * 2. toHandlers(...)
     * 3. normalizeProps(...)
     * 4. normalizeProps(guardReactiveProps(...))
     *
     * we need to get the real props before normalization
     */var props=node.type===13/* VNODE_CALL */?node.props:node.arguments[2];var callPath=[];var parentCall;if(props&&!isString(props)&&props.type===14/* JS_CALL_EXPRESSION */){var ret=getUnnormalizedProps(props);props=ret[0];callPath=ret[1];parentCall=callPath[callPath.length-1];}if(props==null||isString(props)){propsWithInjection=createObjectExpression([prop]);}else if(props.type===14/* JS_CALL_EXPRESSION */){// merged props... add ours
// only inject key to object literal if it's the first argument so that
// if doesn't override user provided keys
var first=props.arguments[0];if(!isString(first)&&first.type===15/* JS_OBJECT_EXPRESSION */){first.properties.unshift(prop);}else{if(props.callee===TO_HANDLERS){// #2366
propsWithInjection=createCallExpression(context.helper(MERGE_PROPS),[createObjectExpression([prop]),props]);}else{props.arguments.unshift(createObjectExpression([prop]));}}!propsWithInjection&&(propsWithInjection=props);}else if(props.type===15/* JS_OBJECT_EXPRESSION */){var alreadyExists=false;// check existing key to avoid overriding user provided keys
if(prop.key.type===4/* SIMPLE_EXPRESSION */){var propKeyName=prop.key.content;alreadyExists=props.properties.some(function(p){return p.key.type===4/* SIMPLE_EXPRESSION */&&p.key.content===propKeyName;});}if(!alreadyExists){props.properties.unshift(prop);}propsWithInjection=props;}else{// single v-bind with expression, return a merged replacement
propsWithInjection=createCallExpression(context.helper(MERGE_PROPS),[createObjectExpression([prop]),props]);// in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(props))`,
// it will be rewritten as `normalizeProps(mergeProps({ key: 0 }, props))`,
// the `guardReactiveProps` will no longer be needed
if(parentCall&&parentCall.callee===GUARD_REACTIVE_PROPS){parentCall=callPath[callPath.length-2];}}if(node.type===13/* VNODE_CALL */){if(parentCall){parentCall.arguments[0]=propsWithInjection;}else{node.props=propsWithInjection;}}else{if(parentCall){parentCall.arguments[0]=propsWithInjection;}else{node.arguments[2]=propsWithInjection;}}}function toValidAssetId(name,type){// see issue#4422, we need adding identifier on validAssetId if variable `name` has specific character
return"_".concat(type,"_").concat(name.replace(/[^\w]/g,function(searchValue,replaceValue){return searchValue==='-'?'_':name.charCodeAt(replaceValue).toString();}));}function getMemoedVNodeCall(node){if(node.type===14/* JS_CALL_EXPRESSION */&&node.callee===WITH_MEMO){return node.arguments[1].returns;}else{return node;}}function makeBlock(node,_ref48){var helper=_ref48.helper,removeHelper=_ref48.removeHelper,inSSR=_ref48.inSSR;if(!node.isBlock){node.isBlock=true;removeHelper(getVNodeHelper(inSSR,node.isComponent));helper(OPEN_BLOCK);helper(getVNodeBlockHelper(inSSR,node.isComponent));}}var deprecationData=(_deprecationData={},_defineProperty(_deprecationData,"COMPILER_IS_ON_ELEMENT"/* COMPILER_IS_ON_ELEMENT */,{message:"Platform-native elements with \"is\" prop will no longer be "+"treated as components in Vue 3 unless the \"is\" value is explicitly "+"prefixed with \"vue:\".",link:"https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"}),_defineProperty(_deprecationData,"COMPILER_V_BIND_SYNC"/* COMPILER_V_BIND_SYNC */,{message:function message(key){return".sync modifier for v-bind has been removed. Use v-model with "+"argument instead. `v-bind:".concat(key,".sync` should be changed to ")+"`v-model:".concat(key,"`.");},link:"https://v3-migration.vuejs.org/breaking-changes/v-model.html"}),_defineProperty(_deprecationData,"COMPILER_V_BIND_PROP"/* COMPILER_V_BIND_PROP */,{message:".prop modifier for v-bind has been removed and no longer necessary. "+"Vue 3 will automatically set a binding as DOM property when appropriate."}),_defineProperty(_deprecationData,"COMPILER_V_BIND_OBJECT_ORDER"/* COMPILER_V_BIND_OBJECT_ORDER */,{message:"v-bind=\"obj\" usage is now order sensitive and behaves like JavaScript "+"object spread: it will now overwrite an existing non-mergeable attribute "+"that appears before v-bind in the case of conflict. "+"To retain 2.x behavior, move v-bind to make it the first attribute. "+"You can also suppress this warning if the usage is intended.",link:"https://v3-migration.vuejs.org/breaking-changes/v-bind.html"}),_defineProperty(_deprecationData,"COMPILER_V_ON_NATIVE"/* COMPILER_V_ON_NATIVE */,{message:".native modifier for v-on has been removed as is no longer necessary.",link:"https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"}),_defineProperty(_deprecationData,"COMPILER_V_IF_V_FOR_PRECEDENCE"/* COMPILER_V_IF_V_FOR_PRECEDENCE */,{message:"v-if / v-for precedence when used on the same element has changed "+"in Vue 3: v-if now takes higher precedence and will no longer have "+"access to v-for scope variables. It is best to avoid the ambiguity "+"with <template> tags or use a computed property that filters v-for "+"data source.",link:"https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"}),_defineProperty(_deprecationData,"COMPILER_NATIVE_TEMPLATE"/* COMPILER_NATIVE_TEMPLATE */,{message:"<template> with no special directives will render as a native template "+"element instead of its inner content in Vue 3."}),_defineProperty(_deprecationData,"COMPILER_INLINE_TEMPLATE"/* COMPILER_INLINE_TEMPLATE */,{message:"\"inline-template\" has been removed in Vue 3.",link:"https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"}),_defineProperty(_deprecationData,"COMPILER_FILTER"/* COMPILER_FILTERS */,{message:"filters have been removed in Vue 3. "+"The \"|\" symbol will be treated as native JavaScript bitwise OR operator. "+"Use method calls or computed properties instead.",link:"https://v3-migration.vuejs.org/breaking-changes/filters.html"}),_deprecationData);function getCompatValue(key,context){var config=context.options?context.options.compatConfig:context.compatConfig;var value=config&&config[key];if(key==='MODE'){return value||3;// compiler defaults to v3 behavior
}else{return value;}}function isCompatEnabled(key,context){var mode=getCompatValue('MODE',context);var value=getCompatValue(key,context);// in v3 mode, only enable if explicitly set to true
// otherwise enable for any non-false value
return mode===3?value===true:value!==false;}function checkCompatEnabled(key,context,loc){var enabled=isCompatEnabled(key,context);if(enabled){for(var _len14=arguments.length,args=new Array(_len14>3?_len14-3:0),_key25=3;_key25<_len14;_key25++){args[_key25-3]=arguments[_key25];}warnDeprecation.apply(void 0,[key,context,loc].concat(args));}return enabled;}function warnDeprecation(key,context,loc){var val=getCompatValue(key,context);if(val==='suppress-warning'){return;}var _deprecationData$key=deprecationData[key],message=_deprecationData$key.message,link=_deprecationData$key.link;for(var _len15=arguments.length,args=new Array(_len15>3?_len15-3:0),_key26=3;_key26<_len15;_key26++){args[_key26-3]=arguments[_key26];}var msg="(deprecation ".concat(key,") ").concat(typeof message==='function'?message.apply(void 0,args):message).concat(link?"\n  Details: ".concat(link):"");var err=new SyntaxError(msg);err.code=key;if(loc)err.loc=loc;context.onWarn(err);}// The default decoder only provides escapes for characters reserved as part of
// the template syntax, and is only used if the custom renderer did not provide
// a platform-specific decoder.
var decodeRE=/&(gt|lt|amp|apos|quot);/g;var decodeMap={gt:'>',lt:'<',amp:'&',apos:"'",quot:'"'};var defaultParserOptions={delimiters:["{{","}}"],getNamespace:function getNamespace(){return 0;}/* HTML */,getTextMode:function getTextMode(){return 0;}/* DATA */,isVoidTag:NO,isPreTag:NO,isCustomElement:NO,decodeEntities:function decodeEntities(rawText){return rawText.replace(decodeRE,function(_,p1){return decodeMap[p1];});},onError:defaultOnError,onWarn:defaultOnWarn,comments:true};function baseParse(content){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var context=createParserContext(content,options);var start=getCursor(context);return createRoot(parseChildren(context,0/* DATA */,[]),getSelection(context,start));}function createParserContext(content,rawOptions){var options=extend({},defaultParserOptions);var key;for(key in rawOptions){// @ts-ignore
options[key]=rawOptions[key]===undefined?defaultParserOptions[key]:rawOptions[key];}return{options:options,column:1,line:1,offset:0,originalSource:content,source:content,inPre:false,inVPre:false,onWarn:options.onWarn};}function parseChildren(context,mode,ancestors){var parent=last(ancestors);var ns=parent?parent.ns:0/* HTML */;var nodes=[];while(!isEnd(context,mode,ancestors)){var s=context.source;var node=undefined;if(mode===0/* DATA */||mode===1/* RCDATA */){if(!context.inVPre&&startsWith(s,context.options.delimiters[0])){// '{{'
node=parseInterpolation(context,mode);}else if(mode===0/* DATA */&&s[0]==='<'){// https://html.spec.whatwg.org/multipage/parsing.html#tag-open-state
if(s.length===1){emitError(context,5/* EOF_BEFORE_TAG_NAME */,1);}else if(s[1]==='!'){// https://html.spec.whatwg.org/multipage/parsing.html#markup-declaration-open-state
if(startsWith(s,'<!--')){node=parseComment(context);}else if(startsWith(s,'<!DOCTYPE')){// Ignore DOCTYPE by a limitation.
node=parseBogusComment(context);}else if(startsWith(s,'<![CDATA[')){if(ns!==0/* HTML */){node=parseCDATA(context,ancestors);}else{emitError(context,1/* CDATA_IN_HTML_CONTENT */);node=parseBogusComment(context);}}else{emitError(context,11/* INCORRECTLY_OPENED_COMMENT */);node=parseBogusComment(context);}}else if(s[1]==='/'){// https://html.spec.whatwg.org/multipage/parsing.html#end-tag-open-state
if(s.length===2){emitError(context,5/* EOF_BEFORE_TAG_NAME */,2);}else if(s[2]==='>'){emitError(context,14/* MISSING_END_TAG_NAME */,2);advanceBy(context,3);continue;}else if(/[a-z]/i.test(s[2])){emitError(context,23/* X_INVALID_END_TAG */);parseTag(context,1/* End */,parent);continue;}else{emitError(context,12/* INVALID_FIRST_CHARACTER_OF_TAG_NAME */,2);node=parseBogusComment(context);}}else if(/[a-z]/i.test(s[1])){node=parseElement(context,ancestors);}else if(s[1]==='?'){emitError(context,21/* UNEXPECTED_QUESTION_MARK_INSTEAD_OF_TAG_NAME */,1);node=parseBogusComment(context);}else{emitError(context,12/* INVALID_FIRST_CHARACTER_OF_TAG_NAME */,1);}}}if(!node){node=parseText(context,mode);}if(isArray(node)){for(var i=0;i<node.length;i++){pushNode(nodes,node[i]);}}else{pushNode(nodes,node);}}// Whitespace handling strategy like v2
var removedWhitespace=false;if(mode!==2/* RAWTEXT */&&mode!==1/* RCDATA */){var shouldCondense=context.options.whitespace!=='preserve';for(var _i8=0;_i8<nodes.length;_i8++){var _node2=nodes[_i8];if(!context.inPre&&_node2.type===2/* TEXT */){if(!/[^\t\r\n\f ]/.test(_node2.content)){var prev=nodes[_i8-1];var next=nodes[_i8+1];// Remove if:
// - the whitespace is the first or last node, or:
// - (condense mode) the whitespace is adjacent to a comment, or:
// - (condense mode) the whitespace is between two elements AND contains newline
if(!prev||!next||shouldCondense&&(prev.type===3/* COMMENT */||next.type===3/* COMMENT */||prev.type===1/* ELEMENT */&&next.type===1/* ELEMENT */&&/[\r\n]/.test(_node2.content))){removedWhitespace=true;nodes[_i8]=null;}else{// Otherwise, the whitespace is condensed into a single space
_node2.content=' ';}}else if(shouldCondense){// in condense mode, consecutive whitespaces in text are condensed
// down to a single space.
_node2.content=_node2.content.replace(/[\t\r\n\f ]+/g,' ');}}// Remove comment nodes if desired by configuration.
else if(_node2.type===3/* COMMENT */&&!context.options.comments){removedWhitespace=true;nodes[_i8]=null;}}if(context.inPre&&parent&&context.options.isPreTag(parent.tag)){// remove leading newline per html spec
// https://html.spec.whatwg.org/multipage/grouping-content.html#the-pre-element
var first=nodes[0];if(first&&first.type===2/* TEXT */){first.content=first.content.replace(/^\r?\n/,'');}}}return removedWhitespace?nodes.filter(Boolean):nodes;}function pushNode(nodes,node){if(node.type===2/* TEXT */){var prev=last(nodes);// Merge if both this and the previous node are text and those are
// consecutive. This happens for cases like "a < b".
if(prev&&prev.type===2/* TEXT */&&prev.loc.end.offset===node.loc.start.offset){prev.content+=node.content;prev.loc.end=node.loc.end;prev.loc.source+=node.loc.source;return;}}nodes.push(node);}function parseCDATA(context,ancestors){advanceBy(context,9);var nodes=parseChildren(context,3/* CDATA */,ancestors);if(context.source.length===0){emitError(context,6/* EOF_IN_CDATA */);}else{advanceBy(context,3);}return nodes;}function parseComment(context){var start=getCursor(context);var content;// Regular comment.
var match=/--(\!)?>/.exec(context.source);if(!match){content=context.source.slice(4);advanceBy(context,context.source.length);emitError(context,7/* EOF_IN_COMMENT */);}else{if(match.index<=3){emitError(context,0/* ABRUPT_CLOSING_OF_EMPTY_COMMENT */);}if(match[1]){emitError(context,10/* INCORRECTLY_CLOSED_COMMENT */);}content=context.source.slice(4,match.index);// Advancing with reporting nested comments.
var s=context.source.slice(0,match.index);var prevIndex=1,nestedIndex=0;while((nestedIndex=s.indexOf('<!--',prevIndex))!==-1){advanceBy(context,nestedIndex-prevIndex+1);if(nestedIndex+4<s.length){emitError(context,16/* NESTED_COMMENT */);}prevIndex=nestedIndex+1;}advanceBy(context,match.index+match[0].length-prevIndex+1);}return{type:3/* COMMENT */,content:content,loc:getSelection(context,start)};}function parseBogusComment(context){var start=getCursor(context);var contentStart=context.source[1]==='?'?1:2;var content;var closeIndex=context.source.indexOf('>');if(closeIndex===-1){content=context.source.slice(contentStart);advanceBy(context,context.source.length);}else{content=context.source.slice(contentStart,closeIndex);advanceBy(context,closeIndex+1);}return{type:3/* COMMENT */,content:content,loc:getSelection(context,start)};}function parseElement(context,ancestors){// Start tag.
var wasInPre=context.inPre;var wasInVPre=context.inVPre;var parent=last(ancestors);var element=parseTag(context,0/* Start */,parent);var isPreBoundary=context.inPre&&!wasInPre;var isVPreBoundary=context.inVPre&&!wasInVPre;if(element.isSelfClosing||context.options.isVoidTag(element.tag)){// #4030 self-closing <pre> tag
if(isPreBoundary){context.inPre=false;}if(isVPreBoundary){context.inVPre=false;}return element;}// Children.
ancestors.push(element);var mode=context.options.getTextMode(element,parent);var children=parseChildren(context,mode,ancestors);ancestors.pop();element.children=children;// End tag.
if(startsWithEndTagOpen(context.source,element.tag)){parseTag(context,1/* End */,parent);}else{emitError(context,24/* X_MISSING_END_TAG */,0,element.loc.start);if(context.source.length===0&&element.tag.toLowerCase()==='script'){var first=children[0];if(first&&startsWith(first.loc.source,'<!--')){emitError(context,8/* EOF_IN_SCRIPT_HTML_COMMENT_LIKE_TEXT */);}}}element.loc=getSelection(context,element.loc.start);if(isPreBoundary){context.inPre=false;}if(isVPreBoundary){context.inVPre=false;}return element;}var isSpecialTemplateDirective=/*#__PURE__*/makeMap("if,else,else-if,for,slot");function parseTag(context,type,parent){// Tag open.
var start=getCursor(context);var match=/^<\/?([a-z][^\t\r\n\f />]*)/i.exec(context.source);var tag=match[1];var ns=context.options.getNamespace(tag,parent);advanceBy(context,match[0].length);advanceSpaces(context);// save current state in case we need to re-parse attributes with v-pre
var cursor=getCursor(context);var currentSource=context.source;// check <pre> tag
if(context.options.isPreTag(tag)){context.inPre=true;}// Attributes.
var props=parseAttributes(context,type);// check v-pre
if(type===0/* Start */&&!context.inVPre&&props.some(function(p){return p.type===7/* DIRECTIVE */&&p.name==='pre';})){context.inVPre=true;// reset context
extend(context,cursor);context.source=currentSource;// re-parse attrs and filter out v-pre itself
props=parseAttributes(context,type).filter(function(p){return p.name!=='v-pre';});}// Tag close.
var isSelfClosing=false;if(context.source.length===0){emitError(context,9/* EOF_IN_TAG */);}else{isSelfClosing=startsWith(context.source,'/>');if(type===1/* End */&&isSelfClosing){emitError(context,4/* END_TAG_WITH_TRAILING_SOLIDUS */);}advanceBy(context,isSelfClosing?2:1);}if(type===1/* End */){return;}var tagType=0/* ELEMENT */;if(!context.inVPre){if(tag==='slot'){tagType=2/* SLOT */;}else if(tag==='template'){if(props.some(function(p){return p.type===7/* DIRECTIVE */&&isSpecialTemplateDirective(p.name);})){tagType=3/* TEMPLATE */;}}else if(isComponent(tag,props,context)){tagType=1/* COMPONENT */;}}return{type:1/* ELEMENT */,ns:ns,tag:tag,tagType:tagType,props:props,isSelfClosing:isSelfClosing,children:[],loc:getSelection(context,start),codegenNode:undefined// to be created during transform phase
};}function isComponent(tag,props,context){var options=context.options;if(options.isCustomElement(tag)){return false;}if(tag==='component'||/^[A-Z]/.test(tag)||isCoreComponent(tag)||options.isBuiltInComponent&&options.isBuiltInComponent(tag)||options.isNativeTag&&!options.isNativeTag(tag)){return true;}// at this point the tag should be a native tag, but check for potential "is"
// casting
for(var i=0;i<props.length;i++){var _p3=props[i];if(_p3.type===6/* ATTRIBUTE */){if(_p3.name==='is'&&_p3.value){if(_p3.value.content.startsWith('vue:')){return true;}}}else{// directive
// v-is (TODO Deprecate)
if(_p3.name==='is'){return true;}else if(// :is on plain element - only treat as component in compat mode
_p3.name==='bind'&&isStaticArgOf(_p3.arg,'is')&&false&&checkCompatEnabled("COMPILER_IS_ON_ELEMENT"/* COMPILER_IS_ON_ELEMENT */,context,_p3.loc)){return true;}}}}function parseAttributes(context,type){var props=[];var attributeNames=new Set();while(context.source.length>0&&!startsWith(context.source,'>')&&!startsWith(context.source,'/>')){if(startsWith(context.source,'/')){emitError(context,22/* UNEXPECTED_SOLIDUS_IN_TAG */);advanceBy(context,1);advanceSpaces(context);continue;}if(type===1/* End */){emitError(context,3/* END_TAG_WITH_ATTRIBUTES */);}var attr=parseAttribute(context,attributeNames);// Trim whitespace between class
// https://github.com/vuejs/core/issues/4251
if(attr.type===6/* ATTRIBUTE */&&attr.value&&attr.name==='class'){attr.value.content=attr.value.content.replace(/\s+/g,' ').trim();}if(type===0/* Start */){props.push(attr);}if(/^[^\t\r\n\f />]/.test(context.source)){emitError(context,15/* MISSING_WHITESPACE_BETWEEN_ATTRIBUTES */);}advanceSpaces(context);}return props;}function parseAttribute(context,nameSet){// Name.
var start=getCursor(context);var match=/^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(context.source);var name=match[0];if(nameSet.has(name)){emitError(context,2/* DUPLICATE_ATTRIBUTE */);}nameSet.add(name);if(name[0]==='='){emitError(context,19/* UNEXPECTED_EQUALS_SIGN_BEFORE_ATTRIBUTE_NAME */);}{var pattern=/["'<]/g;var m;while(m=pattern.exec(name)){emitError(context,17/* UNEXPECTED_CHARACTER_IN_ATTRIBUTE_NAME */,m.index);}}advanceBy(context,name.length);// Value
var value=undefined;if(/^[\t\r\n\f ]*=/.test(context.source)){advanceSpaces(context);advanceBy(context,1);advanceSpaces(context);value=parseAttributeValue(context);if(!value){emitError(context,13/* MISSING_ATTRIBUTE_VALUE */);}}var loc=getSelection(context,start);if(!context.inVPre&&/^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(name)){var _match=/(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(name);var isPropShorthand=startsWith(name,'.');var dirName=_match[1]||(isPropShorthand||startsWith(name,':')?'bind':startsWith(name,'@')?'on':'slot');var arg;if(_match[2]){var isSlot=dirName==='slot';var startOffset=name.lastIndexOf(_match[2]);var _loc=getSelection(context,getNewPosition(context,start,startOffset),getNewPosition(context,start,startOffset+_match[2].length+(isSlot&&_match[3]||'').length));var content=_match[2];var isStatic=true;if(content.startsWith('[')){isStatic=false;if(!content.endsWith(']')){emitError(context,27/* X_MISSING_DYNAMIC_DIRECTIVE_ARGUMENT_END */);content=content.slice(1);}else{content=content.slice(1,content.length-1);}}else if(isSlot){// #1241 special case for v-slot: vuetify relies extensively on slot
// names containing dots. v-slot doesn't have any modifiers and Vue 2.x
// supports such usage so we are keeping it consistent with 2.x.
content+=_match[3]||'';}arg={type:4/* SIMPLE_EXPRESSION */,content:content,isStatic:isStatic,constType:isStatic?3/* CAN_STRINGIFY */:0/* NOT_CONSTANT */,loc:_loc};}if(value&&value.isQuoted){var valueLoc=value.loc;valueLoc.start.offset++;valueLoc.start.column++;valueLoc.end=advancePositionWithClone(valueLoc.start,value.content);valueLoc.source=valueLoc.source.slice(1,-1);}var modifiers=_match[3]?_match[3].slice(1).split('.'):[];if(isPropShorthand)modifiers.push('prop');return{type:7/* DIRECTIVE */,name:dirName,exp:value&&{type:4/* SIMPLE_EXPRESSION */,content:value.content,isStatic:false,// Treat as non-constant by default. This can be potentially set to
// other values by `transformExpression` to make it eligible for hoisting.
constType:0/* NOT_CONSTANT */,loc:value.loc},arg:arg,modifiers:modifiers,loc:loc};}// missing directive name or illegal directive name
if(!context.inVPre&&startsWith(name,'v-')){emitError(context,26/* X_MISSING_DIRECTIVE_NAME */);}return{type:6/* ATTRIBUTE */,name:name,value:value&&{type:2/* TEXT */,content:value.content,loc:value.loc},loc:loc};}function parseAttributeValue(context){var start=getCursor(context);var content;var quote=context.source[0];var isQuoted=quote==="\""||quote==="'";if(isQuoted){// Quoted value.
advanceBy(context,1);var endIndex=context.source.indexOf(quote);if(endIndex===-1){content=parseTextData(context,context.source.length,4/* ATTRIBUTE_VALUE */);}else{content=parseTextData(context,endIndex,4/* ATTRIBUTE_VALUE */);advanceBy(context,1);}}else{// Unquoted
var match=/^[^\t\r\n\f >]+/.exec(context.source);if(!match){return undefined;}var unexpectedChars=/["'<=`]/g;var m;while(m=unexpectedChars.exec(match[0])){emitError(context,18/* UNEXPECTED_CHARACTER_IN_UNQUOTED_ATTRIBUTE_VALUE */,m.index);}content=parseTextData(context,match[0].length,4/* ATTRIBUTE_VALUE */);}return{content:content,isQuoted:isQuoted,loc:getSelection(context,start)};}function parseInterpolation(context,mode){var _context$options$deli=_slicedToArray(context.options.delimiters,2),open=_context$options$deli[0],close=_context$options$deli[1];var closeIndex=context.source.indexOf(close,open.length);if(closeIndex===-1){emitError(context,25/* X_MISSING_INTERPOLATION_END */);return undefined;}var start=getCursor(context);advanceBy(context,open.length);var innerStart=getCursor(context);var innerEnd=getCursor(context);var rawContentLength=closeIndex-open.length;var rawContent=context.source.slice(0,rawContentLength);var preTrimContent=parseTextData(context,rawContentLength,mode);var content=preTrimContent.trim();var startOffset=preTrimContent.indexOf(content);if(startOffset>0){advancePositionWithMutation(innerStart,rawContent,startOffset);}var endOffset=rawContentLength-(preTrimContent.length-content.length-startOffset);advancePositionWithMutation(innerEnd,rawContent,endOffset);advanceBy(context,close.length);return{type:5/* INTERPOLATION */,content:{type:4/* SIMPLE_EXPRESSION */,isStatic:false,// Set `isConstant` to false by default and will decide in transformExpression
constType:0/* NOT_CONSTANT */,content:content,loc:getSelection(context,innerStart,innerEnd)},loc:getSelection(context,start)};}function parseText(context,mode){var endTokens=mode===3/* CDATA */?[']]>']:['<',context.options.delimiters[0]];var endIndex=context.source.length;for(var i=0;i<endTokens.length;i++){var index=context.source.indexOf(endTokens[i],1);if(index!==-1&&endIndex>index){endIndex=index;}}var start=getCursor(context);var content=parseTextData(context,endIndex,mode);return{type:2/* TEXT */,content:content,loc:getSelection(context,start)};}/**
 * Get text data with a given length from the current location.
 * This translates HTML entities in the text data.
 */function parseTextData(context,length,mode){var rawText=context.source.slice(0,length);advanceBy(context,length);if(mode===2/* RAWTEXT */||mode===3/* CDATA */||!rawText.includes('&')){return rawText;}else{// DATA or RCDATA containing "&"". Entity decoding required.
return context.options.decodeEntities(rawText,mode===4/* ATTRIBUTE_VALUE */);}}function getCursor(context){var column=context.column,line=context.line,offset=context.offset;return{column:column,line:line,offset:offset};}function getSelection(context,start,end){end=end||getCursor(context);return{start:start,end:end,source:context.originalSource.slice(start.offset,end.offset)};}function last(xs){return xs[xs.length-1];}function startsWith(source,searchString){return source.startsWith(searchString);}function advanceBy(context,numberOfCharacters){var source=context.source;advancePositionWithMutation(context,source,numberOfCharacters);context.source=source.slice(numberOfCharacters);}function advanceSpaces(context){var match=/^[\t\r\n\f ]+/.exec(context.source);if(match){advanceBy(context,match[0].length);}}function getNewPosition(context,start,numberOfCharacters){return advancePositionWithClone(start,context.originalSource.slice(start.offset,numberOfCharacters),numberOfCharacters);}function emitError(context,code,offset){var loc=arguments.length>3&&arguments[3]!==undefined?arguments[3]:getCursor(context);if(offset){loc.offset+=offset;loc.column+=offset;}context.options.onError(createCompilerError(code,{start:loc,end:loc,source:''}));}function isEnd(context,mode,ancestors){var s=context.source;switch(mode){case 0/* DATA */:if(startsWith(s,'</')){// TODO: probably bad performance
for(var i=ancestors.length-1;i>=0;--i){if(startsWithEndTagOpen(s,ancestors[i].tag)){return true;}}}break;case 1/* RCDATA */:case 2/* RAWTEXT */:{var parent=last(ancestors);if(parent&&startsWithEndTagOpen(s,parent.tag)){return true;}break;}case 3/* CDATA */:if(startsWith(s,']]>')){return true;}break;}return!s;}function startsWithEndTagOpen(source,tag){return startsWith(source,'</')&&source.slice(2,2+tag.length).toLowerCase()===tag.toLowerCase()&&/[\t\r\n\f />]/.test(source[2+tag.length]||'>');}function hoistStatic(root,context){walk(root,context,// Root node is unfortunately non-hoistable due to potential parent
// fallthrough attributes.
isSingleElementRoot(root,root.children[0]));}function isSingleElementRoot(root,child){var children=root.children;return children.length===1&&child.type===1/* ELEMENT */&&!isSlotOutlet(child);}function walk(node,context){var doNotHoistNode=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var children=node.children;var originalCount=children.length;var hoistedCount=0;for(var i=0;i<children.length;i++){var child=children[i];// only plain elements & text calls are eligible for hoisting.
if(child.type===1/* ELEMENT */&&child.tagType===0/* ELEMENT */){var constantType=doNotHoistNode?0/* NOT_CONSTANT */:getConstantType(child,context);if(constantType>0/* NOT_CONSTANT */){if(constantType>=2/* CAN_HOIST */){child.codegenNode.patchFlag=-1/* HOISTED */+" /* HOISTED */";child.codegenNode=context.hoist(child.codegenNode);hoistedCount++;continue;}}else{// node may contain dynamic children, but its props may be eligible for
// hoisting.
var codegenNode=child.codegenNode;if(codegenNode.type===13/* VNODE_CALL */){var flag=getPatchFlag(codegenNode);if((!flag||flag===512/* NEED_PATCH */||flag===1/* TEXT */)&&getGeneratedPropsConstantType(child,context)>=2/* CAN_HOIST */){var props=getNodeProps(child);if(props){codegenNode.props=context.hoist(props);}}if(codegenNode.dynamicProps){codegenNode.dynamicProps=context.hoist(codegenNode.dynamicProps);}}}}else if(child.type===12/* TEXT_CALL */&&getConstantType(child.content,context)>=2/* CAN_HOIST */){child.codegenNode=context.hoist(child.codegenNode);hoistedCount++;}// walk further
if(child.type===1/* ELEMENT */){var _isComponent=child.tagType===1/* COMPONENT */;if(_isComponent){context.scopes.vSlot++;}walk(child,context);if(_isComponent){context.scopes.vSlot--;}}else if(child.type===11/* FOR */){// Do not hoist v-for single child because it has to be a block
walk(child,context,child.children.length===1);}else if(child.type===9/* IF */){for(var _i9=0;_i9<child.branches.length;_i9++){// Do not hoist v-if single child because it has to be a block
walk(child.branches[_i9],context,child.branches[_i9].children.length===1);}}}if(hoistedCount&&context.transformHoist){context.transformHoist(children,context,node);}// all children were hoisted - the entire children array is hoistable.
if(hoistedCount&&hoistedCount===originalCount&&node.type===1/* ELEMENT */&&node.tagType===0/* ELEMENT */&&node.codegenNode&&node.codegenNode.type===13/* VNODE_CALL */&&isArray(node.codegenNode.children)){node.codegenNode.children=context.hoist(createArrayExpression(node.codegenNode.children));}}function getConstantType(node,context){var constantCache=context.constantCache;switch(node.type){case 1/* ELEMENT */:if(node.tagType!==0/* ELEMENT */){return 0/* NOT_CONSTANT */;}var cached=constantCache.get(node);if(cached!==undefined){return cached;}var codegenNode=node.codegenNode;if(codegenNode.type!==13/* VNODE_CALL */){return 0/* NOT_CONSTANT */;}if(codegenNode.isBlock&&node.tag!=='svg'&&node.tag!=='foreignObject'){return 0/* NOT_CONSTANT */;}var flag=getPatchFlag(codegenNode);if(!flag){var _returnType=3/* CAN_STRINGIFY */;// Element itself has no patch flag. However we still need to check:
// 1. Even for a node with no patch flag, it is possible for it to contain
// non-hoistable expressions that refers to scope variables, e.g. compiler
// injected keys or cached event handlers. Therefore we need to always
// check the codegenNode's props to be sure.
var generatedPropsType=getGeneratedPropsConstantType(node,context);if(generatedPropsType===0/* NOT_CONSTANT */){constantCache.set(node,0/* NOT_CONSTANT */);return 0/* NOT_CONSTANT */;}if(generatedPropsType<_returnType){_returnType=generatedPropsType;}// 2. its children.
for(var i=0;i<node.children.length;i++){var childType=getConstantType(node.children[i],context);if(childType===0/* NOT_CONSTANT */){constantCache.set(node,0/* NOT_CONSTANT */);return 0/* NOT_CONSTANT */;}if(childType<_returnType){_returnType=childType;}}// 3. if the type is not already CAN_SKIP_PATCH which is the lowest non-0
// type, check if any of the props can cause the type to be lowered
// we can skip can_patch because it's guaranteed by the absence of a
// patchFlag.
if(_returnType>1/* CAN_SKIP_PATCH */){for(var _i10=0;_i10<node.props.length;_i10++){var _p4=node.props[_i10];if(_p4.type===7/* DIRECTIVE */&&_p4.name==='bind'&&_p4.exp){var expType=getConstantType(_p4.exp,context);if(expType===0/* NOT_CONSTANT */){constantCache.set(node,0/* NOT_CONSTANT */);return 0/* NOT_CONSTANT */;}if(expType<_returnType){_returnType=expType;}}}}// only svg/foreignObject could be block here, however if they are
// static then they don't need to be blocks since there will be no
// nested updates.
if(codegenNode.isBlock){context.removeHelper(OPEN_BLOCK);context.removeHelper(getVNodeBlockHelper(context.inSSR,codegenNode.isComponent));codegenNode.isBlock=false;context.helper(getVNodeHelper(context.inSSR,codegenNode.isComponent));}constantCache.set(node,_returnType);return _returnType;}else{constantCache.set(node,0/* NOT_CONSTANT */);return 0/* NOT_CONSTANT */;}case 2/* TEXT */:case 3/* COMMENT */:return 3/* CAN_STRINGIFY */;case 9/* IF */:case 11/* FOR */:case 10/* IF_BRANCH */:return 0/* NOT_CONSTANT */;case 5/* INTERPOLATION */:case 12/* TEXT_CALL */:return getConstantType(node.content,context);case 4/* SIMPLE_EXPRESSION */:return node.constType;case 8/* COMPOUND_EXPRESSION */:var returnType=3/* CAN_STRINGIFY */;for(var _i11=0;_i11<node.children.length;_i11++){var child=node.children[_i11];if(isString(child)||isSymbol(child)){continue;}var _childType=getConstantType(child,context);if(_childType===0/* NOT_CONSTANT */){return 0/* NOT_CONSTANT */;}else if(_childType<returnType){returnType=_childType;}}return returnType;default:return 0/* NOT_CONSTANT */;}}var allowHoistedHelperSet=new Set([NORMALIZE_CLASS,NORMALIZE_STYLE,NORMALIZE_PROPS,GUARD_REACTIVE_PROPS]);function getConstantTypeOfHelperCall(value,context){if(value.type===14/* JS_CALL_EXPRESSION */&&!isString(value.callee)&&allowHoistedHelperSet.has(value.callee)){var arg=value.arguments[0];if(arg.type===4/* SIMPLE_EXPRESSION */){return getConstantType(arg,context);}else if(arg.type===14/* JS_CALL_EXPRESSION */){// in the case of nested helper call, e.g. `normalizeProps(guardReactiveProps(exp))`
return getConstantTypeOfHelperCall(arg,context);}}return 0/* NOT_CONSTANT */;}function getGeneratedPropsConstantType(node,context){var returnType=3/* CAN_STRINGIFY */;var props=getNodeProps(node);if(props&&props.type===15/* JS_OBJECT_EXPRESSION */){var properties=props.properties;for(var i=0;i<properties.length;i++){var _properties$i=properties[i],key=_properties$i.key,value=_properties$i.value;var keyType=getConstantType(key,context);if(keyType===0/* NOT_CONSTANT */){return keyType;}if(keyType<returnType){returnType=keyType;}var valueType=void 0;if(value.type===4/* SIMPLE_EXPRESSION */){valueType=getConstantType(value,context);}else if(value.type===14/* JS_CALL_EXPRESSION */){// some helper calls can be hoisted,
// such as the `normalizeProps` generated by the compiler for pre-normalize class,
// in this case we need to respect the ConstantType of the helper's arguments
valueType=getConstantTypeOfHelperCall(value,context);}else{valueType=0/* NOT_CONSTANT */;}if(valueType===0/* NOT_CONSTANT */){return valueType;}if(valueType<returnType){returnType=valueType;}}}return returnType;}function getNodeProps(node){var codegenNode=node.codegenNode;if(codegenNode.type===13/* VNODE_CALL */){return codegenNode.props;}}function getPatchFlag(node){var flag=node.patchFlag;return flag?parseInt(flag,10):undefined;}function createTransformContext(root,_ref49){var _ref49$filename=_ref49.filename,filename=_ref49$filename===void 0?'':_ref49$filename,_ref49$prefixIdentifi=_ref49.prefixIdentifiers,prefixIdentifiers=_ref49$prefixIdentifi===void 0?false:_ref49$prefixIdentifi,_ref49$hoistStatic=_ref49.hoistStatic,hoistStatic=_ref49$hoistStatic===void 0?false:_ref49$hoistStatic,_ref49$cacheHandlers=_ref49.cacheHandlers,cacheHandlers=_ref49$cacheHandlers===void 0?false:_ref49$cacheHandlers,_ref49$nodeTransforms=_ref49.nodeTransforms,nodeTransforms=_ref49$nodeTransforms===void 0?[]:_ref49$nodeTransforms,_ref49$directiveTrans=_ref49.directiveTransforms,directiveTransforms=_ref49$directiveTrans===void 0?{}:_ref49$directiveTrans,_ref49$transformHoist=_ref49.transformHoist,transformHoist=_ref49$transformHoist===void 0?null:_ref49$transformHoist,_ref49$isBuiltInCompo=_ref49.isBuiltInComponent,isBuiltInComponent=_ref49$isBuiltInCompo===void 0?NOOP:_ref49$isBuiltInCompo,_ref49$isCustomElemen=_ref49.isCustomElement,isCustomElement=_ref49$isCustomElemen===void 0?NOOP:_ref49$isCustomElemen,_ref49$expressionPlug=_ref49.expressionPlugins,expressionPlugins=_ref49$expressionPlug===void 0?[]:_ref49$expressionPlug,_ref49$scopeId=_ref49.scopeId,scopeId=_ref49$scopeId===void 0?null:_ref49$scopeId,_ref49$slotted=_ref49.slotted,slotted=_ref49$slotted===void 0?true:_ref49$slotted,_ref49$ssr=_ref49.ssr,ssr=_ref49$ssr===void 0?false:_ref49$ssr,_ref49$inSSR=_ref49.inSSR,inSSR=_ref49$inSSR===void 0?false:_ref49$inSSR,_ref49$ssrCssVars=_ref49.ssrCssVars,ssrCssVars=_ref49$ssrCssVars===void 0?"":_ref49$ssrCssVars,_ref49$bindingMetadat=_ref49.bindingMetadata,bindingMetadata=_ref49$bindingMetadat===void 0?EMPTY_OBJ:_ref49$bindingMetadat,_ref49$inline=_ref49.inline,inline=_ref49$inline===void 0?false:_ref49$inline,_ref49$isTS=_ref49.isTS,isTS=_ref49$isTS===void 0?false:_ref49$isTS,_ref49$onError=_ref49.onError,onError=_ref49$onError===void 0?defaultOnError:_ref49$onError,_ref49$onWarn=_ref49.onWarn,onWarn=_ref49$onWarn===void 0?defaultOnWarn:_ref49$onWarn,compatConfig=_ref49.compatConfig;var nameMatch=filename.replace(/\?.*$/,'').match(/([^/\\]+)\.\w+$/);var context={// options
selfName:nameMatch&&capitalize(camelize(nameMatch[1])),prefixIdentifiers:prefixIdentifiers,hoistStatic:hoistStatic,cacheHandlers:cacheHandlers,nodeTransforms:nodeTransforms,directiveTransforms:directiveTransforms,transformHoist:transformHoist,isBuiltInComponent:isBuiltInComponent,isCustomElement:isCustomElement,expressionPlugins:expressionPlugins,scopeId:scopeId,slotted:slotted,ssr:ssr,inSSR:inSSR,ssrCssVars:ssrCssVars,bindingMetadata:bindingMetadata,inline:inline,isTS:isTS,onError:onError,onWarn:onWarn,compatConfig:compatConfig,// state
root:root,helpers:new Map(),components:new Set(),directives:new Set(),hoists:[],imports:[],constantCache:new Map(),temps:0,cached:0,identifiers:Object.create(null),scopes:{vFor:0,vSlot:0,vPre:0,vOnce:0},parent:null,currentNode:root,childIndex:0,inVOnce:false,// methods
helper:function helper(name){var count=context.helpers.get(name)||0;context.helpers.set(name,count+1);return name;},removeHelper:function removeHelper(name){var count=context.helpers.get(name);if(count){var currentCount=count-1;if(!currentCount){context.helpers.delete(name);}else{context.helpers.set(name,currentCount);}}},helperString:function helperString(name){return"_".concat(helperNameMap[context.helper(name)]);},replaceNode:function replaceNode(node){/* istanbul ignore if */{if(!context.currentNode){throw new Error("Node being replaced is already removed.");}if(!context.parent){throw new Error("Cannot replace root node.");}}context.parent.children[context.childIndex]=context.currentNode=node;},removeNode:function removeNode(node){if(!context.parent){throw new Error("Cannot remove root node.");}var list=context.parent.children;var removalIndex=node?list.indexOf(node):context.currentNode?context.childIndex:-1;/* istanbul ignore if */if(removalIndex<0){throw new Error("node being removed is not a child of current parent");}if(!node||node===context.currentNode){// current node removed
context.currentNode=null;context.onNodeRemoved();}else{// sibling node removed
if(context.childIndex>removalIndex){context.childIndex--;context.onNodeRemoved();}}context.parent.children.splice(removalIndex,1);},onNodeRemoved:function onNodeRemoved(){},addIdentifiers:function addIdentifiers(exp){},removeIdentifiers:function removeIdentifiers(exp){},hoist:function hoist(exp){if(isString(exp))exp=createSimpleExpression(exp);context.hoists.push(exp);var identifier=createSimpleExpression("_hoisted_".concat(context.hoists.length),false,exp.loc,2/* CAN_HOIST */);identifier.hoisted=exp;return identifier;},cache:function cache(exp){var isVNode=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;return createCacheExpression(context.cached++,exp,isVNode);}};return context;}function transform(root,options){var context=createTransformContext(root,options);traverseNode(root,context);if(options.hoistStatic){hoistStatic(root,context);}if(!options.ssr){createRootCodegen(root,context);}// finalize meta information
root.helpers=_toConsumableArray(context.helpers.keys());root.components=_toConsumableArray(context.components);root.directives=_toConsumableArray(context.directives);root.imports=context.imports;root.hoists=context.hoists;root.temps=context.temps;root.cached=context.cached;}function createRootCodegen(root,context){var helper=context.helper;var children=root.children;if(children.length===1){var child=children[0];// if the single child is an element, turn it into a block.
if(isSingleElementRoot(root,child)&&child.codegenNode){// single element root is never hoisted so codegenNode will never be
// SimpleExpressionNode
var codegenNode=child.codegenNode;if(codegenNode.type===13/* VNODE_CALL */){makeBlock(codegenNode,context);}root.codegenNode=codegenNode;}else{// - single <slot/>, IfNode, ForNode: already blocks.
// - single text node: always patched.
// root codegen falls through via genNode()
root.codegenNode=child;}}else if(children.length>1){// root has multiple nodes - return a fragment block.
var patchFlag=64/* STABLE_FRAGMENT */;var patchFlagText=PatchFlagNames[64/* STABLE_FRAGMENT */];// check if the fragment actually contains a single valid child with
// the rest being comments
if(children.filter(function(c){return c.type!==3;}/* COMMENT */).length===1){patchFlag|=2048/* DEV_ROOT_FRAGMENT */;patchFlagText+=", ".concat(PatchFlagNames[2048/* DEV_ROOT_FRAGMENT */]);}root.codegenNode=createVNodeCall(context,helper(FRAGMENT),undefined,root.children,patchFlag+" /* ".concat(patchFlagText," */"),undefined,undefined,true,undefined,false/* isComponent */);}else;}function traverseChildren(parent,context){var i=0;var nodeRemoved=function nodeRemoved(){i--;};for(;i<parent.children.length;i++){var child=parent.children[i];if(isString(child))continue;context.parent=parent;context.childIndex=i;context.onNodeRemoved=nodeRemoved;traverseNode(child,context);}}function traverseNode(node,context){context.currentNode=node;// apply transform plugins
var nodeTransforms=context.nodeTransforms;var exitFns=[];for(var _i12=0;_i12<nodeTransforms.length;_i12++){var onExit=nodeTransforms[_i12](node,context);if(onExit){if(isArray(onExit)){exitFns.push.apply(exitFns,_toConsumableArray(onExit));}else{exitFns.push(onExit);}}if(!context.currentNode){// node was removed
return;}else{// node may have been replaced
node=context.currentNode;}}switch(node.type){case 3/* COMMENT */:if(!context.ssr){// inject import for the Comment symbol, which is needed for creating
// comment nodes with `createVNode`
context.helper(CREATE_COMMENT);}break;case 5/* INTERPOLATION */:// no need to traverse, but we need to inject toString helper
if(!context.ssr){context.helper(TO_DISPLAY_STRING);}break;// for container types, further traverse downwards
case 9/* IF */:for(var _i13=0;_i13<node.branches.length;_i13++){traverseNode(node.branches[_i13],context);}break;case 10/* IF_BRANCH */:case 11/* FOR */:case 1/* ELEMENT */:case 0/* ROOT */:traverseChildren(node,context);break;}// exit transforms
context.currentNode=node;var i=exitFns.length;while(i--){exitFns[i]();}}function createStructuralDirectiveTransform(name,fn){var matches=isString(name)?function(n){return n===name;}:function(n){return name.test(n);};return function(node,context){if(node.type===1/* ELEMENT */){var props=node.props;// structural directive transforms are not concerned with slots
// as they are handled separately in vSlot.ts
if(node.tagType===3/* TEMPLATE */&&props.some(isVSlot)){return;}var exitFns=[];for(var i=0;i<props.length;i++){var prop=props[i];if(prop.type===7/* DIRECTIVE */&&matches(prop.name)){// structural directives are removed to avoid infinite recursion
// also we remove them *before* applying so that it can further
// traverse itself in case it moves the node around
props.splice(i,1);i--;var onExit=fn(node,prop,context);if(onExit)exitFns.push(onExit);}}return exitFns;}};}var PURE_ANNOTATION="/*#__PURE__*/";function createCodegenContext(ast,_ref50){var _ref50$mode=_ref50.mode,mode=_ref50$mode===void 0?'function':_ref50$mode,_ref50$prefixIdentifi=_ref50.prefixIdentifiers,prefixIdentifiers=_ref50$prefixIdentifi===void 0?mode==='module':_ref50$prefixIdentifi,_ref50$sourceMap=_ref50.sourceMap,sourceMap=_ref50$sourceMap===void 0?false:_ref50$sourceMap,_ref50$filename=_ref50.filename,filename=_ref50$filename===void 0?"template.vue.html":_ref50$filename,_ref50$scopeId=_ref50.scopeId,scopeId=_ref50$scopeId===void 0?null:_ref50$scopeId,_ref50$optimizeImport=_ref50.optimizeImports,optimizeImports=_ref50$optimizeImport===void 0?false:_ref50$optimizeImport,_ref50$runtimeGlobalN=_ref50.runtimeGlobalName,runtimeGlobalName=_ref50$runtimeGlobalN===void 0?"Vue":_ref50$runtimeGlobalN,_ref50$runtimeModuleN=_ref50.runtimeModuleName,runtimeModuleName=_ref50$runtimeModuleN===void 0?"vue":_ref50$runtimeModuleN,_ref50$ssrRuntimeModu=_ref50.ssrRuntimeModuleName,ssrRuntimeModuleName=_ref50$ssrRuntimeModu===void 0?'vue/server-renderer':_ref50$ssrRuntimeModu,_ref50$ssr=_ref50.ssr,ssr=_ref50$ssr===void 0?false:_ref50$ssr,_ref50$isTS=_ref50.isTS,isTS=_ref50$isTS===void 0?false:_ref50$isTS,_ref50$inSSR=_ref50.inSSR,inSSR=_ref50$inSSR===void 0?false:_ref50$inSSR;var context={mode:mode,prefixIdentifiers:prefixIdentifiers,sourceMap:sourceMap,filename:filename,scopeId:scopeId,optimizeImports:optimizeImports,runtimeGlobalName:runtimeGlobalName,runtimeModuleName:runtimeModuleName,ssrRuntimeModuleName:ssrRuntimeModuleName,ssr:ssr,isTS:isTS,inSSR:inSSR,source:ast.loc.source,code:"",column:1,line:1,offset:0,indentLevel:0,pure:false,map:undefined,helper:function helper(key){return"_".concat(helperNameMap[key]);},push:function push(code,node){context.code+=code;},indent:function indent(){_newline(++context.indentLevel);},deindent:function deindent(){var withoutNewLine=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(withoutNewLine){--context.indentLevel;}else{_newline(--context.indentLevel);}},newline:function newline(){_newline(context.indentLevel);}};function _newline(n){context.push('\n'+"  ".repeat(n));}return context;}function generate(ast){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var context=createCodegenContext(ast,options);if(options.onContextCreated)options.onContextCreated(context);var mode=context.mode,push=context.push,prefixIdentifiers=context.prefixIdentifiers,indent=context.indent,deindent=context.deindent,newline=context.newline,scopeId=context.scopeId,ssr=context.ssr;var hasHelpers=ast.helpers.length>0;var useWithBlock=!prefixIdentifiers&&mode!=='module';// preambles
// in setup() inline mode, the preamble is generated in a sub context
// and returned separately.
var preambleContext=context;{genFunctionPreamble(ast,preambleContext);}// enter render function
var functionName=ssr?"ssrRender":"render";var args=ssr?['_ctx','_push','_parent','_attrs']:['_ctx','_cache'];var signature=args.join(', ');{push("function ".concat(functionName,"(").concat(signature,") {"));}indent();if(useWithBlock){push("with (_ctx) {");indent();// function mode const declarations should be inside with block
// also they should be renamed to avoid collision with user properties
if(hasHelpers){push("const { ".concat(ast.helpers.map(function(s){return"".concat(helperNameMap[s],": _").concat(helperNameMap[s]);}).join(', ')," } = _Vue"));push("\n");newline();}}// generate asset resolution statements
if(ast.components.length){genAssets(ast.components,'component',context);if(ast.directives.length||ast.temps>0){newline();}}if(ast.directives.length){genAssets(ast.directives,'directive',context);if(ast.temps>0){newline();}}if(ast.temps>0){push("let ");for(var i=0;i<ast.temps;i++){push("".concat(i>0?", ":"","_temp").concat(i));}}if(ast.components.length||ast.directives.length||ast.temps){push("\n");newline();}// generate the VNode tree expression
if(!ssr){push("return ");}if(ast.codegenNode){genNode(ast.codegenNode,context);}else{push("null");}if(useWithBlock){deindent();push("}");}deindent();push("}");return{ast:ast,code:context.code,preamble:"",// SourceMapGenerator does have toJSON() method but it's not in the types
map:context.map?context.map.toJSON():undefined};}function genFunctionPreamble(ast,context){var ssr=context.ssr,prefixIdentifiers=context.prefixIdentifiers,push=context.push,newline=context.newline,runtimeModuleName=context.runtimeModuleName,runtimeGlobalName=context.runtimeGlobalName,ssrRuntimeModuleName=context.ssrRuntimeModuleName;var VueBinding=runtimeGlobalName;var aliasHelper=function aliasHelper(s){return"".concat(helperNameMap[s],": _").concat(helperNameMap[s]);};// Generate const declaration for helpers
// In prefix mode, we place the const declaration at top so it's done
// only once; But if we not prefixing, we place the declaration inside the
// with block so it doesn't incur the `in` check cost for every helper access.
if(ast.helpers.length>0){{// "with" mode.
// save Vue in a separate variable to avoid collision
push("const _Vue = ".concat(VueBinding,"\n"));// in "with" mode, helpers are declared inside the with block to avoid
// has check cost, but hoists are lifted out of the function - we need
// to provide the helper here.
if(ast.hoists.length){var staticHelpers=[CREATE_VNODE,CREATE_ELEMENT_VNODE,CREATE_COMMENT,CREATE_TEXT,CREATE_STATIC].filter(function(helper){return ast.helpers.includes(helper);}).map(aliasHelper).join(', ');push("const { ".concat(staticHelpers," } = _Vue\n"));}}}genHoists(ast.hoists,context);newline();push("return ");}function genAssets(assets,type,_ref51){var helper=_ref51.helper,push=_ref51.push,newline=_ref51.newline,isTS=_ref51.isTS;var resolver=helper(type==='component'?RESOLVE_COMPONENT:RESOLVE_DIRECTIVE);for(var i=0;i<assets.length;i++){var id=assets[i];// potential component implicit self-reference inferred from SFC filename
var maybeSelfReference=id.endsWith('__self');if(maybeSelfReference){id=id.slice(0,-6);}push("const ".concat(toValidAssetId(id,type)," = ").concat(resolver,"(").concat(JSON.stringify(id)).concat(maybeSelfReference?", true":"",")").concat(isTS?"!":""));if(i<assets.length-1){newline();}}}function genHoists(hoists,context){if(!hoists.length){return;}context.pure=true;var push=context.push,newline=context.newline,helper=context.helper,scopeId=context.scopeId,mode=context.mode;newline();for(var i=0;i<hoists.length;i++){var exp=hoists[i];if(exp){push("const _hoisted_".concat(i+1," = ",""));genNode(exp,context);newline();}}context.pure=false;}function isText$1(n){return isString(n)||n.type===4/* SIMPLE_EXPRESSION */||n.type===2/* TEXT */||n.type===5/* INTERPOLATION */||n.type===8/* COMPOUND_EXPRESSION */;}function genNodeListAsArray(nodes,context){var multilines=nodes.length>3||nodes.some(function(n){return isArray(n)||!isText$1(n);});context.push("[");multilines&&context.indent();genNodeList(nodes,context,multilines);multilines&&context.deindent();context.push("]");}function genNodeList(nodes,context){var multilines=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var comma=arguments.length>3&&arguments[3]!==undefined?arguments[3]:true;var push=context.push,newline=context.newline;for(var i=0;i<nodes.length;i++){var node=nodes[i];if(isString(node)){push(node);}else if(isArray(node)){genNodeListAsArray(node,context);}else{genNode(node,context);}if(i<nodes.length-1){if(multilines){comma&&push(',');newline();}else{comma&&push(', ');}}}}function genNode(node,context){if(isString(node)){context.push(node);return;}if(isSymbol(node)){context.push(context.helper(node));return;}switch(node.type){case 1/* ELEMENT */:case 9/* IF */:case 11/* FOR */:assert(node.codegenNode!=null,"Codegen node is missing for element/if/for node. "+"Apply appropriate transforms first.");genNode(node.codegenNode,context);break;case 2/* TEXT */:genText(node,context);break;case 4/* SIMPLE_EXPRESSION */:genExpression(node,context);break;case 5/* INTERPOLATION */:genInterpolation(node,context);break;case 12/* TEXT_CALL */:genNode(node.codegenNode,context);break;case 8/* COMPOUND_EXPRESSION */:genCompoundExpression(node,context);break;case 3/* COMMENT */:genComment(node,context);break;case 13/* VNODE_CALL */:genVNodeCall(node,context);break;case 14/* JS_CALL_EXPRESSION */:genCallExpression(node,context);break;case 15/* JS_OBJECT_EXPRESSION */:genObjectExpression(node,context);break;case 17/* JS_ARRAY_EXPRESSION */:genArrayExpression(node,context);break;case 18/* JS_FUNCTION_EXPRESSION */:genFunctionExpression(node,context);break;case 19/* JS_CONDITIONAL_EXPRESSION */:genConditionalExpression(node,context);break;case 20/* JS_CACHE_EXPRESSION */:genCacheExpression(node,context);break;case 21/* JS_BLOCK_STATEMENT */:genNodeList(node.body,context,true,false);break;// SSR only types
case 22/* JS_TEMPLATE_LITERAL */:break;case 23/* JS_IF_STATEMENT */:break;case 24/* JS_ASSIGNMENT_EXPRESSION */:break;case 25/* JS_SEQUENCE_EXPRESSION */:break;case 26/* JS_RETURN_STATEMENT */:break;/* istanbul ignore next */case 10/* IF_BRANCH */:// noop
break;default:{assert(false,"unhandled codegen node type: ".concat(node.type));// make sure we exhaust all possible types
var exhaustiveCheck=node;return exhaustiveCheck;}}}function genText(node,context){context.push(JSON.stringify(node.content),node);}function genExpression(node,context){var content=node.content,isStatic=node.isStatic;context.push(isStatic?JSON.stringify(content):content,node);}function genInterpolation(node,context){var push=context.push,helper=context.helper,pure=context.pure;if(pure)push(PURE_ANNOTATION);push("".concat(helper(TO_DISPLAY_STRING),"("));genNode(node.content,context);push(")");}function genCompoundExpression(node,context){for(var i=0;i<node.children.length;i++){var child=node.children[i];if(isString(child)){context.push(child);}else{genNode(child,context);}}}function genExpressionAsPropertyKey(node,context){var push=context.push;if(node.type===8/* COMPOUND_EXPRESSION */){push("[");genCompoundExpression(node,context);push("]");}else if(node.isStatic){// only quote keys if necessary
var text=isSimpleIdentifier(node.content)?node.content:JSON.stringify(node.content);push(text,node);}else{push("[".concat(node.content,"]"),node);}}function genComment(node,context){var push=context.push,helper=context.helper,pure=context.pure;if(pure){push(PURE_ANNOTATION);}push("".concat(helper(CREATE_COMMENT),"(").concat(JSON.stringify(node.content),")"),node);}function genVNodeCall(node,context){var push=context.push,helper=context.helper,pure=context.pure;var tag=node.tag,props=node.props,children=node.children,patchFlag=node.patchFlag,dynamicProps=node.dynamicProps,directives=node.directives,isBlock=node.isBlock,disableTracking=node.disableTracking,isComponent=node.isComponent;if(directives){push(helper(WITH_DIRECTIVES)+"(");}if(isBlock){push("(".concat(helper(OPEN_BLOCK),"(").concat(disableTracking?"true":"","), "));}if(pure){push(PURE_ANNOTATION);}var callHelper=isBlock?getVNodeBlockHelper(context.inSSR,isComponent):getVNodeHelper(context.inSSR,isComponent);push(helper(callHelper)+"(",node);genNodeList(genNullableArgs([tag,props,children,patchFlag,dynamicProps]),context);push(")");if(isBlock){push(")");}if(directives){push(", ");genNode(directives,context);push(")");}}function genNullableArgs(args){var i=args.length;while(i--){if(args[i]!=null)break;}return args.slice(0,i+1).map(function(arg){return arg||"null";});}// JavaScript
function genCallExpression(node,context){var push=context.push,helper=context.helper,pure=context.pure;var callee=isString(node.callee)?node.callee:helper(node.callee);if(pure){push(PURE_ANNOTATION);}push(callee+"(",node);genNodeList(node.arguments,context);push(")");}function genObjectExpression(node,context){var push=context.push,indent=context.indent,deindent=context.deindent,newline=context.newline;var properties=node.properties;if(!properties.length){push("{}",node);return;}var multilines=properties.length>1||properties.some(function(p){return p.value.type!==4;}/* SIMPLE_EXPRESSION */);push(multilines?"{":"{ ");multilines&&indent();for(var i=0;i<properties.length;i++){var _properties$i2=properties[i],key=_properties$i2.key,value=_properties$i2.value;// key
genExpressionAsPropertyKey(key,context);push(": ");// value
genNode(value,context);if(i<properties.length-1){// will only reach this if it's multilines
push(",");newline();}}multilines&&deindent();push(multilines?"}":" }");}function genArrayExpression(node,context){genNodeListAsArray(node.elements,context);}function genFunctionExpression(node,context){var push=context.push,indent=context.indent,deindent=context.deindent;var params=node.params,returns=node.returns,body=node.body,newline=node.newline,isSlot=node.isSlot;if(isSlot){// wrap slot functions with owner context
push("_".concat(helperNameMap[WITH_CTX],"("));}push("(",node);if(isArray(params)){genNodeList(params,context);}else if(params){genNode(params,context);}push(") => ");if(newline||body){push("{");indent();}if(returns){if(newline){push("return ");}if(isArray(returns)){genNodeListAsArray(returns,context);}else{genNode(returns,context);}}else if(body){genNode(body,context);}if(newline||body){deindent();push("}");}if(isSlot){push(")");}}function genConditionalExpression(node,context){var test=node.test,consequent=node.consequent,alternate=node.alternate,needNewline=node.newline;var push=context.push,indent=context.indent,deindent=context.deindent,newline=context.newline;if(test.type===4/* SIMPLE_EXPRESSION */){var needsParens=!isSimpleIdentifier(test.content);needsParens&&push("(");genExpression(test,context);needsParens&&push(")");}else{push("(");genNode(test,context);push(")");}needNewline&&indent();context.indentLevel++;needNewline||push(" ");push("? ");genNode(consequent,context);context.indentLevel--;needNewline&&newline();needNewline||push(" ");push(": ");var isNested=alternate.type===19/* JS_CONDITIONAL_EXPRESSION */;if(!isNested){context.indentLevel++;}genNode(alternate,context);if(!isNested){context.indentLevel--;}needNewline&&deindent(true/* without newline */);}function genCacheExpression(node,context){var push=context.push,helper=context.helper,indent=context.indent,deindent=context.deindent,newline=context.newline;push("_cache[".concat(node.index,"] || ("));if(node.isVNode){indent();push("".concat(helper(SET_BLOCK_TRACKING),"(-1),"));newline();}push("_cache[".concat(node.index,"] = "));genNode(node.value,context);if(node.isVNode){push(",");newline();push("".concat(helper(SET_BLOCK_TRACKING),"(1),"));newline();push("_cache[".concat(node.index,"]"));deindent();}push(")");}// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE=new RegExp('\\b'+('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,'+'super,throw,while,yield,delete,export,import,return,switch,default,'+'extends,finally,continue,debugger,function,arguments,typeof,void').split(',').join('\\b|\\b')+'\\b');// strip strings in expressions
var stripStringRE=/'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;/**
 * Validate a non-prefixed expression.
 * This is only called when using the in-browser runtime compiler since it
 * doesn't prefix expressions.
 */function validateBrowserExpression(node,context){var asParams=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var asRawStatements=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var exp=node.content;// empty expressions are validated per-directive since some directives
// do allow empty expressions.
if(!exp.trim()){return;}try{new Function(asRawStatements?" ".concat(exp," "):"return ".concat(asParams?"(".concat(exp,") => {}"):"(".concat(exp,")")));}catch(e){var message=e.message;var keywordMatch=exp.replace(stripStringRE,'').match(prohibitedKeywordRE);if(keywordMatch){message="avoid using JavaScript keyword as property name: \"".concat(keywordMatch[0],"\"");}context.onError(createCompilerError(44/* X_INVALID_EXPRESSION */,node.loc,undefined,message));}}var transformExpression=function transformExpression(node,context){if(node.type===5/* INTERPOLATION */){node.content=processExpression(node.content,context);}else if(node.type===1/* ELEMENT */){// handle directives on element
for(var i=0;i<node.props.length;i++){var dir=node.props[i];// do not process for v-on & v-for since they are special handled
if(dir.type===7/* DIRECTIVE */&&dir.name!=='for'){var exp=dir.exp;var arg=dir.arg;// do not process exp if this is v-on:arg - we need special handling
// for wrapping inline statements.
if(exp&&exp.type===4/* SIMPLE_EXPRESSION */&&!(dir.name==='on'&&arg)){dir.exp=processExpression(exp,context,// slot args must be processed as function params
dir.name==='slot');}if(arg&&arg.type===4/* SIMPLE_EXPRESSION */&&!arg.isStatic){dir.arg=processExpression(arg,context);}}}}};// Important: since this function uses Node.js only dependencies, it should
// always be used with a leading !true check so that it can be
// tree-shaken from the browser build.
function processExpression(node,context){var asParams=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var asRawStatements=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var localVars=arguments.length>4&&arguments[4]!==undefined?arguments[4]:Object.create(context.identifiers);{{// simple in-browser validation (same logic in 2.x)
validateBrowserExpression(node,context,asParams,asRawStatements);}return node;}}var transformIf=createStructuralDirectiveTransform(/^(if|else|else-if)$/,function(node,dir,context){return processIf(node,dir,context,function(ifNode,branch,isRoot){// #1587: We need to dynamically increment the key based on the current
// node's sibling nodes, since chained v-if/else branches are
// rendered at the same depth
var siblings=context.parent.children;var i=siblings.indexOf(ifNode);var key=0;while(i-->=0){var sibling=siblings[i];if(sibling&&sibling.type===9/* IF */){key+=sibling.branches.length;}}// Exit callback. Complete the codegenNode when all children have been
// transformed.
return function(){if(isRoot){ifNode.codegenNode=createCodegenNodeForBranch(branch,key,context);}else{// attach this branch's codegen node to the v-if root.
var parentCondition=getParentCondition(ifNode.codegenNode);parentCondition.alternate=createCodegenNodeForBranch(branch,key+ifNode.branches.length-1,context);}};});});// target-agnostic transform used for both Client and SSR
function processIf(node,dir,context,processCodegen){if(dir.name!=='else'&&(!dir.exp||!dir.exp.content.trim())){var loc=dir.exp?dir.exp.loc:node.loc;context.onError(createCompilerError(28/* X_V_IF_NO_EXPRESSION */,dir.loc));dir.exp=createSimpleExpression("true",false,loc);}if(dir.exp){validateBrowserExpression(dir.exp,context);}if(dir.name==='if'){var branch=createIfBranch(node,dir);var ifNode={type:9/* IF */,loc:node.loc,branches:[branch]};context.replaceNode(ifNode);if(processCodegen){return processCodegen(ifNode,branch,true);}}else{// locate the adjacent v-if
var siblings=context.parent.children;var comments=[];var i=siblings.indexOf(node);while(i-->=-1){var sibling=siblings[i];if(sibling&&sibling.type===3/* COMMENT */){context.removeNode(sibling);comments.unshift(sibling);continue;}if(sibling&&sibling.type===2/* TEXT */&&!sibling.content.trim().length){context.removeNode(sibling);continue;}if(sibling&&sibling.type===9/* IF */){(function(){// Check if v-else was followed by v-else-if
if(dir.name==='else-if'&&sibling.branches[sibling.branches.length-1].condition===undefined){context.onError(createCompilerError(30/* X_V_ELSE_NO_ADJACENT_IF */,node.loc));}// move the node to the if node's branches
context.removeNode();var branch=createIfBranch(node,dir);if(comments.length&&// #3619 ignore comments if the v-if is direct child of <transition>
!(context.parent&&context.parent.type===1/* ELEMENT */&&isBuiltInType(context.parent.tag,'transition'))){branch.children=[].concat(comments,_toConsumableArray(branch.children));}// check if user is forcing same key on different branches
{var key=branch.userKey;if(key){sibling.branches.forEach(function(_ref52){var userKey=_ref52.userKey;if(isSameKey(userKey,key)){context.onError(createCompilerError(29/* X_V_IF_SAME_KEY */,branch.userKey.loc));}});}}sibling.branches.push(branch);var onExit=processCodegen&&processCodegen(sibling,branch,false);// since the branch was removed, it will not be traversed.
// make sure to traverse here.
traverseNode(branch,context);// call on exit
if(onExit)onExit();// make sure to reset currentNode after traversal to indicate this
// node has been removed.
context.currentNode=null;})();}else{context.onError(createCompilerError(30/* X_V_ELSE_NO_ADJACENT_IF */,node.loc));}break;}}}function createIfBranch(node,dir){return{type:10/* IF_BRANCH */,loc:node.loc,condition:dir.name==='else'?undefined:dir.exp,children:node.tagType===3/* TEMPLATE */&&!findDir(node,'for')?node.children:[node],userKey:findProp(node,"key")};}function createCodegenNodeForBranch(branch,keyIndex,context){if(branch.condition){return createConditionalExpression(branch.condition,createChildrenCodegenNode(branch,keyIndex,context),// make sure to pass in asBlock: true so that the comment node call
// closes the current block.
createCallExpression(context.helper(CREATE_COMMENT),['"v-if"','true']));}else{return createChildrenCodegenNode(branch,keyIndex,context);}}function createChildrenCodegenNode(branch,keyIndex,context){var helper=context.helper;var keyProperty=createObjectProperty("key",createSimpleExpression("".concat(keyIndex),false,locStub,2/* CAN_HOIST */));var children=branch.children;var firstChild=children[0];var needFragmentWrapper=children.length!==1||firstChild.type!==1/* ELEMENT */;if(needFragmentWrapper){if(children.length===1&&firstChild.type===11/* FOR */){// optimize away nested fragments when child is a ForNode
var vnodeCall=firstChild.codegenNode;injectProp(vnodeCall,keyProperty,context);return vnodeCall;}else{var patchFlag=64/* STABLE_FRAGMENT */;var patchFlagText=PatchFlagNames[64/* STABLE_FRAGMENT */];// check if the fragment actually contains a single valid child with
// the rest being comments
if(children.filter(function(c){return c.type!==3;}/* COMMENT */).length===1){patchFlag|=2048/* DEV_ROOT_FRAGMENT */;patchFlagText+=", ".concat(PatchFlagNames[2048/* DEV_ROOT_FRAGMENT */]);}return createVNodeCall(context,helper(FRAGMENT),createObjectExpression([keyProperty]),children,patchFlag+" /* ".concat(patchFlagText," */"),undefined,undefined,true,false,false/* isComponent */,branch.loc);}}else{var ret=firstChild.codegenNode;var _vnodeCall=getMemoedVNodeCall(ret);// Change createVNode to createBlock.
if(_vnodeCall.type===13/* VNODE_CALL */){makeBlock(_vnodeCall,context);}// inject branch key
injectProp(_vnodeCall,keyProperty,context);return ret;}}function isSameKey(a,b){if(!a||a.type!==b.type){return false;}if(a.type===6/* ATTRIBUTE */){if(a.value.content!==b.value.content){return false;}}else{// directive
var exp=a.exp;var branchExp=b.exp;if(exp.type!==branchExp.type){return false;}if(exp.type!==4/* SIMPLE_EXPRESSION */||exp.isStatic!==branchExp.isStatic||exp.content!==branchExp.content){return false;}}return true;}function getParentCondition(node){while(true){if(node.type===19/* JS_CONDITIONAL_EXPRESSION */){if(node.alternate.type===19/* JS_CONDITIONAL_EXPRESSION */){node=node.alternate;}else{return node;}}else if(node.type===20/* JS_CACHE_EXPRESSION */){node=node.value;}}}var transformFor=createStructuralDirectiveTransform('for',function(node,dir,context){var helper=context.helper,removeHelper=context.removeHelper;return processFor(node,dir,context,function(forNode){// create the loop render function expression now, and add the
// iterator on exit after all children have been traversed
var renderExp=createCallExpression(helper(RENDER_LIST),[forNode.source]);var isTemplate=isTemplateNode(node);var memo=findDir(node,'memo');var keyProp=findProp(node,"key");var keyExp=keyProp&&(keyProp.type===6/* ATTRIBUTE */?createSimpleExpression(keyProp.value.content,true):keyProp.exp);var keyProperty=keyProp?createObjectProperty("key",keyExp):null;var isStableFragment=forNode.source.type===4/* SIMPLE_EXPRESSION */&&forNode.source.constType>0/* NOT_CONSTANT */;var fragmentFlag=isStableFragment?64/* STABLE_FRAGMENT */:keyProp?128/* KEYED_FRAGMENT */:256/* UNKEYED_FRAGMENT */;forNode.codegenNode=createVNodeCall(context,helper(FRAGMENT),undefined,renderExp,fragmentFlag+" /* ".concat(PatchFlagNames[fragmentFlag]," */"),undefined,undefined,true/* isBlock */,!isStableFragment/* disableTracking */,false/* isComponent */,node.loc);return function(){// finish the codegen now that all children have been traversed
var childBlock;var children=forNode.children;// check <template v-for> key placement
if(isTemplate){node.children.some(function(c){if(c.type===1/* ELEMENT */){var key=findProp(c,'key');if(key){context.onError(createCompilerError(33/* X_V_FOR_TEMPLATE_KEY_PLACEMENT */,key.loc));return true;}}});}var needFragmentWrapper=children.length!==1||children[0].type!==1/* ELEMENT */;var slotOutlet=isSlotOutlet(node)?node:isTemplate&&node.children.length===1&&isSlotOutlet(node.children[0])?node.children[0]// api-extractor somehow fails to infer this
:null;if(slotOutlet){// <slot v-for="..."> or <template v-for="..."><slot/></template>
childBlock=slotOutlet.codegenNode;if(isTemplate&&keyProperty){// <template v-for="..." :key="..."><slot/></template>
// we need to inject the key to the renderSlot() call.
// the props for renderSlot is passed as the 3rd argument.
injectProp(childBlock,keyProperty,context);}}else if(needFragmentWrapper){// <template v-for="..."> with text or multi-elements
// should generate a fragment block for each loop
childBlock=createVNodeCall(context,helper(FRAGMENT),keyProperty?createObjectExpression([keyProperty]):undefined,node.children,64/* STABLE_FRAGMENT */+" /* ".concat(PatchFlagNames[64/* STABLE_FRAGMENT */]," */"),undefined,undefined,true,undefined,false/* isComponent */);}else{// Normal element v-for. Directly use the child's codegenNode
// but mark it as a block.
childBlock=children[0].codegenNode;if(isTemplate&&keyProperty){injectProp(childBlock,keyProperty,context);}if(childBlock.isBlock!==!isStableFragment){if(childBlock.isBlock){// switch from block to vnode
removeHelper(OPEN_BLOCK);removeHelper(getVNodeBlockHelper(context.inSSR,childBlock.isComponent));}else{// switch from vnode to block
removeHelper(getVNodeHelper(context.inSSR,childBlock.isComponent));}}childBlock.isBlock=!isStableFragment;if(childBlock.isBlock){helper(OPEN_BLOCK);helper(getVNodeBlockHelper(context.inSSR,childBlock.isComponent));}else{helper(getVNodeHelper(context.inSSR,childBlock.isComponent));}}if(memo){var loop=createFunctionExpression(createForLoopParams(forNode.parseResult,[createSimpleExpression("_cached")]));loop.body=createBlockStatement([createCompoundExpression(["const _memo = (",memo.exp,")"]),createCompoundExpression(["if (_cached"].concat(_toConsumableArray(keyExp?[" && _cached.key === ",keyExp]:[]),[" && ".concat(context.helperString(IS_MEMO_SAME),"(_cached, _memo)) return _cached")])),createCompoundExpression(["const _item = ",childBlock]),createSimpleExpression("_item.memo = _memo"),createSimpleExpression("return _item")]);renderExp.arguments.push(loop,createSimpleExpression("_cache"),createSimpleExpression(String(context.cached++)));}else{renderExp.arguments.push(createFunctionExpression(createForLoopParams(forNode.parseResult),childBlock,true/* force newline */));}};});});// target-agnostic transform used for both Client and SSR
function processFor(node,dir,context,processCodegen){if(!dir.exp){context.onError(createCompilerError(31/* X_V_FOR_NO_EXPRESSION */,dir.loc));return;}var parseResult=parseForExpression(// can only be simple expression because vFor transform is applied
// before expression transform.
dir.exp,context);if(!parseResult){context.onError(createCompilerError(32/* X_V_FOR_MALFORMED_EXPRESSION */,dir.loc));return;}var addIdentifiers=context.addIdentifiers,removeIdentifiers=context.removeIdentifiers,scopes=context.scopes;var source=parseResult.source,value=parseResult.value,key=parseResult.key,index=parseResult.index;var forNode={type:11/* FOR */,loc:dir.loc,source:source,valueAlias:value,keyAlias:key,objectIndexAlias:index,parseResult:parseResult,children:isTemplateNode(node)?node.children:[node]};context.replaceNode(forNode);// bookkeeping
scopes.vFor++;var onExit=processCodegen&&processCodegen(forNode);return function(){scopes.vFor--;if(onExit)onExit();};}var forAliasRE=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;// This regex doesn't cover the case if key or index aliases have destructuring,
// but those do not make sense in the first place, so this works in practice.
var forIteratorRE=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/;var stripParensRE=/^\(|\)$/g;function parseForExpression(input,context){var loc=input.loc;var exp=input.content;var inMatch=exp.match(forAliasRE);if(!inMatch)return;var _inMatch=_slicedToArray(inMatch,3),LHS=_inMatch[1],RHS=_inMatch[2];var result={source:createAliasExpression(loc,RHS.trim(),exp.indexOf(RHS,LHS.length)),value:undefined,key:undefined,index:undefined};{validateBrowserExpression(result.source,context);}var valueContent=LHS.trim().replace(stripParensRE,'').trim();var trimmedOffset=LHS.indexOf(valueContent);var iteratorMatch=valueContent.match(forIteratorRE);if(iteratorMatch){valueContent=valueContent.replace(forIteratorRE,'').trim();var keyContent=iteratorMatch[1].trim();var keyOffset;if(keyContent){keyOffset=exp.indexOf(keyContent,trimmedOffset+valueContent.length);result.key=createAliasExpression(loc,keyContent,keyOffset);{validateBrowserExpression(result.key,context,true);}}if(iteratorMatch[2]){var indexContent=iteratorMatch[2].trim();if(indexContent){result.index=createAliasExpression(loc,indexContent,exp.indexOf(indexContent,result.key?keyOffset+keyContent.length:trimmedOffset+valueContent.length));{validateBrowserExpression(result.index,context,true);}}}}if(valueContent){result.value=createAliasExpression(loc,valueContent,trimmedOffset);{validateBrowserExpression(result.value,context,true);}}return result;}function createAliasExpression(range,content,offset){return createSimpleExpression(content,false,getInnerRange(range,offset,content.length));}function createForLoopParams(_ref53){var value=_ref53.value,key=_ref53.key,index=_ref53.index;var memoArgs=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];return createParamsList([value,key,index].concat(_toConsumableArray(memoArgs)));}function createParamsList(args){var i=args.length;while(i--){if(args[i])break;}return args.slice(0,i+1).map(function(arg,i){return arg||createSimpleExpression("_".repeat(i+1),false);});}var defaultFallback=createSimpleExpression("undefined",false);// A NodeTransform that:
// 1. Tracks scope identifiers for scoped slots so that they don't get prefixed
//    by transformExpression. This is only applied in non-browser builds with
//    { prefixIdentifiers: true }.
// 2. Track v-slot depths so that we know a slot is inside another slot.
//    Note the exit callback is executed before buildSlots() on the same node,
//    so only nested slots see positive numbers.
var trackSlotScopes=function trackSlotScopes(node,context){if(node.type===1/* ELEMENT */&&(node.tagType===1/* COMPONENT */||node.tagType===3/* TEMPLATE */)){// We are only checking non-empty v-slot here
// since we only care about slots that introduce scope variables.
var vSlot=findDir(node,'slot');if(vSlot){vSlot.exp;context.scopes.vSlot++;return function(){context.scopes.vSlot--;};}}};var buildClientSlotFn=function buildClientSlotFn(props,children,loc){return createFunctionExpression(props,children,false/* newline */,true/* isSlot */,children.length?children[0].loc:loc);};// Instead of being a DirectiveTransform, v-slot processing is called during
// transformElement to build the slots object for a component.
function buildSlots(node,context){var buildSlotFn=arguments.length>2&&arguments[2]!==undefined?arguments[2]:buildClientSlotFn;context.helper(WITH_CTX);var children=node.children,loc=node.loc;var slotsProperties=[];var dynamicSlots=[];// If the slot is inside a v-for or another v-slot, force it to be dynamic
// since it likely uses a scope variable.
var hasDynamicSlots=context.scopes.vSlot>0||context.scopes.vFor>0;// 1. Check for slot with slotProps on component itself.
//    <Comp v-slot="{ prop }"/>
var onComponentSlot=findDir(node,'slot',true);if(onComponentSlot){var arg=onComponentSlot.arg,exp=onComponentSlot.exp;if(arg&&!isStaticExp(arg)){hasDynamicSlots=true;}slotsProperties.push(createObjectProperty(arg||createSimpleExpression('default',true),buildSlotFn(exp,children,loc)));}// 2. Iterate through children and check for template slots
//    <template v-slot:foo="{ prop }">
var hasTemplateSlots=false;var hasNamedDefaultSlot=false;var implicitDefaultChildren=[];var seenSlotNames=new Set();for(var i=0;i<children.length;i++){var slotElement=children[i];var slotDir=void 0;if(!isTemplateNode(slotElement)||!(slotDir=findDir(slotElement,'slot',true))){// not a <template v-slot>, skip.
if(slotElement.type!==3/* COMMENT */){implicitDefaultChildren.push(slotElement);}continue;}if(onComponentSlot){// already has on-component slot - this is incorrect usage.
context.onError(createCompilerError(37/* X_V_SLOT_MIXED_SLOT_USAGE */,slotDir.loc));break;}hasTemplateSlots=true;var slotChildren=slotElement.children,slotLoc=slotElement.loc;var _slotDir=slotDir,_slotDir$arg=_slotDir.arg,slotName=_slotDir$arg===void 0?createSimpleExpression("default",true):_slotDir$arg,slotProps=_slotDir.exp,dirLoc=_slotDir.loc;// check if name is dynamic.
var staticSlotName=void 0;if(isStaticExp(slotName)){staticSlotName=slotName?slotName.content:"default";}else{hasDynamicSlots=true;}var slotFunction=buildSlotFn(slotProps,slotChildren,slotLoc);// check if this slot is conditional (v-if/v-for)
var vIf=void 0;var vElse=void 0;var vFor=void 0;if(vIf=findDir(slotElement,'if')){hasDynamicSlots=true;dynamicSlots.push(createConditionalExpression(vIf.exp,buildDynamicSlot(slotName,slotFunction),defaultFallback));}else if(vElse=findDir(slotElement,/^else(-if)?$/,true/* allowEmpty */)){// find adjacent v-if
var j=i;var prev=void 0;while(j--){prev=children[j];if(prev.type!==3/* COMMENT */){break;}}if(prev&&isTemplateNode(prev)&&findDir(prev,'if')){// remove node
children.splice(i,1);i--;// attach this slot to previous conditional
var conditional=dynamicSlots[dynamicSlots.length-1];while(conditional.alternate.type===19/* JS_CONDITIONAL_EXPRESSION */){conditional=conditional.alternate;}conditional.alternate=vElse.exp?createConditionalExpression(vElse.exp,buildDynamicSlot(slotName,slotFunction),defaultFallback):buildDynamicSlot(slotName,slotFunction);}else{context.onError(createCompilerError(30/* X_V_ELSE_NO_ADJACENT_IF */,vElse.loc));}}else if(vFor=findDir(slotElement,'for')){hasDynamicSlots=true;var parseResult=vFor.parseResult||parseForExpression(vFor.exp,context);if(parseResult){// Render the dynamic slots as an array and add it to the createSlot()
// args. The runtime knows how to handle it appropriately.
dynamicSlots.push(createCallExpression(context.helper(RENDER_LIST),[parseResult.source,createFunctionExpression(createForLoopParams(parseResult),buildDynamicSlot(slotName,slotFunction),true/* force newline */)]));}else{context.onError(createCompilerError(32/* X_V_FOR_MALFORMED_EXPRESSION */,vFor.loc));}}else{// check duplicate static names
if(staticSlotName){if(seenSlotNames.has(staticSlotName)){context.onError(createCompilerError(38/* X_V_SLOT_DUPLICATE_SLOT_NAMES */,dirLoc));continue;}seenSlotNames.add(staticSlotName);if(staticSlotName==='default'){hasNamedDefaultSlot=true;}}slotsProperties.push(createObjectProperty(slotName,slotFunction));}}if(!onComponentSlot){var buildDefaultSlotProperty=function buildDefaultSlotProperty(props,children){var fn=buildSlotFn(props,children,loc);return createObjectProperty("default",fn);};if(!hasTemplateSlots){// implicit default slot (on component)
slotsProperties.push(buildDefaultSlotProperty(undefined,children));}else if(implicitDefaultChildren.length&&// #3766
// with whitespace: 'preserve', whitespaces between slots will end up in
// implicitDefaultChildren. Ignore if all implicit children are whitespaces.
implicitDefaultChildren.some(function(node){return isNonWhitespaceContent(node);})){// implicit default slot (mixed with named slots)
if(hasNamedDefaultSlot){context.onError(createCompilerError(39/* X_V_SLOT_EXTRANEOUS_DEFAULT_SLOT_CHILDREN */,implicitDefaultChildren[0].loc));}else{slotsProperties.push(buildDefaultSlotProperty(undefined,implicitDefaultChildren));}}}var slotFlag=hasDynamicSlots?2/* DYNAMIC */:hasForwardedSlots(node.children)?3/* FORWARDED */:1/* STABLE */;var slots=createObjectExpression(slotsProperties.concat(createObjectProperty("_",// 2 = compiled but dynamic = can skip normalization, but must run diff
// 1 = compiled and static = can skip normalization AND diff as optimized
createSimpleExpression(slotFlag+" /* ".concat(slotFlagsText[slotFlag]," */"),false))),loc);if(dynamicSlots.length){slots=createCallExpression(context.helper(CREATE_SLOTS),[slots,createArrayExpression(dynamicSlots)]);}return{slots:slots,hasDynamicSlots:hasDynamicSlots};}function buildDynamicSlot(name,fn){return createObjectExpression([createObjectProperty("name",name),createObjectProperty("fn",fn)]);}function hasForwardedSlots(children){for(var i=0;i<children.length;i++){var child=children[i];switch(child.type){case 1/* ELEMENT */:if(child.tagType===2/* SLOT */||hasForwardedSlots(child.children)){return true;}break;case 9/* IF */:if(hasForwardedSlots(child.branches))return true;break;case 10/* IF_BRANCH */:case 11/* FOR */:if(hasForwardedSlots(child.children))return true;break;}}return false;}function isNonWhitespaceContent(node){if(node.type!==2/* TEXT */&&node.type!==12/* TEXT_CALL */)return true;return node.type===2/* TEXT */?!!node.content.trim():isNonWhitespaceContent(node.content);}// some directive transforms (e.g. v-model) may return a symbol for runtime
// import, which should be used instead of a resolveDirective call.
var directiveImportMap=new WeakMap();// generate a JavaScript AST for this element's codegen
var transformElement=function transformElement(node,context){// perform the work on exit, after all child expressions have been
// processed and merged.
return function postTransformElement(){node=context.currentNode;if(!(node.type===1/* ELEMENT */&&(node.tagType===0/* ELEMENT */||node.tagType===1/* COMPONENT */))){return;}var _node3=node,tag=_node3.tag,props=_node3.props;var isComponent=node.tagType===1/* COMPONENT */;// The goal of the transform is to create a codegenNode implementing the
// VNodeCall interface.
var vnodeTag=isComponent?resolveComponentType(node,context):"\"".concat(tag,"\"");var isDynamicComponent=isObject(vnodeTag)&&vnodeTag.callee===RESOLVE_DYNAMIC_COMPONENT;var vnodeProps;var vnodeChildren;var vnodePatchFlag;var patchFlag=0;var vnodeDynamicProps;var dynamicPropNames;var vnodeDirectives;var shouldUseBlock=// dynamic component may resolve to plain elements
isDynamicComponent||vnodeTag===TELEPORT||vnodeTag===SUSPENSE||!isComponent&&(// <svg> and <foreignObject> must be forced into blocks so that block
// updates inside get proper isSVG flag at runtime. (#639, #643)
// This is technically web-specific, but splitting the logic out of core
// leads to too much unnecessary complexity.
tag==='svg'||tag==='foreignObject');// props
if(props.length>0){var propsBuildResult=buildProps(node,context);vnodeProps=propsBuildResult.props;patchFlag=propsBuildResult.patchFlag;dynamicPropNames=propsBuildResult.dynamicPropNames;var directives=propsBuildResult.directives;vnodeDirectives=directives&&directives.length?createArrayExpression(directives.map(function(dir){return buildDirectiveArgs(dir,context);})):undefined;if(propsBuildResult.shouldUseBlock){shouldUseBlock=true;}}// children
if(node.children.length>0){if(vnodeTag===KEEP_ALIVE){// Although a built-in component, we compile KeepAlive with raw children
// instead of slot functions so that it can be used inside Transition
// or other Transition-wrapping HOCs.
// To ensure correct updates with block optimizations, we need to:
// 1. Force keep-alive into a block. This avoids its children being
//    collected by a parent block.
shouldUseBlock=true;// 2. Force keep-alive to always be updated, since it uses raw children.
patchFlag|=1024/* DYNAMIC_SLOTS */;if(node.children.length>1){context.onError(createCompilerError(45/* X_KEEP_ALIVE_INVALID_CHILDREN */,{start:node.children[0].loc.start,end:node.children[node.children.length-1].loc.end,source:''}));}}var shouldBuildAsSlots=isComponent&&// Teleport is not a real component and has dedicated runtime handling
vnodeTag!==TELEPORT&&// explained above.
vnodeTag!==KEEP_ALIVE;if(shouldBuildAsSlots){var _buildSlots=buildSlots(node,context),slots=_buildSlots.slots,hasDynamicSlots=_buildSlots.hasDynamicSlots;vnodeChildren=slots;if(hasDynamicSlots){patchFlag|=1024/* DYNAMIC_SLOTS */;}}else if(node.children.length===1&&vnodeTag!==TELEPORT){var child=node.children[0];var type=child.type;// check for dynamic text children
var hasDynamicTextChild=type===5/* INTERPOLATION */||type===8/* COMPOUND_EXPRESSION */;if(hasDynamicTextChild&&getConstantType(child,context)===0/* NOT_CONSTANT */){patchFlag|=1/* TEXT */;}// pass directly if the only child is a text node
// (plain / interpolation / expression)
if(hasDynamicTextChild||type===2/* TEXT */){vnodeChildren=child;}else{vnodeChildren=node.children;}}else{vnodeChildren=node.children;}}// patchFlag & dynamicPropNames
if(patchFlag!==0){{if(patchFlag<0){// special flags (negative and mutually exclusive)
vnodePatchFlag=patchFlag+" /* ".concat(PatchFlagNames[patchFlag]," */");}else{// bitwise flags
var flagNames=Object.keys(PatchFlagNames).map(Number).filter(function(n){return n>0&&patchFlag&n;}).map(function(n){return PatchFlagNames[n];}).join(", ");vnodePatchFlag=patchFlag+" /* ".concat(flagNames," */");}}if(dynamicPropNames&&dynamicPropNames.length){vnodeDynamicProps=stringifyDynamicPropNames(dynamicPropNames);}}node.codegenNode=createVNodeCall(context,vnodeTag,vnodeProps,vnodeChildren,vnodePatchFlag,vnodeDynamicProps,vnodeDirectives,!!shouldUseBlock,false/* disableTracking */,isComponent,node.loc);};};function resolveComponentType(node,context){var ssr=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var tag=node.tag;// 1. dynamic component
var isExplicitDynamic=isComponentTag(tag);var isProp=findProp(node,'is');if(isProp){if(isExplicitDynamic||false){var exp=isProp.type===6/* ATTRIBUTE */?isProp.value&&createSimpleExpression(isProp.value.content,true):isProp.exp;if(exp){return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT),[exp]);}}else if(isProp.type===6/* ATTRIBUTE */&&isProp.value.content.startsWith('vue:')){// <button is="vue:xxx">
// if not <component>, only is value that starts with "vue:" will be
// treated as component by the parse phase and reach here, unless it's
// compat mode where all is values are considered components
tag=isProp.value.content.slice(4);}}// 1.5 v-is (TODO: Deprecate)
var isDir=!isExplicitDynamic&&findDir(node,'is');if(isDir&&isDir.exp){return createCallExpression(context.helper(RESOLVE_DYNAMIC_COMPONENT),[isDir.exp]);}// 2. built-in components (Teleport, Transition, KeepAlive, Suspense...)
var builtIn=isCoreComponent(tag)||context.isBuiltInComponent(tag);if(builtIn){// built-ins are simply fallthroughs / have special handling during ssr
// so we don't need to import their runtime equivalents
if(!ssr)context.helper(builtIn);return builtIn;}// 5. user component (resolve)
context.helper(RESOLVE_COMPONENT);context.components.add(tag);return toValidAssetId(tag,"component");}function buildProps(node,context){var props=arguments.length>2&&arguments[2]!==undefined?arguments[2]:node.props;var ssr=arguments.length>3&&arguments[3]!==undefined?arguments[3]:false;var tag=node.tag,elementLoc=node.loc,children=node.children;var isComponent=node.tagType===1/* COMPONENT */;var properties=[];var mergeArgs=[];var runtimeDirectives=[];var hasChildren=children.length>0;var shouldUseBlock=false;// patchFlag analysis
var patchFlag=0;var hasRef=false;var hasClassBinding=false;var hasStyleBinding=false;var hasHydrationEventBinding=false;var hasDynamicKeys=false;var hasVnodeHook=false;var dynamicPropNames=[];var analyzePatchFlag=function analyzePatchFlag(_ref54){var key=_ref54.key,value=_ref54.value;if(isStaticExp(key)){var name=key.content;var isEventHandler=isOn(name);if(!isComponent&&isEventHandler&&// omit the flag for click handlers because hydration gives click
// dedicated fast path.
name.toLowerCase()!=='onclick'&&// omit v-model handlers
name!=='onUpdate:modelValue'&&// omit onVnodeXXX hooks
!isReservedProp(name)){hasHydrationEventBinding=true;}if(isEventHandler&&isReservedProp(name)){hasVnodeHook=true;}if(value.type===20/* JS_CACHE_EXPRESSION */||(value.type===4/* SIMPLE_EXPRESSION */||value.type===8/* COMPOUND_EXPRESSION */)&&getConstantType(value,context)>0){// skip if the prop is a cached handler or has constant value
return;}if(name==='ref'){hasRef=true;}else if(name==='class'){hasClassBinding=true;}else if(name==='style'){hasStyleBinding=true;}else if(name!=='key'&&!dynamicPropNames.includes(name)){dynamicPropNames.push(name);}// treat the dynamic class and style binding of the component as dynamic props
if(isComponent&&(name==='class'||name==='style')&&!dynamicPropNames.includes(name)){dynamicPropNames.push(name);}}else{hasDynamicKeys=true;}};for(var i=0;i<props.length;i++){// static attribute
var prop=props[i];if(prop.type===6/* ATTRIBUTE */){var loc=prop.loc,name=prop.name,value=prop.value;var isStatic=true;if(name==='ref'){hasRef=true;if(context.scopes.vFor>0){properties.push(createObjectProperty(createSimpleExpression('ref_for',true),createSimpleExpression('true')));}}// skip is on <component>, or is="vue:xxx"
if(name==='is'&&(isComponentTag(tag)||value&&value.content.startsWith('vue:')||false)){continue;}properties.push(createObjectProperty(createSimpleExpression(name,true,getInnerRange(loc,0,name.length)),createSimpleExpression(value?value.content:'',isStatic,value?value.loc:loc)));}else{// directives
var _name=prop.name,arg=prop.arg,exp=prop.exp,_loc2=prop.loc;var isVBind=_name==='bind';var isVOn=_name==='on';// skip v-slot - it is handled by its dedicated transform.
if(_name==='slot'){if(!isComponent){context.onError(createCompilerError(40/* X_V_SLOT_MISPLACED */,_loc2));}continue;}// skip v-once/v-memo - they are handled by dedicated transforms.
if(_name==='once'||_name==='memo'){continue;}// skip v-is and :is on <component>
if(_name==='is'||isVBind&&isStaticArgOf(arg,'is')&&(isComponentTag(tag)||false)){continue;}// skip v-on in SSR compilation
if(isVOn&&ssr){continue;}if(// #938: elements with dynamic keys should be forced into blocks
isVBind&&isStaticArgOf(arg,'key')||// inline before-update hooks need to force block so that it is invoked
// before children
isVOn&&hasChildren&&isStaticArgOf(arg,'vue:before-update')){shouldUseBlock=true;}if(isVBind&&isStaticArgOf(arg,'ref')&&context.scopes.vFor>0){properties.push(createObjectProperty(createSimpleExpression('ref_for',true),createSimpleExpression('true')));}// special case for v-bind and v-on with no argument
if(!arg&&(isVBind||isVOn)){hasDynamicKeys=true;if(exp){if(properties.length){mergeArgs.push(createObjectExpression(dedupeProperties(properties),elementLoc));properties=[];}if(isVBind){mergeArgs.push(exp);}else{// v-on="obj" -> toHandlers(obj)
mergeArgs.push({type:14/* JS_CALL_EXPRESSION */,loc:_loc2,callee:context.helper(TO_HANDLERS),arguments:[exp]});}}else{context.onError(createCompilerError(isVBind?34/* X_V_BIND_NO_EXPRESSION */:35/* X_V_ON_NO_EXPRESSION */,_loc2));}continue;}var directiveTransform=context.directiveTransforms[_name];if(directiveTransform){var _properties;// has built-in directive transform.
var _directiveTransform=directiveTransform(prop,node,context),_props3=_directiveTransform.props,needRuntime=_directiveTransform.needRuntime;!ssr&&_props3.forEach(analyzePatchFlag);(_properties=properties).push.apply(_properties,_toConsumableArray(_props3));if(needRuntime){runtimeDirectives.push(prop);if(isSymbol(needRuntime)){directiveImportMap.set(prop,needRuntime);}}}else if(!isBuiltInDirective(_name)){// no built-in transform, this is a user custom directive.
runtimeDirectives.push(prop);// custom dirs may use beforeUpdate so they need to force blocks
// to ensure before-update gets called before children update
if(hasChildren){shouldUseBlock=true;}}}}var propsExpression=undefined;// has v-bind="object" or v-on="object", wrap with mergeProps
if(mergeArgs.length){if(properties.length){mergeArgs.push(createObjectExpression(dedupeProperties(properties),elementLoc));}if(mergeArgs.length>1){propsExpression=createCallExpression(context.helper(MERGE_PROPS),mergeArgs,elementLoc);}else{// single v-bind with nothing else - no need for a mergeProps call
propsExpression=mergeArgs[0];}}else if(properties.length){propsExpression=createObjectExpression(dedupeProperties(properties),elementLoc);}// patchFlag analysis
if(hasDynamicKeys){patchFlag|=16/* FULL_PROPS */;}else{if(hasClassBinding&&!isComponent){patchFlag|=2/* CLASS */;}if(hasStyleBinding&&!isComponent){patchFlag|=4/* STYLE */;}if(dynamicPropNames.length){patchFlag|=8/* PROPS */;}if(hasHydrationEventBinding){patchFlag|=32/* HYDRATE_EVENTS */;}}if(!shouldUseBlock&&(patchFlag===0||patchFlag===32/* HYDRATE_EVENTS */)&&(hasRef||hasVnodeHook||runtimeDirectives.length>0)){patchFlag|=512/* NEED_PATCH */;}// pre-normalize props, SSR is skipped for now
if(!context.inSSR&&propsExpression){switch(propsExpression.type){case 15/* JS_OBJECT_EXPRESSION */:// means that there is no v-bind,
// but still need to deal with dynamic key binding
var classKeyIndex=-1;var styleKeyIndex=-1;var hasDynamicKey=false;for(var _i14=0;_i14<propsExpression.properties.length;_i14++){var key=propsExpression.properties[_i14].key;if(isStaticExp(key)){if(key.content==='class'){classKeyIndex=_i14;}else if(key.content==='style'){styleKeyIndex=_i14;}}else if(!key.isHandlerKey){hasDynamicKey=true;}}var classProp=propsExpression.properties[classKeyIndex];var styleProp=propsExpression.properties[styleKeyIndex];// no dynamic key
if(!hasDynamicKey){if(classProp&&!isStaticExp(classProp.value)){classProp.value=createCallExpression(context.helper(NORMALIZE_CLASS),[classProp.value]);}if(styleProp&&!isStaticExp(styleProp.value)&&(// the static style is compiled into an object,
// so use `hasStyleBinding` to ensure that it is a dynamic style binding
hasStyleBinding||// v-bind:style and style both exist,
// v-bind:style with static literal object
styleProp.value.type===17/* JS_ARRAY_EXPRESSION */)){styleProp.value=createCallExpression(context.helper(NORMALIZE_STYLE),[styleProp.value]);}}else{// dynamic key binding, wrap with `normalizeProps`
propsExpression=createCallExpression(context.helper(NORMALIZE_PROPS),[propsExpression]);}break;case 14/* JS_CALL_EXPRESSION */:// mergeProps call, do nothing
break;default:// single v-bind
propsExpression=createCallExpression(context.helper(NORMALIZE_PROPS),[createCallExpression(context.helper(GUARD_REACTIVE_PROPS),[propsExpression])]);break;}}return{props:propsExpression,directives:runtimeDirectives,patchFlag:patchFlag,dynamicPropNames:dynamicPropNames,shouldUseBlock:shouldUseBlock};}// Dedupe props in an object literal.
// Literal duplicated attributes would have been warned during the parse phase,
// however, it's possible to encounter duplicated `onXXX` handlers with different
// modifiers. We also need to merge static and dynamic class / style attributes.
// - onXXX handlers / style: merge into array
// - class: merge into single expression with concatenation
function dedupeProperties(properties){var knownProps=new Map();var deduped=[];for(var i=0;i<properties.length;i++){var prop=properties[i];// dynamic keys are always allowed
if(prop.key.type===8/* COMPOUND_EXPRESSION */||!prop.key.isStatic){deduped.push(prop);continue;}var name=prop.key.content;var existing=knownProps.get(name);if(existing){if(name==='style'||name==='class'||isOn(name)){mergeAsArray$1(existing,prop);}// unexpected duplicate, should have emitted error during parse
}else{knownProps.set(name,prop);deduped.push(prop);}}return deduped;}function mergeAsArray$1(existing,incoming){if(existing.value.type===17/* JS_ARRAY_EXPRESSION */){existing.value.elements.push(incoming.value);}else{existing.value=createArrayExpression([existing.value,incoming.value],existing.loc);}}function buildDirectiveArgs(dir,context){var dirArgs=[];var runtime=directiveImportMap.get(dir);if(runtime){// built-in directive with runtime
dirArgs.push(context.helperString(runtime));}else{{// inject statement for resolving directive
context.helper(RESOLVE_DIRECTIVE);context.directives.add(dir.name);dirArgs.push(toValidAssetId(dir.name,"directive"));}}var loc=dir.loc;if(dir.exp)dirArgs.push(dir.exp);if(dir.arg){if(!dir.exp){dirArgs.push("void 0");}dirArgs.push(dir.arg);}if(Object.keys(dir.modifiers).length){if(!dir.arg){if(!dir.exp){dirArgs.push("void 0");}dirArgs.push("void 0");}var trueExpression=createSimpleExpression("true",false,loc);dirArgs.push(createObjectExpression(dir.modifiers.map(function(modifier){return createObjectProperty(modifier,trueExpression);}),loc));}return createArrayExpression(dirArgs,dir.loc);}function stringifyDynamicPropNames(props){var propsNamesString="[";for(var i=0,l=props.length;i<l;i++){propsNamesString+=JSON.stringify(props[i]);if(i<l-1)propsNamesString+=', ';}return propsNamesString+"]";}function isComponentTag(tag){return tag==='component'||tag==='Component';}var transformSlotOutlet=function transformSlotOutlet(node,context){if(isSlotOutlet(node)){var children=node.children,loc=node.loc;var _processSlotOutlet=processSlotOutlet(node,context),slotName=_processSlotOutlet.slotName,slotProps=_processSlotOutlet.slotProps;var slotArgs=[context.prefixIdentifiers?"_ctx.$slots":"$slots",slotName,'{}','undefined','true'];var expectedLen=2;if(slotProps){slotArgs[2]=slotProps;expectedLen=3;}if(children.length){slotArgs[3]=createFunctionExpression([],children,false,false,loc);expectedLen=4;}if(context.scopeId&&!context.slotted){expectedLen=5;}slotArgs.splice(expectedLen);// remove unused arguments
node.codegenNode=createCallExpression(context.helper(RENDER_SLOT),slotArgs,loc);}};function processSlotOutlet(node,context){var slotName="\"default\"";var slotProps=undefined;var nonNameProps=[];for(var i=0;i<node.props.length;i++){var _p5=node.props[i];if(_p5.type===6/* ATTRIBUTE */){if(_p5.value){if(_p5.name==='name'){slotName=JSON.stringify(_p5.value.content);}else{_p5.name=camelize(_p5.name);nonNameProps.push(_p5);}}}else{if(_p5.name==='bind'&&isStaticArgOf(_p5.arg,'name')){if(_p5.exp)slotName=_p5.exp;}else{if(_p5.name==='bind'&&_p5.arg&&isStaticExp(_p5.arg)){_p5.arg.content=camelize(_p5.arg.content);}nonNameProps.push(_p5);}}}if(nonNameProps.length>0){var _buildProps=buildProps(node,context,nonNameProps),props=_buildProps.props,directives=_buildProps.directives;slotProps=props;if(directives.length){context.onError(createCompilerError(36/* X_V_SLOT_UNEXPECTED_DIRECTIVE_ON_SLOT_OUTLET */,directives[0].loc));}}return{slotName:slotName,slotProps:slotProps};}var fnExpRE=/^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/;var transformOn=function transformOn(dir,node,context,augmentor){var loc=dir.loc,modifiers=dir.modifiers,arg=dir.arg;if(!dir.exp&&!modifiers.length){context.onError(createCompilerError(35/* X_V_ON_NO_EXPRESSION */,loc));}var eventName;if(arg.type===4/* SIMPLE_EXPRESSION */){if(arg.isStatic){var rawName=arg.content;// TODO deprecate @vnodeXXX usage
if(rawName.startsWith('vue:')){rawName="vnode-".concat(rawName.slice(4));}// for all event listeners, auto convert it to camelCase. See issue #2249
eventName=createSimpleExpression(toHandlerKey(camelize(rawName)),true,arg.loc);}else{// #2388
eventName=createCompoundExpression(["".concat(context.helperString(TO_HANDLER_KEY),"("),arg,")"]);}}else{// already a compound expression.
eventName=arg;eventName.children.unshift("".concat(context.helperString(TO_HANDLER_KEY),"("));eventName.children.push(")");}// handler processing
var exp=dir.exp;if(exp&&!exp.content.trim()){exp=undefined;}var shouldCache=context.cacheHandlers&&!exp&&!context.inVOnce;if(exp){var isMemberExp=isMemberExpression(exp.content);var isInlineStatement=!(isMemberExp||fnExpRE.test(exp.content));var hasMultipleStatements=exp.content.includes(";");{validateBrowserExpression(exp,context,false,hasMultipleStatements);}if(isInlineStatement||shouldCache&&isMemberExp){// wrap inline statement in a function expression
exp=createCompoundExpression(["".concat(isInlineStatement?"$event":"".concat("","(...args)")," => ").concat(hasMultipleStatements?"{":"("),exp,hasMultipleStatements?"}":")"]);}}var ret={props:[createObjectProperty(eventName,exp||createSimpleExpression("() => {}",false,loc))]};// apply extended compiler augmentor
if(augmentor){ret=augmentor(ret);}if(shouldCache){// cache handlers so that it's always the same handler being passed down.
// this avoids unnecessary re-renders when users use inline handlers on
// components.
ret.props[0].value=context.cache(ret.props[0].value);}// mark the key as handler for props normalization check
ret.props.forEach(function(p){return p.key.isHandlerKey=true;});return ret;};// v-bind without arg is handled directly in ./transformElements.ts due to it affecting
// codegen for the entire props object. This transform here is only for v-bind
// *with* args.
var transformBind=function transformBind(dir,_node,context){var exp=dir.exp,modifiers=dir.modifiers,loc=dir.loc;var arg=dir.arg;if(arg.type!==4/* SIMPLE_EXPRESSION */){arg.children.unshift("(");arg.children.push(") || \"\"");}else if(!arg.isStatic){arg.content="".concat(arg.content," || \"\"");}// .sync is replaced by v-model:arg
if(modifiers.includes('camel')){if(arg.type===4/* SIMPLE_EXPRESSION */){if(arg.isStatic){arg.content=camelize(arg.content);}else{arg.content="".concat(context.helperString(CAMELIZE),"(").concat(arg.content,")");}}else{arg.children.unshift("".concat(context.helperString(CAMELIZE),"("));arg.children.push(")");}}if(!context.inSSR){if(modifiers.includes('prop')){injectPrefix(arg,'.');}if(modifiers.includes('attr')){injectPrefix(arg,'^');}}if(!exp||exp.type===4/* SIMPLE_EXPRESSION */&&!exp.content.trim()){context.onError(createCompilerError(34/* X_V_BIND_NO_EXPRESSION */,loc));return{props:[createObjectProperty(arg,createSimpleExpression('',true,loc))]};}return{props:[createObjectProperty(arg,exp)]};};var injectPrefix=function injectPrefix(arg,prefix){if(arg.type===4/* SIMPLE_EXPRESSION */){if(arg.isStatic){arg.content=prefix+arg.content;}else{arg.content="`".concat(prefix,"${").concat(arg.content,"}`");}}else{arg.children.unshift("'".concat(prefix,"' + ("));arg.children.push(")");}};// Merge adjacent text nodes and expressions into a single expression
// e.g. <div>abc {{ d }} {{ e }}</div> should have a single expression node as child.
var transformText=function transformText(node,context){if(node.type===0/* ROOT */||node.type===1/* ELEMENT */||node.type===11/* FOR */||node.type===10/* IF_BRANCH */){// perform the transform on node exit so that all expressions have already
// been processed.
return function(){var children=node.children;var currentContainer=undefined;var hasText=false;for(var i=0;i<children.length;i++){var child=children[i];if(isText(child)){hasText=true;for(var j=i+1;j<children.length;j++){var next=children[j];if(isText(next)){if(!currentContainer){currentContainer=children[i]={type:8/* COMPOUND_EXPRESSION */,loc:child.loc,children:[child]};}// merge adjacent text node into current
currentContainer.children.push(" + ",next);children.splice(j,1);j--;}else{currentContainer=undefined;break;}}}}if(!hasText||// if this is a plain element with a single text child, leave it
// as-is since the runtime has dedicated fast path for this by directly
// setting textContent of the element.
// for component root it's always normalized anyway.
children.length===1&&(node.type===0/* ROOT */||node.type===1/* ELEMENT */&&node.tagType===0/* ELEMENT */&&// #3756
// custom directives can potentially add DOM elements arbitrarily,
// we need to avoid setting textContent of the element at runtime
// to avoid accidentally overwriting the DOM elements added
// by the user through custom directives.
!node.props.find(function(p){return p.type===7/* DIRECTIVE */&&!context.directiveTransforms[p.name];})&&// in compat mode, <template> tags with no special directives
// will be rendered as a fragment so its children must be
// converted into vnodes.
!false)){return;}// pre-convert text nodes into createTextVNode(text) calls to avoid
// runtime normalization.
for(var _i15=0;_i15<children.length;_i15++){var _child2=children[_i15];if(isText(_child2)||_child2.type===8/* COMPOUND_EXPRESSION */){var callArgs=[];// createTextVNode defaults to single whitespace, so if it is a
// single space the code could be an empty call to save bytes.
if(_child2.type!==2/* TEXT */||_child2.content!==' '){callArgs.push(_child2);}// mark dynamic text with flag so it gets patched inside a block
if(!context.ssr&&getConstantType(_child2,context)===0/* NOT_CONSTANT */){callArgs.push(1/* TEXT */+" /* ".concat(PatchFlagNames[1/* TEXT */]," */"));}children[_i15]={type:12/* TEXT_CALL */,content:_child2,loc:_child2.loc,codegenNode:createCallExpression(context.helper(CREATE_TEXT),callArgs)};}}};}};var seen=new WeakSet();var transformOnce=function transformOnce(node,context){if(node.type===1/* ELEMENT */&&findDir(node,'once',true)){if(seen.has(node)||context.inVOnce){return;}seen.add(node);context.inVOnce=true;context.helper(SET_BLOCK_TRACKING);return function(){context.inVOnce=false;var cur=context.currentNode;if(cur.codegenNode){cur.codegenNode=context.cache(cur.codegenNode,true/* isVNode */);}};}};var transformModel=function transformModel(dir,node,context){var exp=dir.exp,arg=dir.arg;if(!exp){context.onError(createCompilerError(41/* X_V_MODEL_NO_EXPRESSION */,dir.loc));return createTransformProps();}var rawExp=exp.loc.source;var expString=exp.type===4/* SIMPLE_EXPRESSION */?exp.content:rawExp;// im SFC <script setup> inline mode, the exp may have been transformed into
// _unref(exp)
context.bindingMetadata[rawExp];var maybeRef=!true/* SETUP_CONST */;if(!expString.trim()||!isMemberExpression(expString)&&!maybeRef){context.onError(createCompilerError(42/* X_V_MODEL_MALFORMED_EXPRESSION */,exp.loc));return createTransformProps();}var propName=arg?arg:createSimpleExpression('modelValue',true);var eventName=arg?isStaticExp(arg)?"onUpdate:".concat(arg.content):createCompoundExpression(['"onUpdate:" + ',arg]):"onUpdate:modelValue";var assignmentExp;var eventArg=context.isTS?"($event: any)":"$event";{assignmentExp=createCompoundExpression(["".concat(eventArg," => (("),exp,") = $event)"]);}var props=[// modelValue: foo
createObjectProperty(propName,dir.exp),// "onUpdate:modelValue": $event => (foo = $event)
createObjectProperty(eventName,assignmentExp)];// modelModifiers: { foo: true, "bar-baz": true }
if(dir.modifiers.length&&node.tagType===1/* COMPONENT */){var modifiers=dir.modifiers.map(function(m){return(isSimpleIdentifier(m)?m:JSON.stringify(m))+": true";}).join(", ");var modifiersKey=arg?isStaticExp(arg)?"".concat(arg.content,"Modifiers"):createCompoundExpression([arg,' + "Modifiers"']):"modelModifiers";props.push(createObjectProperty(modifiersKey,createSimpleExpression("{ ".concat(modifiers," }"),false,dir.loc,2/* CAN_HOIST */)));}return createTransformProps(props);};function createTransformProps(){var props=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];return{props:props};}var seen$1=new WeakSet();var transformMemo=function transformMemo(node,context){if(node.type===1/* ELEMENT */){var dir=findDir(node,'memo');if(!dir||seen$1.has(node)){return;}seen$1.add(node);return function(){var codegenNode=node.codegenNode||context.currentNode.codegenNode;if(codegenNode&&codegenNode.type===13/* VNODE_CALL */){// non-component sub tree should be turned into a block
if(node.tagType!==1/* COMPONENT */){makeBlock(codegenNode,context);}node.codegenNode=createCallExpression(context.helper(WITH_MEMO),[dir.exp,createFunctionExpression(undefined,codegenNode),"_cache",String(context.cached++)]);}};}};function getBaseTransformPreset(prefixIdentifiers){return[[transformOnce,transformIf,transformMemo,transformFor].concat([],[transformExpression],[transformSlotOutlet,transformElement,trackSlotScopes,transformText]),{on:transformOn,bind:transformBind,model:transformModel}];}// we name it `baseCompile` so that higher order compilers like
// @vue/compiler-dom can export `compile` while re-exporting everything else.
function baseCompile(template){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var onError=options.onError||defaultOnError;var isModuleMode=options.mode==='module';/* istanbul ignore if */{if(options.prefixIdentifiers===true){onError(createCompilerError(46/* X_PREFIX_ID_NOT_SUPPORTED */));}else if(isModuleMode){onError(createCompilerError(47/* X_MODULE_MODE_NOT_SUPPORTED */));}}var prefixIdentifiers=!true;if(options.cacheHandlers){onError(createCompilerError(48/* X_CACHE_HANDLER_NOT_SUPPORTED */));}if(options.scopeId&&!isModuleMode){onError(createCompilerError(49/* X_SCOPE_ID_NOT_SUPPORTED */));}var ast=isString(template)?baseParse(template,options):template;var _getBaseTransformPres=getBaseTransformPreset(),_getBaseTransformPres2=_slicedToArray(_getBaseTransformPres,2),nodeTransforms=_getBaseTransformPres2[0],directiveTransforms=_getBaseTransformPres2[1];transform(ast,extend({},options,{prefixIdentifiers:prefixIdentifiers,nodeTransforms:[].concat(_toConsumableArray(nodeTransforms),_toConsumableArray(options.nodeTransforms||[])),directiveTransforms:extend({},directiveTransforms,options.directiveTransforms||{}// user transforms
)}));return generate(ast,extend({},options,{prefixIdentifiers:prefixIdentifiers}));}var noopDirectiveTransform=function noopDirectiveTransform(){return{props:[]};};var V_MODEL_RADIO=Symbol("vModelRadio");var V_MODEL_CHECKBOX=Symbol("vModelCheckbox");var V_MODEL_TEXT=Symbol("vModelText");var V_MODEL_SELECT=Symbol("vModelSelect");var V_MODEL_DYNAMIC=Symbol("vModelDynamic");var V_ON_WITH_MODIFIERS=Symbol("vOnModifiersGuard");var V_ON_WITH_KEYS=Symbol("vOnKeysGuard");var V_SHOW=Symbol("vShow");var TRANSITION$1=Symbol("Transition");var TRANSITION_GROUP=Symbol("TransitionGroup");registerRuntimeHelpers((_registerRuntimeHelpe={},_defineProperty(_registerRuntimeHelpe,V_MODEL_RADIO,"vModelRadio"),_defineProperty(_registerRuntimeHelpe,V_MODEL_CHECKBOX,"vModelCheckbox"),_defineProperty(_registerRuntimeHelpe,V_MODEL_TEXT,"vModelText"),_defineProperty(_registerRuntimeHelpe,V_MODEL_SELECT,"vModelSelect"),_defineProperty(_registerRuntimeHelpe,V_MODEL_DYNAMIC,"vModelDynamic"),_defineProperty(_registerRuntimeHelpe,V_ON_WITH_MODIFIERS,"withModifiers"),_defineProperty(_registerRuntimeHelpe,V_ON_WITH_KEYS,"withKeys"),_defineProperty(_registerRuntimeHelpe,V_SHOW,"vShow"),_defineProperty(_registerRuntimeHelpe,TRANSITION$1,"Transition"),_defineProperty(_registerRuntimeHelpe,TRANSITION_GROUP,"TransitionGroup"),_registerRuntimeHelpe));/* eslint-disable no-restricted-globals */var decoder;function decodeHtmlBrowser(raw){var asAttr=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(!decoder){decoder=document.createElement('div');}if(asAttr){decoder.innerHTML="<div foo=\"".concat(raw.replace(/"/g,'&quot;'),"\">");return decoder.children[0].getAttribute('foo');}else{decoder.innerHTML=raw;return decoder.textContent;}}var isRawTextContainer=/*#__PURE__*/makeMap('style,iframe,script,noscript',true);var parserOptions={isVoidTag:isVoidTag,isNativeTag:function isNativeTag(tag){return isHTMLTag(tag)||isSVGTag(tag);},isPreTag:function isPreTag(tag){return tag==='pre';},decodeEntities:decodeHtmlBrowser,isBuiltInComponent:function isBuiltInComponent(tag){if(isBuiltInType(tag,"Transition")){return TRANSITION$1;}else if(isBuiltInType(tag,"TransitionGroup")){return TRANSITION_GROUP;}},// https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
getNamespace:function getNamespace(tag,parent){var ns=parent?parent.ns:0/* HTML */;if(parent&&ns===2/* MATH_ML */){if(parent.tag==='annotation-xml'){if(tag==='svg'){return 1/* SVG */;}if(parent.props.some(function(a){return a.type===6/* ATTRIBUTE */&&a.name==='encoding'&&a.value!=null&&(a.value.content==='text/html'||a.value.content==='application/xhtml+xml');})){ns=0/* HTML */;}}else if(/^m(?:[ions]|text)$/.test(parent.tag)&&tag!=='mglyph'&&tag!=='malignmark'){ns=0/* HTML */;}}else if(parent&&ns===1/* SVG */){if(parent.tag==='foreignObject'||parent.tag==='desc'||parent.tag==='title'){ns=0/* HTML */;}}if(ns===0/* HTML */){if(tag==='svg'){return 1/* SVG */;}if(tag==='math'){return 2/* MATH_ML */;}}return ns;},// https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
getTextMode:function getTextMode(_ref55){var tag=_ref55.tag,ns=_ref55.ns;if(ns===0/* HTML */){if(tag==='textarea'||tag==='title'){return 1/* RCDATA */;}if(isRawTextContainer(tag)){return 2/* RAWTEXT */;}}return 0/* DATA */;}};// Parse inline CSS strings for static style attributes into an object.
// This is a NodeTransform since it works on the static `style` attribute and
// converts it into a dynamic equivalent:
// style="color: red" -> :style='{ "color": "red" }'
// It is then processed by `transformElement` and included in the generated
// props.
var transformStyle=function transformStyle(node){if(node.type===1/* ELEMENT */){node.props.forEach(function(p,i){if(p.type===6/* ATTRIBUTE */&&p.name==='style'&&p.value){// replace p with an expression node
node.props[i]={type:7/* DIRECTIVE */,name:"bind",arg:createSimpleExpression("style",true,p.loc),exp:parseInlineCSS(p.value.content,p.loc),modifiers:[],loc:p.loc};}});}};var parseInlineCSS=function parseInlineCSS(cssText,loc){var normalized=parseStringStyle(cssText);return createSimpleExpression(JSON.stringify(normalized),false,loc,3/* CAN_STRINGIFY */);};function createDOMCompilerError(code,loc){return createCompilerError(code,loc,DOMErrorMessages);}var DOMErrorMessages=(_DOMErrorMessages={},_defineProperty(_DOMErrorMessages,50/* X_V_HTML_NO_EXPRESSION */,"v-html is missing expression."),_defineProperty(_DOMErrorMessages,51/* X_V_HTML_WITH_CHILDREN */,"v-html will override element children."),_defineProperty(_DOMErrorMessages,52/* X_V_TEXT_NO_EXPRESSION */,"v-text is missing expression."),_defineProperty(_DOMErrorMessages,53/* X_V_TEXT_WITH_CHILDREN */,"v-text will override element children."),_defineProperty(_DOMErrorMessages,54/* X_V_MODEL_ON_INVALID_ELEMENT */,"v-model can only be used on <input>, <textarea> and <select> elements."),_defineProperty(_DOMErrorMessages,55/* X_V_MODEL_ARG_ON_ELEMENT */,"v-model argument is not supported on plain elements."),_defineProperty(_DOMErrorMessages,56/* X_V_MODEL_ON_FILE_INPUT_ELEMENT */,"v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead."),_defineProperty(_DOMErrorMessages,57/* X_V_MODEL_UNNECESSARY_VALUE */,"Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior."),_defineProperty(_DOMErrorMessages,58/* X_V_SHOW_NO_EXPRESSION */,"v-show is missing expression."),_defineProperty(_DOMErrorMessages,59/* X_TRANSITION_INVALID_CHILDREN */,"<Transition> expects exactly one child element or component."),_defineProperty(_DOMErrorMessages,60/* X_IGNORED_SIDE_EFFECT_TAG */,"Tags with side effect (<script> and <style>) are ignored in client component templates."),_DOMErrorMessages);var transformVHtml=function transformVHtml(dir,node,context){var exp=dir.exp,loc=dir.loc;if(!exp){context.onError(createDOMCompilerError(50/* X_V_HTML_NO_EXPRESSION */,loc));}if(node.children.length){context.onError(createDOMCompilerError(51/* X_V_HTML_WITH_CHILDREN */,loc));node.children.length=0;}return{props:[createObjectProperty(createSimpleExpression("innerHTML",true,loc),exp||createSimpleExpression('',true))]};};var transformVText=function transformVText(dir,node,context){var exp=dir.exp,loc=dir.loc;if(!exp){context.onError(createDOMCompilerError(52/* X_V_TEXT_NO_EXPRESSION */,loc));}if(node.children.length){context.onError(createDOMCompilerError(53/* X_V_TEXT_WITH_CHILDREN */,loc));node.children.length=0;}return{props:[createObjectProperty(createSimpleExpression("textContent",true),exp?createCallExpression(context.helperString(TO_DISPLAY_STRING),[exp],loc):createSimpleExpression('',true))]};};var transformModel$1=function transformModel$1(dir,node,context){var baseResult=transformModel(dir,node,context);// base transform has errors OR component v-model (only need props)
if(!baseResult.props.length||node.tagType===1/* COMPONENT */){return baseResult;}if(dir.arg){context.onError(createDOMCompilerError(55/* X_V_MODEL_ARG_ON_ELEMENT */,dir.arg.loc));}function checkDuplicatedValue(){var value=findProp(node,'value');if(value){context.onError(createDOMCompilerError(57/* X_V_MODEL_UNNECESSARY_VALUE */,value.loc));}}var tag=node.tag;var isCustomElement=context.isCustomElement(tag);if(tag==='input'||tag==='textarea'||tag==='select'||isCustomElement){var directiveToUse=V_MODEL_TEXT;var isInvalidType=false;if(tag==='input'||isCustomElement){var type=findProp(node,"type");if(type){if(type.type===7/* DIRECTIVE */){// :type="foo"
directiveToUse=V_MODEL_DYNAMIC;}else if(type.value){switch(type.value.content){case'radio':directiveToUse=V_MODEL_RADIO;break;case'checkbox':directiveToUse=V_MODEL_CHECKBOX;break;case'file':isInvalidType=true;context.onError(createDOMCompilerError(56/* X_V_MODEL_ON_FILE_INPUT_ELEMENT */,dir.loc));break;default:// text type
checkDuplicatedValue();break;}}}else if(hasDynamicKeyVBind(node)){// element has bindings with dynamic keys, which can possibly contain
// "type".
directiveToUse=V_MODEL_DYNAMIC;}else{// text type
checkDuplicatedValue();}}else if(tag==='select'){directiveToUse=V_MODEL_SELECT;}else{// textarea
checkDuplicatedValue();}// inject runtime directive
// by returning the helper symbol via needRuntime
// the import will replaced a resolveDirective call.
if(!isInvalidType){baseResult.needRuntime=context.helper(directiveToUse);}}else{context.onError(createDOMCompilerError(54/* X_V_MODEL_ON_INVALID_ELEMENT */,dir.loc));}// native vmodel doesn't need the `modelValue` props since they are also
// passed to the runtime as `binding.value`. removing it reduces code size.
baseResult.props=baseResult.props.filter(function(p){return!(p.key.type===4/* SIMPLE_EXPRESSION */&&p.key.content==='modelValue');});return baseResult;};var isEventOptionModifier=/*#__PURE__*/makeMap("passive,once,capture");var isNonKeyModifier=/*#__PURE__*/makeMap(// event propagation management
"stop,prevent,self,"+// system modifiers + exact
"ctrl,shift,alt,meta,exact,"+// mouse
"middle");// left & right could be mouse or key modifiers based on event type
var maybeKeyModifier=/*#__PURE__*/makeMap('left,right');var isKeyboardEvent=/*#__PURE__*/makeMap("onkeyup,onkeydown,onkeypress",true);var resolveModifiers=function resolveModifiers(key,modifiers,context,loc){var keyModifiers=[];var nonKeyModifiers=[];var eventOptionModifiers=[];for(var i=0;i<modifiers.length;i++){var modifier=modifiers[i];if(isEventOptionModifier(modifier)){// eventOptionModifiers: modifiers for addEventListener() options,
// e.g. .passive & .capture
eventOptionModifiers.push(modifier);}else{// runtimeModifiers: modifiers that needs runtime guards
if(maybeKeyModifier(modifier)){if(isStaticExp(key)){if(isKeyboardEvent(key.content)){keyModifiers.push(modifier);}else{nonKeyModifiers.push(modifier);}}else{keyModifiers.push(modifier);nonKeyModifiers.push(modifier);}}else{if(isNonKeyModifier(modifier)){nonKeyModifiers.push(modifier);}else{keyModifiers.push(modifier);}}}}return{keyModifiers:keyModifiers,nonKeyModifiers:nonKeyModifiers,eventOptionModifiers:eventOptionModifiers};};var transformClick=function transformClick(key,event){var isStaticClick=isStaticExp(key)&&key.content.toLowerCase()==='onclick';return isStaticClick?createSimpleExpression(event,true):key.type!==4/* SIMPLE_EXPRESSION */?createCompoundExpression(["(",key,") === \"onClick\" ? \"".concat(event,"\" : ("),key,")"]):key;};var transformOn$1=function transformOn$1(dir,node,context){return transformOn(dir,node,context,function(baseResult){var modifiers=dir.modifiers;if(!modifiers.length)return baseResult;var _baseResult$props$=baseResult.props[0],key=_baseResult$props$.key,handlerExp=_baseResult$props$.value;var _resolveModifiers=resolveModifiers(key,modifiers,context,dir.loc),keyModifiers=_resolveModifiers.keyModifiers,nonKeyModifiers=_resolveModifiers.nonKeyModifiers,eventOptionModifiers=_resolveModifiers.eventOptionModifiers;// normalize click.right and click.middle since they don't actually fire
if(nonKeyModifiers.includes('right')){key=transformClick(key,"onContextmenu");}if(nonKeyModifiers.includes('middle')){key=transformClick(key,"onMouseup");}if(nonKeyModifiers.length){handlerExp=createCallExpression(context.helper(V_ON_WITH_MODIFIERS),[handlerExp,JSON.stringify(nonKeyModifiers)]);}if(keyModifiers.length&&(// if event name is dynamic, always wrap with keys guard
!isStaticExp(key)||isKeyboardEvent(key.content))){handlerExp=createCallExpression(context.helper(V_ON_WITH_KEYS),[handlerExp,JSON.stringify(keyModifiers)]);}if(eventOptionModifiers.length){var modifierPostfix=eventOptionModifiers.map(capitalize).join('');key=isStaticExp(key)?createSimpleExpression("".concat(key.content).concat(modifierPostfix),true):createCompoundExpression(["(",key,") + \"".concat(modifierPostfix,"\"")]);}return{props:[createObjectProperty(key,handlerExp)]};});};var transformShow=function transformShow(dir,node,context){var exp=dir.exp,loc=dir.loc;if(!exp){context.onError(createDOMCompilerError(58/* X_V_SHOW_NO_EXPRESSION */,loc));}return{props:[],needRuntime:context.helper(V_SHOW)};};var warnTransitionChildren=function warnTransitionChildren(node,context){if(node.type===1/* ELEMENT */&&node.tagType===1/* COMPONENT */){var component=context.isBuiltInComponent(node.tag);if(component===TRANSITION$1){return function(){if(node.children.length&&hasMultipleChildren(node)){context.onError(createDOMCompilerError(59/* X_TRANSITION_INVALID_CHILDREN */,{start:node.children[0].loc.start,end:node.children[node.children.length-1].loc.end,source:''}));}};}}};function hasMultipleChildren(node){// #1352 filter out potential comment nodes.
var children=node.children=node.children.filter(function(c){return c.type!==3/* COMMENT */&&!(c.type===2/* TEXT */&&!c.content.trim());});var child=children[0];return children.length!==1||child.type===11/* FOR */||child.type===9/* IF */&&child.branches.some(hasMultipleChildren);}var ignoreSideEffectTags=function ignoreSideEffectTags(node,context){if(node.type===1/* ELEMENT */&&node.tagType===0/* ELEMENT */&&(node.tag==='script'||node.tag==='style')){context.onError(createDOMCompilerError(60/* X_IGNORED_SIDE_EFFECT_TAG */,node.loc));context.removeNode();}};var DOMNodeTransforms=[transformStyle].concat([warnTransitionChildren]);var DOMDirectiveTransforms={cloak:noopDirectiveTransform,html:transformVHtml,text:transformVText,model:transformModel$1,on:transformOn$1,show:transformShow};function compile$1(template){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};return baseCompile(template,extend({},parserOptions,options,{nodeTransforms:[// ignore <script> and <tag>
// this is not put inside DOMNodeTransforms because that list is used
// by compiler-ssr to generate vnode fallback branches
ignoreSideEffectTags].concat(_toConsumableArray(DOMNodeTransforms),_toConsumableArray(options.nodeTransforms||[])),directiveTransforms:extend({},DOMDirectiveTransforms,options.directiveTransforms||{}),transformHoist:null}));}// This entry is the "full-build" that includes both the runtime
{initDev();}var compileCache=Object.create(null);function compileToFunction(template,options){if(!isString(template)){if(template.nodeType){template=template.innerHTML;}else{warn$1("invalid template option: ",template);return NOOP;}}var key=template;var cached=compileCache[key];if(cached){return cached;}if(template[0]==='#'){var el=document.querySelector(template);if(!el){warn$1("Template element not found or is empty: ".concat(template));}// __UNSAFE__
// Reason: potential execution of JS expressions in in-DOM template.
// The user must make sure the in-DOM template is trusted. If it's rendered
// by the server, the template should not contain any user data.
template=el?el.innerHTML:"";}var _compile$=compile$1(template,extend({hoistStatic:true,onError:onError,onWarn:function onWarn(e){return onError(e,true);}},options)),code=_compile$.code;function onError(err){var asWarning=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var message=asWarning?err.message:"Template compilation error: ".concat(err.message);var codeFrame=err.loc&&generateCodeFrame(template,err.loc.start.offset,err.loc.end.offset);warn$1(codeFrame?"".concat(message,"\n").concat(codeFrame):message);}// The wildcard import results in a huge object with every export
// with keys that cannot be mangled, and can be quite heavy size-wise.
// In the global build we know `Vue` is available globally so we can avoid
// the wildcard object.
var render=new Function('Vue',code)(runtimeDom);render._rc=true;return compileCache[key]=render;}registerRuntimeCompiler(compileToFunction);

/***/ }),

/***/ "./src/sass/main.sass":
/*!****************************!*\
  !*** ./src/sass/main.sass ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./node_modules/ts-loader/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[11].use[0]!./src/ts/vue/app.vue?vue&type=script&lang=ts":
/*!********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/ts-loader/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[11].use[0]!./src/ts/vue/app.vue?vue&type=script&lang=ts ***!
  \********************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-browser.js");

/* harmony default export */ __webpack_exports__["default"] = ((0,vue__WEBPACK_IMPORTED_MODULE_0__.defineComponent)({
    setup: function () {
        var data = (0,vue__WEBPACK_IMPORTED_MODULE_0__.reactive)({ message: 'Vue.js is ready use TypeScript' });
        var showMessage = function () {
            console.log(data.message);
        };
        (0,vue__WEBPACK_IMPORTED_MODULE_0__.onMounted)(function () {
            showMessage();
        });
    }
}));


/***/ }),

/***/ "./src/ts/modules/checking-browser.ts":
/*!********************************************!*\
  !*** ./src/ts/modules/checking-browser.ts ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FindBrowser": function() { return /* binding */ FindBrowser; }
/* harmony export */ });

function FindBrowser() {
    var currentUserAgent = window.navigator.userAgent.toLowerCase();
    if (currentUserAgent.indexOf('msie') !== -1 || currentUserAgent.indexOf('trident') !== -1) {
        return 'Internet Explorer';
    }
    else if (currentUserAgent.indexOf('edge') !== -1) {
        return 'Microsoft Edge';
    }
    else if (currentUserAgent.indexOf('edg') !== -1) {
        return 'Chromium Edge';
    }
    else if (currentUserAgent.indexOf('opr') !== -1) {
        return 'Opera';
    }
    else if (currentUserAgent.indexOf('chrome') !== -1) {
        return 'Google Chrome';
    }
    else if (currentUserAgent.indexOf('safari') !== -1) {
        return 'Safari';
    }
    else if (currentUserAgent.indexOf('firefox') !== -1) {
        return 'FireFox';
    }
    else {
        return 'other Browser';
    }
}


/***/ }),

/***/ "./src/ts/modules/checking-legacy-ie.ts":
/*!**********************************************!*\
  !*** ./src/ts/modules/checking-legacy-ie.ts ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IsLegacyIE": function() { return /* binding */ IsLegacyIE; }
/* harmony export */ });

function IsLegacyIE() {
    var currentUserAgent = window.navigator.userAgent.toLowerCase(), notice = '', targets = [
        'msie 6.0',
        'msie 7.0',
        'msie 8.0',
        'msie 9.0',
        'msie 10.0',
        'trident/7.0'
    ];
    Array.prototype.slice.call(targets).forEach(function (target) {
        if (currentUserAgent.indexOf(target) !== -1) {
            alert(notice);
        }
        else {
            return false;
        }
    });
}


/***/ }),

/***/ "./src/ts/modules/checking-os.ts":
/*!***************************************!*\
  !*** ./src/ts/modules/checking-os.ts ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FindOS": function() { return /* binding */ FindOS; }
/* harmony export */ });

function FindOS() {
    var currentUserAgent = window.navigator.userAgent.toLowerCase();
    if (currentUserAgent.indexOf('windows nt') !== -1) {
        return 'Windows';
    }
    else if ((currentUserAgent.indexOf('android') !== -1) && (currentUserAgent.indexOf('mobile') !== -1)) {
        return 'Android Mobile';
    }
    else if ((currentUserAgent.indexOf('android') !== -1) && (currentUserAgent.indexOf('mobile') === -1)) {
        return 'Android Tablet';
    }
    else if (currentUserAgent.indexOf('iphone') !== -1) {
        return 'iOS iPhone';
    }
    else if (currentUserAgent.indexOf('ipad') !== -1) {
        return 'iOS iPad';
    }
    else if (currentUserAgent.indexOf('mac os') !== -1) {
        return 'Mac OS';
    }
    else {
        return 'other OS';
    }
}


/***/ }),

/***/ "./src/ts/modules/class-intersection-observer-toggleclass.ts":
/*!*******************************************************************!*\
  !*** ./src/ts/modules/class-intersection-observer-toggleclass.ts ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IntersectionObserverToggleClass": function() { return /* binding */ IntersectionObserverToggleClass; }
/* harmony export */ });

var IntersectionObserverToggleClass = (function () {
    function IntersectionObserverToggleClass(settings) {
        var _this = this;
        this.settings = settings;
        this.selector = settings.selector;
        this.className = settings.className;
        this.toggle = settings.toggle;
        this.doObserve = function (element) {
            var targets = document.querySelectorAll(element);
            var options = {
                root: null,
                rootMargin: '0px',
                threshold: 0
            };
            var observer = new IntersectionObserver(function (items) {
                items.forEach(function (item) {
                    if (_this.toggle) {
                        if (item.isIntersecting) {
                            item.target.classList.add(_this.className);
                        }
                        else {
                            item.target.classList.remove(_this.className);
                        }
                    }
                    else {
                        if (item.isIntersecting) {
                            item.target.classList.add(_this.className);
                        }
                    }
                });
            }, options);
            Array.from(targets).forEach(function (target) {
                observer.observe(target);
            });
        };
        this.doObserve(this.selector);
    }
    return IntersectionObserverToggleClass;
}());



/***/ }),

/***/ "./src/ts/vue/app.vue":
/*!****************************!*\
  !*** ./src/ts/vue/app.vue ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _app_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app.vue?vue&type=script&lang=ts */ "./src/ts/vue/app.vue?vue&type=script&lang=ts");
/* harmony import */ var _Users_designsupply_git_github_startify2_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/vue-loader/dist/exportHelper.js */ "./node_modules/vue-loader/dist/exportHelper.js");



;
const __exports__ = /*#__PURE__*/(0,_Users_designsupply_git_github_startify2_node_modules_vue_loader_dist_exportHelper_js__WEBPACK_IMPORTED_MODULE_1__.default)(_app_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__.default, [['__file',"src/ts/vue/app.vue"]])
/* hot reload */
if (false) {}


/* harmony default export */ __webpack_exports__["default"] = (__exports__);

/***/ }),

/***/ "./src/ts/vue/app.vue?vue&type=script&lang=ts":
/*!****************************************************!*\
  !*** ./src/ts/vue/app.vue?vue&type=script&lang=ts ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* reexport safe */ _node_modules_ts_loader_index_js_clonedRuleSet_1_use_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_11_use_0_app_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__.default; }
/* harmony export */ });
/* harmony import */ var _node_modules_ts_loader_index_js_clonedRuleSet_1_use_node_modules_vue_loader_dist_index_js_ruleSet_1_rules_11_use_0_app_vue_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../node_modules/ts-loader/index.js??clonedRuleSet-1.use!../../../node_modules/vue-loader/dist/index.js??ruleSet[1].rules[11].use[0]!./app.vue?vue&type=script&lang=ts */ "./node_modules/ts-loader/index.js??clonedRuleSet-1.use!./node_modules/vue-loader/dist/index.js??ruleSet[1].rules[11].use[0]!./src/ts/vue/app.vue?vue&type=script&lang=ts");
 

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!************************!*\
  !*** ./src/ts/main.ts ***!
  \************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sass_main_sass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sass/main.sass */ "./src/sass/main.sass");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue */ "./node_modules/vue/dist/vue.esm-browser.js");
/* harmony import */ var _modules_class_intersection_observer_toggleclass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modules/class-intersection-observer-toggleclass */ "./src/ts/modules/class-intersection-observer-toggleclass.ts");
/* harmony import */ var _modules_checking_legacy_ie__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modules/checking-legacy-ie */ "./src/ts/modules/checking-legacy-ie.ts");
/* harmony import */ var _modules_checking_os__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modules/checking-os */ "./src/ts/modules/checking-os.ts");
/* harmony import */ var _modules_checking_browser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modules/checking-browser */ "./src/ts/modules/checking-browser.ts");
/* harmony import */ var _vue_app_vue__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./vue/app.vue */ "./src/ts/vue/app.vue");









var app = (0,vue__WEBPACK_IMPORTED_MODULE_2__.createApp)(_vue_app_vue__WEBPACK_IMPORTED_MODULE_7__.default);
app.mount('#app');
jquery__WEBPACK_IMPORTED_MODULE_1___default()(function () {
    console.log('jQuery is ready. use TypeScript');
});
new _modules_class_intersection_observer_toggleclass__WEBPACK_IMPORTED_MODULE_3__.IntersectionObserverToggleClass({
    selector: '.observe_target',
    className: 'observed',
    toggle: true
});
(0,_modules_checking_legacy_ie__WEBPACK_IMPORTED_MODULE_4__.IsLegacyIE)();
(0,_modules_checking_os__WEBPACK_IMPORTED_MODULE_5__.FindOS)();
(0,_modules_checking_browser__WEBPACK_IMPORTED_MODULE_6__.FindBrowser)();

}();
/******/ })()
;
//# sourceMappingURL=main.min.js.map